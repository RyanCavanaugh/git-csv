{
  "id": "MDU6SXNzdWUzODQ2NzQzNQ==",
  "number": 202,
  "createdAt": "2014-07-22T23:52:21Z",
  "title": "Support some non-structural (nominal) type matching",
  "url": "https://github.com/microsoft/TypeScript/issues/202",
  "author": {
    "login": "iislucas"
  },
  "body": "Proposal: support non-structural typing (e.g. new user-defined base-types, or some form of basic nominal typing). This allows programmer to have more refined types supporting frequently used idioms such as: \r\n\r\n1) Indexes that come from different tables. Because all indexes are strings (or numbers), it's easy to use the an index variable (intended for one table) with another index variable intended for a different table. Because indexes are the same type, no error is given. If we have abstract index classes this would be fixed.\r\n\r\n2) Certain classes of functions (e.g. callbacks) can be important to be distinguished even though they have the same type. e.g. \"() => void\" often captures a side-effect producing function. Sometimes you want to control which ones are put into an event handler. Currently there's no way to type-check them. \r\n\r\n3) Consider having 2 different interfaces that have different optional parameters but the same required one. In typescript you will not get a compiler error when you provide one but need the other. Sometimes this is ok, but very often this is very not ok and you would love to have a compiler error rather than be confused at run-time.\r\n\r\nProposal (with all type-Error-lines removed!): \r\n\r\n```\r\n// Define FooTable and FooIndex\r\nnominal FooIndex = string;  // Proposed new kind of nominal declaration.\r\ninterface FooTable {\r\n  [i: FooIndex]: { foo: number };\r\n}\r\nlet s1: FooIndex;\r\nlet t1: FooTable;\r\n\r\n// Define BarTable and BarIndex\r\nnominal BarIndex = string; // Proposed new kind of nominal declaration.\r\ninterface BarTable {\r\n  [i: BarIndex]: { bar: string };\r\n}\r\nlet s2: BarIndex;\r\nlet t2: BarTable;\r\n\r\n// For assignment from base-types and basic structures: no type-overloading is needed.\r\ns1 = 'foo1';\r\nt1 = {};\r\nt1[s1] = { foo: 1 };\r\n\r\ns2 = 'bar1';\r\nt2 = { 'bar1': { bar: 'barbar' }};\r\n\r\nconsole.log(s2 = s1); // Proposed to be type error.\r\nconsole.log(s2 == s1); // Proposed to be type error.\r\nconsole.log(s2 === s1); // Proposed to be type error.\r\n\r\nt1[s2].foo = 100; // Gives a runtime error. Proposed to be type error.\r\nt1[s1].foo = 100;\r\n\r\nfunction BadFooTest(t: FooTable) {\r\n  if (s2 in t) {  // Proposed to be type error.\r\n    console.log('cool');\r\n    console.log(t[s2].foo); // Proposed to be type error.\r\n  }\r\n}\r\n\r\nfunction GoodBarTest(t: BarTable) {\r\n  if (s2 in t) {\r\n    console.log('cool');\r\n    console.log(t[s2].bar);\r\n  }\r\n}\r\n\r\nBadFooTest(t1); // Gives runtime error;\r\nBadFooTest(t2); // No runtime error, Proposed to be type error.\r\nGoodBarTest(t1); // Gives runtime error; Proposed to be type error.\r\nGoodBarTest(t2);\r\n```\r\n",
  "bodyHTML": "<p dir=\"auto\">Proposal: support non-structural typing (e.g. new user-defined base-types, or some form of basic nominal typing). This allows programmer to have more refined types supporting frequently used idioms such as:</p>\n<ol dir=\"auto\">\n<li>\n<p dir=\"auto\">Indexes that come from different tables. Because all indexes are strings (or numbers), it's easy to use the an index variable (intended for one table) with another index variable intended for a different table. Because indexes are the same type, no error is given. If we have abstract index classes this would be fixed.</p>\n</li>\n<li>\n<p dir=\"auto\">Certain classes of functions (e.g. callbacks) can be important to be distinguished even though they have the same type. e.g. \"() =&gt; void\" often captures a side-effect producing function. Sometimes you want to control which ones are put into an event handler. Currently there's no way to type-check them.</p>\n</li>\n<li>\n<p dir=\"auto\">Consider having 2 different interfaces that have different optional parameters but the same required one. In typescript you will not get a compiler error when you provide one but need the other. Sometimes this is ok, but very often this is very not ok and you would love to have a compiler error rather than be confused at run-time.</p>\n</li>\n</ol>\n<p dir=\"auto\">Proposal (with all type-Error-lines removed!):</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"// Define FooTable and FooIndex\nnominal FooIndex = string;  // Proposed new kind of nominal declaration.\ninterface FooTable {\n  [i: FooIndex]: { foo: number };\n}\nlet s1: FooIndex;\nlet t1: FooTable;\n\n// Define BarTable and BarIndex\nnominal BarIndex = string; // Proposed new kind of nominal declaration.\ninterface BarTable {\n  [i: BarIndex]: { bar: string };\n}\nlet s2: BarIndex;\nlet t2: BarTable;\n\n// For assignment from base-types and basic structures: no type-overloading is needed.\ns1 = 'foo1';\nt1 = {};\nt1[s1] = { foo: 1 };\n\ns2 = 'bar1';\nt2 = { 'bar1': { bar: 'barbar' }};\n\nconsole.log(s2 = s1); // Proposed to be type error.\nconsole.log(s2 == s1); // Proposed to be type error.\nconsole.log(s2 === s1); // Proposed to be type error.\n\nt1[s2].foo = 100; // Gives a runtime error. Proposed to be type error.\nt1[s1].foo = 100;\n\nfunction BadFooTest(t: FooTable) {\n  if (s2 in t) {  // Proposed to be type error.\n    console.log('cool');\n    console.log(t[s2].foo); // Proposed to be type error.\n  }\n}\n\nfunction GoodBarTest(t: BarTable) {\n  if (s2 in t) {\n    console.log('cool');\n    console.log(t[s2].bar);\n  }\n}\n\nBadFooTest(t1); // Gives runtime error;\nBadFooTest(t2); // No runtime error, Proposed to be type error.\nGoodBarTest(t1); // Gives runtime error; Proposed to be type error.\nGoodBarTest(t2);\"><pre class=\"notranslate\"><code class=\"notranslate\">// Define FooTable and FooIndex\nnominal FooIndex = string;  // Proposed new kind of nominal declaration.\ninterface FooTable {\n  [i: FooIndex]: { foo: number };\n}\nlet s1: FooIndex;\nlet t1: FooTable;\n\n// Define BarTable and BarIndex\nnominal BarIndex = string; // Proposed new kind of nominal declaration.\ninterface BarTable {\n  [i: BarIndex]: { bar: string };\n}\nlet s2: BarIndex;\nlet t2: BarTable;\n\n// For assignment from base-types and basic structures: no type-overloading is needed.\ns1 = 'foo1';\nt1 = {};\nt1[s1] = { foo: 1 };\n\ns2 = 'bar1';\nt2 = { 'bar1': { bar: 'barbar' }};\n\nconsole.log(s2 = s1); // Proposed to be type error.\nconsole.log(s2 == s1); // Proposed to be type error.\nconsole.log(s2 === s1); // Proposed to be type error.\n\nt1[s2].foo = 100; // Gives a runtime error. Proposed to be type error.\nt1[s1].foo = 100;\n\nfunction BadFooTest(t: FooTable) {\n  if (s2 in t) {  // Proposed to be type error.\n    console.log('cool');\n    console.log(t[s2].foo); // Proposed to be type error.\n  }\n}\n\nfunction GoodBarTest(t: BarTable) {\n  if (s2 in t) {\n    console.log('cool');\n    console.log(t[s2].bar);\n  }\n}\n\nBadFooTest(t1); // Gives runtime error;\nBadFooTest(t2); // No runtime error, Proposed to be type error.\nGoodBarTest(t1); // Gives runtime error; Proposed to be type error.\nGoodBarTest(t2);\n</code></pre></div>",
  "reactionGroups": [
    {
      "content": "THUMBS_UP",
      "reactors": {
        "totalCount": 741
      }
    },
    {
      "content": "THUMBS_DOWN",
      "reactors": {
        "totalCount": 8
      }
    },
    {
      "content": "LAUGH",
      "reactors": {
        "totalCount": 0
      }
    },
    {
      "content": "HOORAY",
      "reactors": {
        "totalCount": 0
      }
    },
    {
      "content": "CONFUSED",
      "reactors": {
        "totalCount": 0
      }
    },
    {
      "content": "HEART",
      "reactors": {
        "totalCount": 150
      }
    },
    {
      "content": "ROCKET",
      "reactors": {
        "totalCount": 42
      }
    },
    {
      "content": "EYES",
      "reactors": {
        "totalCount": 15
      }
    }
  ],
  "closed": false,
  "locked": false,
  "milestone": null,
  "assignees": {
    "nodes": []
  },
  "labels": {
    "nodes": [
      {
        "id": "MDU6TGFiZWwxMTM5NzExNTU=",
        "name": "Suggestion",
        "color": "006b75"
      },
      {
        "id": "MDU6TGFiZWwxMTc2MzA1NjA=",
        "name": "In Discussion",
        "color": "556b75"
      }
    ]
  },
  "timelineItems": {
    "pageInfo": {
      "endCursor": "Y3Vyc29yOnYyOpPPAAABVyI3XGAAqTI0NjU4NjcyMA==",
      "hasNextPage": true
    },
    "nodes": [
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5ODIxMTIz",
        "author": {
          "login": "RyanCavanaugh"
        },
        "authorAssociation": "MEMBER",
        "body": "Is there a better keyword here than \"abstract\" ? People are going to confuse it with \"abstract class\".\n\n+Needs Proposal\n",
        "bodyHTML": "<p dir=\"auto\">Is there a better keyword here than \"abstract\" ? People are going to confuse it with \"abstract class\".</p>\n<p dir=\"auto\">+Needs Proposal</p>",
        "createdAt": "2014-07-23T00:58:33Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-49821123",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 16
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "LabeledEvent",
        "createdAt": "2014-07-23T00:58:41Z",
        "actor": {
          "login": "RyanCavanaugh"
        },
        "label": {
          "id": "MDU6TGFiZWww",
          "name": "Suggestion",
          "color": "006b75"
        }
      },
      {
        "__typename": "LabeledEvent",
        "createdAt": "2014-07-23T00:58:44Z",
        "actor": {
          "login": "RyanCavanaugh"
        },
        "label": {
          "id": "MDU6TGFiZWww",
          "name": "Needs Proposal",
          "color": "bfdadc"
        }
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5ODIzNjU1",
        "author": {
          "login": "iislucas"
        },
        "authorAssociation": "NONE",
        "body": "w.r.t. Needs Proposal: do you mean how to implement it? For compilation to JS, nothing needs to be changed. But would need internal identifiers for new types being introduced and an extra check at assignment. \n",
        "bodyHTML": "<p dir=\"auto\">w.r.t. Needs Proposal: do you mean how to implement it? For compilation to JS, nothing needs to be changed. But would need internal identifiers for new types being introduced and an extra check at assignment.</p>",
        "createdAt": "2014-07-23T01:41:20Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-49823655",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5ODI5MTY5",
        "author": {
          "login": "samwgoldman"
        },
        "authorAssociation": "NONE",
        "body": "Regarding a name, what about \"nominal\" types? Seems pretty common in literature.\n",
        "bodyHTML": "<p dir=\"auto\">Regarding a name, what about \"nominal\" types? Seems pretty common in literature.</p>",
        "createdAt": "2014-07-23T03:29:05Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-49829169",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 62
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5ODI5NjQz",
        "author": {
          "login": "RyanCavanaugh"
        },
        "authorAssociation": "MEMBER",
        "body": "We're still writing up the exact guidelines on suggestions, but basically \"Needs Proposal\" means that we're looking for someone to write up a detailed formal explanation of what the suggestion means so that it can be more accurately evaluated.\n\nIn this case, that would mean a description of how these types would fit in to all the various type algorithms in the spec, defining in precise language any \"special case\" things, listing motivating examples, and writing out error and non-error cases for each new or modified rule.\n",
        "bodyHTML": "<p dir=\"auto\">We're still writing up the exact guidelines on suggestions, but basically \"Needs Proposal\" means that we're looking for someone to write up a detailed formal explanation of what the suggestion means so that it can be more accurately evaluated.</p>\n<p dir=\"auto\">In this case, that would mean a description of how these types would fit in to all the various type algorithms in the spec, defining in precise language any \"special case\" things, listing motivating examples, and writing out error and non-error cases for each new or modified rule.</p>",
        "createdAt": "2014-07-23T03:39:58Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-49829643",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5ODMwNjIy",
        "author": {
          "login": "iislucas"
        },
        "authorAssociation": "NONE",
        "body": "@RyanCavanaugh Thanks! Not sure I have time for that this evening :)  but if the idea would be seriously considered I can either do it, to get someone on my team to do so. Would you want an implementation also? Or would a clear design proposal suffice? \n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/RyanCavanaugh/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/RyanCavanaugh\">@RyanCavanaugh</a> Thanks! Not sure I have time for that this evening :)  but if the idea would be seriously considered I can either do it, to get someone on my team to do so. Would you want an implementation also? Or would a clear design proposal suffice?</p>",
        "createdAt": "2014-07-23T04:00:24Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-49830622",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5ODMyOTU5",
        "author": {
          "login": "danquirk"
        },
        "authorAssociation": "MEMBER",
        "body": "@iislucas no implementation is necessary for \"Needs Proposal\" issues, just something on the more formal side like Ryan described. No rush ;)\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/iislucas/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/iislucas\">@iislucas</a> no implementation is necessary for \"Needs Proposal\" issues, just something on the more formal side like Ryan described. No rush ;)</p>",
        "createdAt": "2014-07-23T04:55:07Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-49832959",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwMTk5NzEz",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "There is a workaround that I use a lot in my code to get nominal typing, consider:\n\n```\ninterface NominalA {\n   'I am a nominal type A, nobody can match me to anything I am not': NominalA;\n    value: number;\n}\n\ninterface NominalB {\n   'I am a nominal type B, mostly like A but yet quite different': NominalB;\n   value: number;\n}\n\n// using <any> on constructing instances of such nominal types is the price you have to pay\n// I use special constructor functions that do casting internally producing a nominal object to avoid doing it everywhere\nvar a : NominalA = <any>  { value: 1 };\nvar b : NominalB = <any>  { value: 2 };\n\na = b; // <-- problema\n```\n",
        "bodyHTML": "<p dir=\"auto\">There is a workaround that I use a lot in my code to get nominal typing, consider:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"interface NominalA {\n   'I am a nominal type A, nobody can match me to anything I am not': NominalA;\n    value: number;\n}\n\ninterface NominalB {\n   'I am a nominal type B, mostly like A but yet quite different': NominalB;\n   value: number;\n}\n\n// using &lt;any&gt; on constructing instances of such nominal types is the price you have to pay\n// I use special constructor functions that do casting internally producing a nominal object to avoid doing it everywhere\nvar a : NominalA = &lt;any&gt;  { value: 1 };\nvar b : NominalB = &lt;any&gt;  { value: 2 };\n\na = b; // &lt;-- problema\"><pre class=\"notranslate\"><code class=\"notranslate\">interface NominalA {\n   'I am a nominal type A, nobody can match me to anything I am not': NominalA;\n    value: number;\n}\n\ninterface NominalB {\n   'I am a nominal type B, mostly like A but yet quite different': NominalB;\n   value: number;\n}\n\n// using &lt;any&gt; on constructing instances of such nominal types is the price you have to pay\n// I use special constructor functions that do casting internally producing a nominal object to avoid doing it everywhere\nvar a : NominalA = &lt;any&gt;  { value: 1 };\nvar b : NominalB = &lt;any&gt;  { value: 2 };\n\na = b; // &lt;-- problema\n</code></pre></div>",
        "createdAt": "2014-07-25T20:23:35Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50199713",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 24
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 8
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwMjIxODQz",
        "author": {
          "login": "iislucas"
        },
        "authorAssociation": "NONE",
        "body": "Neat trick! Slight optimization, you can use: \n\n```\nvar a = <NominalA>  { value: 1 };\nvar b = <NominalB>  { value: 2 };\n```\n\n(Slightly nicer/safer looking syntax)\n[Shame it doesn't work for creating distinct types for string that you want to be indexable]\n",
        "bodyHTML": "<p dir=\"auto\">Neat trick! Slight optimization, you can use:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"var a = &lt;NominalA&gt;  { value: 1 };\nvar b = &lt;NominalB&gt;  { value: 2 };\"><pre class=\"notranslate\"><code class=\"notranslate\">var a = &lt;NominalA&gt;  { value: 1 };\nvar b = &lt;NominalB&gt;  { value: 2 };\n</code></pre></div>\n<p dir=\"auto\">(Slightly nicer/safer looking syntax)<br>\n[Shame it doesn't work for creating distinct types for string that you want to be indexable]</p>",
        "createdAt": "2014-07-26T03:19:20Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50221843",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 15
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwMjIyMzMy",
        "author": {
          "login": "basarat"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@aleksey-bykov nice trick. We have nominal Id types on the server (c#) that are serialized as strings (and we like this serialization). We've wondered of a good way to do that without it all being `string` on the client. We haven't seen bugs around this on the client but we still would have liked that safety. Based on your code the following looks promising (all interfaces will be codegened): \n\n``` ts\n// FOO \ninterface FooId{\n    'FooId':string; // To prevent type errors\n}\ninterface String{   // To ease client side assignment from string\n    'FooId':string;\n}\n// BAR\ninterface BarId{\n    'BarId':string; // To prevent type errors\n}\ninterface String{   // To ease client side assignment from string\n    'BarId':string;\n}\n\n\nvar fooId: FooId;\nvar barId: BarId;\n\n// Safety!\nfooId = barId; // error \nbarId = fooId; // error \nfooId = <FooId>barId; // error \nbarId = <BarId>fooId; // error\n\n// client side assignment. Think of it as \"new Id\"\nfooId = <FooId>'foo';\nbarId = <BarId>'bar';\n\n// If you need the base string \n// (for generic code that might operate on base identity)\nvar str:string;\nstr = <string>fooId;\nstr = <string>barId;  \n```\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Aleksey-Bykov/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Aleksey-Bykov\">@Aleksey-Bykov</a> nice trick. We have nominal Id types on the server (c#) that are serialized as strings (and we like this serialization). We've wondered of a good way to do that without it all being <code class=\"notranslate\">string</code> on the client. We haven't seen bugs around this on the client but we still would have liked that safety. Based on your code the following looks promising (all interfaces will be codegened):</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// FOO \ninterface FooId{\n    'FooId':string; // To prevent type errors\n}\ninterface String{   // To ease client side assignment from string\n    'FooId':string;\n}\n// BAR\ninterface BarId{\n    'BarId':string; // To prevent type errors\n}\ninterface String{   // To ease client side assignment from string\n    'BarId':string;\n}\n\n\nvar fooId: FooId;\nvar barId: BarId;\n\n// Safety!\nfooId = barId; // error \nbarId = fooId; // error \nfooId = &lt;FooId&gt;barId; // error \nbarId = &lt;BarId&gt;fooId; // error\n\n// client side assignment. Think of it as &quot;new Id&quot;\nfooId = &lt;FooId&gt;'foo';\nbarId = &lt;BarId&gt;'bar';\n\n// If you need the base string \n// (for generic code that might operate on base identity)\nvar str:string;\nstr = &lt;string&gt;fooId;\nstr = &lt;string&gt;barId;  \"><pre class=\"notranslate\"><span class=\"pl-c\">// FOO </span>\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">FooId</span><span class=\"pl-kos\">{</span>\n    <span class=\"pl-s\">'FooId'</span>:<span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// To prevent type errors</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">String</span><span class=\"pl-kos\">{</span>   <span class=\"pl-c\">// To ease client side assignment from string</span>\n    <span class=\"pl-s\">'FooId'</span>:<span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-c\">// BAR</span>\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">BarId</span><span class=\"pl-kos\">{</span>\n    <span class=\"pl-s\">'BarId'</span>:<span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// To prevent type errors</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">String</span><span class=\"pl-kos\">{</span>   <span class=\"pl-c\">// To ease client side assignment from string</span>\n    <span class=\"pl-s\">'BarId'</span>:<span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n\n<span class=\"pl-k\">var</span> <span class=\"pl-s1\">fooId</span>: <span class=\"pl-smi\">FooId</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">var</span> <span class=\"pl-s1\">barId</span>: <span class=\"pl-smi\">BarId</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// Safety!</span>\n<span class=\"pl-s1\">fooId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">barId</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error </span>\n<span class=\"pl-s1\">barId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">fooId</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error </span>\n<span class=\"pl-s1\">fooId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">FooId</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-s1\">barId</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error </span>\n<span class=\"pl-s1\">barId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">BarId</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-s1\">fooId</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error</span>\n\n<span class=\"pl-c\">// client side assignment. Think of it as \"new Id\"</span>\n<span class=\"pl-s1\">fooId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">FooId</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-s\">'foo'</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">barId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">BarId</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-s\">'bar'</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// If you need the base string </span>\n<span class=\"pl-c\">// (for generic code that might operate on base identity)</span>\n<span class=\"pl-k\">var</span> <span class=\"pl-s1\">str</span>:<span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">str</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-s1\">fooId</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">str</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-s1\">barId</span><span class=\"pl-kos\">;</span>  </pre></div>",
        "createdAt": "2014-07-26T03:48:02Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50222332",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwNzMzNzIz",
        "author": {
          "login": "Steve-Fenton"
        },
        "authorAssociation": "NONE",
        "body": "We could look at an implementation that largely left the syntax untouched: perhaps we could add a single new keyword that switches on \"nominality\" for a given interface. That would leave the TypeScript syntax largely unchanged and familiar.\n\n```\nclass Customer {\n    lovesUs: boolean;\n}\n\nnamed class Client {\n    lovesUs: boolean;\n}\n\nfunction exampleA(customer: Customer) {\n\n}\n\nfunction exampleB(customer: Client) {\n\n}\n\nvar customer = new Customer();\nvar client = new Client();\n\nexampleA(customer);\nexampleA(client);\n\nexampleB(customer); // <- Not allowed\nexampleB(client);\n```\n\nSo you can use a Client where a Customer is needed, but not vice versa.\n\nYou could fix the error in this example by having Customer extend Client, or by using the correct named type - at which point the error goes away.\n\nYou could use the \"named\" switch on classes and interfaces.\n",
        "bodyHTML": "<p dir=\"auto\">We could look at an implementation that largely left the syntax untouched: perhaps we could add a single new keyword that switches on \"nominality\" for a given interface. That would leave the TypeScript syntax largely unchanged and familiar.</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"class Customer {\n    lovesUs: boolean;\n}\n\nnamed class Client {\n    lovesUs: boolean;\n}\n\nfunction exampleA(customer: Customer) {\n\n}\n\nfunction exampleB(customer: Client) {\n\n}\n\nvar customer = new Customer();\nvar client = new Client();\n\nexampleA(customer);\nexampleA(client);\n\nexampleB(customer); // &lt;- Not allowed\nexampleB(client);\"><pre class=\"notranslate\"><code class=\"notranslate\">class Customer {\n    lovesUs: boolean;\n}\n\nnamed class Client {\n    lovesUs: boolean;\n}\n\nfunction exampleA(customer: Customer) {\n\n}\n\nfunction exampleB(customer: Client) {\n\n}\n\nvar customer = new Customer();\nvar client = new Client();\n\nexampleA(customer);\nexampleA(client);\n\nexampleB(customer); // &lt;- Not allowed\nexampleB(client);\n</code></pre></div>\n<p dir=\"auto\">So you can use a Client where a Customer is needed, but not vice versa.</p>\n<p dir=\"auto\">You could fix the error in this example by having Customer extend Client, or by using the correct named type - at which point the error goes away.</p>\n<p dir=\"auto\">You could use the \"named\" switch on classes and interfaces.</p>",
        "createdAt": "2014-07-31T08:52:11Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50733723",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 20
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwNzQ2NTEy",
        "author": {
          "login": "basarat"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> You could use the \"named\" switch on classes and interfaces.\n\n:+1: \n",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">You could use the \"named\" switch on classes and interfaces.</p>\n</blockquote>\n<p dir=\"auto\">👍</p>",
        "createdAt": "2014-07-31T11:24:53Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50746512",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwODE1ODM5",
        "author": {
          "login": "Steve-Fenton"
        },
        "authorAssociation": "NONE",
        "body": "You could also use it to make a type nominal in a specific context, even if the type was not marked as nominal:\n\n```\nfunction getById(id: named CustomerId) {\n    //...\n```\n",
        "bodyHTML": "<p dir=\"auto\">You could also use it to make a type nominal in a specific context, even if the type was not marked as nominal:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"function getById(id: named CustomerId) {\n    //...\"><pre class=\"notranslate\"><code class=\"notranslate\">function getById(id: named CustomerId) {\n    //...\n</code></pre></div>",
        "createdAt": "2014-07-31T20:44:04Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50815839",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwODE2NzMz",
        "author": {
          "login": "RyanCavanaugh"
        },
        "authorAssociation": "MEMBER",
        "body": "> You could also use it to make a type nominal in a specific context\n\nWhat would that mean?\n",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">You could also use it to make a type nominal in a specific context</p>\n</blockquote>\n<p dir=\"auto\">What would that mean?</p>",
        "createdAt": "2014-07-31T20:50:57Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50816733",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwODE3MjAw",
        "author": {
          "login": "Steve-Fenton"
        },
        "authorAssociation": "NONE",
        "body": "When used as part of a type annotation, it would tell the compiler to compare types nominally, rather than structurally - so you could decide when it is important for the exact type, and when it isn't.\n\nIt would be equivalent to specifying it on the class or interface, but would allow you to create a \"structural\" interface that in your specific case is treated as \"nominal\".\n\nOr, I have jumped the shark :) !\n",
        "bodyHTML": "<p dir=\"auto\">When used as part of a type annotation, it would tell the compiler to compare types nominally, rather than structurally - so you could decide when it is important for the exact type, and when it isn't.</p>\n<p dir=\"auto\">It would be equivalent to specifying it on the class or interface, but would allow you to create a \"structural\" interface that in your specific case is treated as \"nominal\".</p>\n<p dir=\"auto\">Or, I have jumped the shark :) !</p>",
        "createdAt": "2014-07-31T20:54:39Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50817200",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwODE5MDcx",
        "author": {
          "login": "RyanCavanaugh"
        },
        "authorAssociation": "MEMBER",
        "body": "An example of an error (or _non_-error) would be nice. I can't figure out how you'd even use this thing\n\n``` ts\ninterface CustomerId { name: string }\ninterface OrderId { name: string }\nfunction getById(id: named CustomerId) {\n    //...\n}\nvar x = {name: 'bob'};\ngetById(x); // Error, x is not the nominal 'named CustomerId' ?\n\nfunction doubleNamed1(a: named CustomerId, b: named OrderId) {\n    a = b; // Legal? Not legal?\n}\nfunction doubleNamed2(a: named CustomerId, b: named CustomerId) {\n    a = b; // Legal? Not legal?\n}\nfunction namedAnon(x: named { name: string }) {\n     // What does this even mean? How would I make a value compatible with 'x' ?\n}\n```\n",
        "bodyHTML": "<p dir=\"auto\">An example of an error (or <em>non</em>-error) would be nice. I can't figure out how you'd even use this thing</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"interface CustomerId { name: string }\ninterface OrderId { name: string }\nfunction getById(id: named CustomerId) {\n    //...\n}\nvar x = {name: 'bob'};\ngetById(x); // Error, x is not the nominal 'named CustomerId' ?\n\nfunction doubleNamed1(a: named CustomerId, b: named OrderId) {\n    a = b; // Legal? Not legal?\n}\nfunction doubleNamed2(a: named CustomerId, b: named CustomerId) {\n    a = b; // Legal? Not legal?\n}\nfunction namedAnon(x: named { name: string }) {\n     // What does this even mean? How would I make a value compatible with 'x' ?\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">interface</span> <span class=\"pl-smi\">CustomerId</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">name</span>: <span class=\"pl-smi\">string</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">OrderId</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">name</span>: <span class=\"pl-smi\">string</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">getById</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">id</span>: <span class=\"pl-s1\">named</span> <span class=\"pl-smi\">CustomerId</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c\">//...</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">var</span> <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span><span class=\"pl-c1\">name</span>: <span class=\"pl-s\">'bob'</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-en\">getById</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// Error, x is not the nominal 'named CustomerId' ?</span>\n\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">doubleNamed1</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">a</span>: <span class=\"pl-s1\">named</span> <span class=\"pl-smi\">CustomerId</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">b</span>: <span class=\"pl-s1\">named</span> <span class=\"pl-smi\">OrderId</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-s1\">a</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">b</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// Legal? Not legal?</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">doubleNamed2</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">a</span>: <span class=\"pl-s1\">named</span> <span class=\"pl-smi\">CustomerId</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">b</span>: <span class=\"pl-s1\">named</span> <span class=\"pl-smi\">CustomerId</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-s1\">a</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">b</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// Legal? Not legal?</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">namedAnon</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">named</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">name</span>: <span class=\"pl-s1\">string</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n     <span class=\"pl-c\">// What does this even mean? How would I make a value compatible with 'x' ?</span>\n<span class=\"pl-kos\">}</span></pre></div>",
        "createdAt": "2014-07-31T21:09:39Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50819071",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwODIxOTI3",
        "author": {
          "login": "Steve-Fenton"
        },
        "authorAssociation": "NONE",
        "body": "This is why I'm not a language designer :)\n\nI've shown in the example below that the keyword applies for the scope of the variable. If you make a parameter nominal, it is nominal for the whole function.\n\n```\ninterface CustomerId { name: string }\ninterface OrderId { name: string }\nfunction getById(id: named CustomerId) {\n    //...\n}\nvar x = {name: 'bob'};\ngetById(x); // Error, x is not the nominal 'named CustomerId'\n\nfunction doubleNamed1(a: named CustomerId, b: named OrderId) {\n    a = b; // Not legal, a is considered to be a nominal type\n}\nfunction doubleNamed2(a: named CustomerId, b: named CustomerId) {\n    a = b; // Legal, a is compared nominally to b and they are the same type\n}\nfunction singleNamed1(a: named CustomerId, b: CustomerId) {\n    a = b; // Legal, a is compared nominally to b and they are the same type\n}\nfunction namedAnon(x: named { name: string }) {\n     // Compiler error - the \"named\" keyword can only be applied to interfaces and classes\n}\n```\n",
        "bodyHTML": "<p dir=\"auto\">This is why I'm not a language designer :)</p>\n<p dir=\"auto\">I've shown in the example below that the keyword applies for the scope of the variable. If you make a parameter nominal, it is nominal for the whole function.</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"interface CustomerId { name: string }\ninterface OrderId { name: string }\nfunction getById(id: named CustomerId) {\n    //...\n}\nvar x = {name: 'bob'};\ngetById(x); // Error, x is not the nominal 'named CustomerId'\n\nfunction doubleNamed1(a: named CustomerId, b: named OrderId) {\n    a = b; // Not legal, a is considered to be a nominal type\n}\nfunction doubleNamed2(a: named CustomerId, b: named CustomerId) {\n    a = b; // Legal, a is compared nominally to b and they are the same type\n}\nfunction singleNamed1(a: named CustomerId, b: CustomerId) {\n    a = b; // Legal, a is compared nominally to b and they are the same type\n}\nfunction namedAnon(x: named { name: string }) {\n     // Compiler error - the &quot;named&quot; keyword can only be applied to interfaces and classes\n}\"><pre class=\"notranslate\"><code class=\"notranslate\">interface CustomerId { name: string }\ninterface OrderId { name: string }\nfunction getById(id: named CustomerId) {\n    //...\n}\nvar x = {name: 'bob'};\ngetById(x); // Error, x is not the nominal 'named CustomerId'\n\nfunction doubleNamed1(a: named CustomerId, b: named OrderId) {\n    a = b; // Not legal, a is considered to be a nominal type\n}\nfunction doubleNamed2(a: named CustomerId, b: named CustomerId) {\n    a = b; // Legal, a is compared nominally to b and they are the same type\n}\nfunction singleNamed1(a: named CustomerId, b: CustomerId) {\n    a = b; // Legal, a is compared nominally to b and they are the same type\n}\nfunction namedAnon(x: named { name: string }) {\n     // Compiler error - the \"named\" keyword can only be applied to interfaces and classes\n}\n</code></pre></div>",
        "createdAt": "2014-07-31T21:33:35Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50821927",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwODIyODYx",
        "author": {
          "login": "Steve-Fenton"
        },
        "authorAssociation": "NONE",
        "body": "I admit that the notion of marking an item as nominal temporarily as per these recent examples may have been a little flippant - in the process of thinking through the implications of the feature I'm happy to accept it may be a terrible idea.\n\nI'd hate for that to affect the much more straightforward idea marking a class or interface as nominal at the point it is defined.\n",
        "bodyHTML": "<p dir=\"auto\">I admit that the notion of marking an item as nominal temporarily as per these recent examples may have been a little flippant - in the process of thinking through the implications of the feature I'm happy to accept it may be a terrible idea.</p>\n<p dir=\"auto\">I'd hate for that to affect the much more straightforward idea marking a class or interface as nominal at the point it is defined.</p>",
        "createdAt": "2014-07-31T21:41:48Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50822861",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwODUwNjc2",
        "author": {
          "login": "basarat"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Will need an inline creation syntax. Suggestion, a named assertion:\n\n``` ts\nvar x = <named CustomerId>{name: 'bob'};  // x is now named `CustomerId`\ngetById(x); // okay\n```\n\nPerhaps there can be a better one.\n",
        "bodyHTML": "<p dir=\"auto\">Will need an inline creation syntax. Suggestion, a named assertion:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"var x = &lt;named CustomerId&gt;{name: 'bob'};  // x is now named `CustomerId`\ngetById(x); // okay\"><pre class=\"notranslate\"><span class=\"pl-k\">var</span> <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-s1\">named</span> <span class=\"pl-smi\">CustomerId</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">{</span><span class=\"pl-c1\">name</span>: <span class=\"pl-s\">'bob'</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>  <span class=\"pl-c\">// x is now named `CustomerId`</span>\n<span class=\"pl-en\">getById</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// okay</span></pre></div>\n<p dir=\"auto\">Perhaps there can be a better one.</p>",
        "createdAt": "2014-08-01T05:39:12Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50850676",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwODY2NjMx",
        "author": {
          "login": "ComFreek"
        },
        "authorAssociation": "NONE",
        "body": "I wonder what the use cases for library developers are to _not_ request nominal type checking via `name`.\n\nWouldn't you always be on the safe side if you use `name` by default? If the caller does have the right type, all is fine. If he doesn't, he must convert it (e.g. using the syntax @basarat suggested). If the conversion works, but doesn't work as expected, it's the user's fault and not the library developer's fault.\n\nMaybe the whole problem is the duck typing system itself. But that's one problem TypeScript shouldn't solve, I suppose.\n",
        "bodyHTML": "<p dir=\"auto\">I wonder what the use cases for library developers are to <em>not</em> request nominal type checking via <code class=\"notranslate\">name</code>.</p>\n<p dir=\"auto\">Wouldn't you always be on the safe side if you use <code class=\"notranslate\">name</code> by default? If the caller does have the right type, all is fine. If he doesn't, he must convert it (e.g. using the syntax <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/basarat/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/basarat\">@basarat</a> suggested). If the conversion works, but doesn't work as expected, it's the user's fault and not the library developer's fault.</p>\n<p dir=\"auto\">Maybe the whole problem is the duck typing system itself. But that's one problem TypeScript shouldn't solve, I suppose.</p>",
        "createdAt": "2014-08-01T09:38:38Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50866631",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwOTE2Njk5",
        "author": {
          "login": "jntrnr"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Not to sound like a sour puss, but being a structural type system is a fork in the road early on in how the type system works.  We intentionally went structural to fit in better with JavaScript and then added layer upon layer of type system machinery on top of it that assumes things are structural.  To pull up the floor boards and rethink that is a ton of work, and I'm not clear on how it adds enough value to pay for itself.  \n\nIt's worth noting, too, the complexity it adds in terms of usability.  Now people would always need to think about \"is this type going to be used nominally or structurally?\" Like Ryan shows, once you mix in patterns that are common in TypeScript the story gets murky.  \n\nIt may have been mentioned already, but a good article for rules of thumb on new features is this one: http://blogs.msdn.com/b/ericgu/archive/2004/01/12/57985.aspx\n\nThe gist is that assume every new feature starts at -100 points and has to pay for itself in terms of added benefit.  Something that causes a deep rethink of the type system is probably an order of magnitude worse.  Not to say it's impossible.  Rather, it's highly unlikely a feature could be worth so much.\n",
        "bodyHTML": "<p dir=\"auto\">Not to sound like a sour puss, but being a structural type system is a fork in the road early on in how the type system works.  We intentionally went structural to fit in better with JavaScript and then added layer upon layer of type system machinery on top of it that assumes things are structural.  To pull up the floor boards and rethink that is a ton of work, and I'm not clear on how it adds enough value to pay for itself.</p>\n<p dir=\"auto\">It's worth noting, too, the complexity it adds in terms of usability.  Now people would always need to think about \"is this type going to be used nominally or structurally?\" Like Ryan shows, once you mix in patterns that are common in TypeScript the story gets murky.</p>\n<p dir=\"auto\">It may have been mentioned already, but a good article for rules of thumb on new features is this one: <a href=\"http://blogs.msdn.com/b/ericgu/archive/2004/01/12/57985.aspx\" rel=\"nofollow\">http://blogs.msdn.com/b/ericgu/archive/2004/01/12/57985.aspx</a></p>\n<p dir=\"auto\">The gist is that assume every new feature starts at -100 points and has to pay for itself in terms of added benefit.  Something that causes a deep rethink of the type system is probably an order of magnitude worse.  Not to say it's impossible.  Rather, it's highly unlikely a feature could be worth so much.</p>",
        "createdAt": "2014-08-01T18:12:06Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50916699",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 25
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 10
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 6
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 2
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwOTIwNTU2",
        "author": {
          "login": "danquirk"
        },
        "authorAssociation": "MEMBER",
        "body": "Agree with Jonathan here. I would have to see an extremely thorough proposal with some large code examples that prove this doesn't quickly become unmanageable. I have a hard time imagining how you could effectively use this modifier in a restricted set of circumstances without it leaking everywhere and ending up with you needing to use it on every type in your program (or giving up entirely on things like object literals). At that point you're talking about a different language that is basically incompatible with JavaScript.\n\nRemember that nominal systems come with pain too and have patterns they don't represent as well. The trade off to enable those patterns with a structural system is the occasional overlap of structurally equal but conceptually different types. \n",
        "bodyHTML": "<p dir=\"auto\">Agree with Jonathan here. I would have to see an extremely thorough proposal with some large code examples that prove this doesn't quickly become unmanageable. I have a hard time imagining how you could effectively use this modifier in a restricted set of circumstances without it leaking everywhere and ending up with you needing to use it on every type in your program (or giving up entirely on things like object literals). At that point you're talking about a different language that is basically incompatible with JavaScript.</p>\n<p dir=\"auto\">Remember that nominal systems come with pain too and have patterns they don't represent as well. The trade off to enable those patterns with a structural system is the occasional overlap of structurally equal but conceptually different types.</p>",
        "createdAt": "2014-08-01T18:45:51Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50920556",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwOTMwMjky",
        "author": {
          "login": "Steve-Fenton"
        },
        "authorAssociation": "NONE",
        "body": "So the most common use case for this (that I can think of) is type-safe ids. Currently, you _can_ create these in TypeScript by adding a private member to a class (or a crazy identifier on an interface, although that only reduces the chance, whereas the private member trick works as expected).\n\nYou have already made the decision that you want a nominal type when you create a type safe id class, because that is the purpose of such a class (and is the reason you aren't simply using `number`).\n\nSo my question is as follows, this code does what a lot of people want:\n\n``` ts\n    class ExampleId {\n        constructor(public value: number){}\n        private notused: string;\n    }\n```\n\ni.e. you cannot create another type that will satisfy this structure, because of the private member...\n1. Would it be possible to formalise _this_ behaviour with a keyword so the private member isn't needed?\n2. Would it be possible to get this behaviour for interfaces?\n\nThe first of these two questions would probably cover 80% of the use cases. The second would allow similar cases and would be very useful from a `.d.ts` perspective.\n\nThis limits the feature to the creation of types that cannot be matched, which is already possible as described and for classes simply moves a \"magic fix\" into a more deliberate keyword.\n\nI would be happy to write up something for this.\n",
        "bodyHTML": "<p dir=\"auto\">So the most common use case for this (that I can think of) is type-safe ids. Currently, you <em>can</em> create these in TypeScript by adding a private member to a class (or a crazy identifier on an interface, although that only reduces the chance, whereas the private member trick works as expected).</p>\n<p dir=\"auto\">You have already made the decision that you want a nominal type when you create a type safe id class, because that is the purpose of such a class (and is the reason you aren't simply using <code class=\"notranslate\">number</code>).</p>\n<p dir=\"auto\">So my question is as follows, this code does what a lot of people want:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    class ExampleId {\n        constructor(public value: number){}\n        private notused: string;\n    }\"><pre class=\"notranslate\">    <span class=\"pl-k\">class</span> <span class=\"pl-smi\">ExampleId</span> <span class=\"pl-kos\">{</span>\n        <span class=\"pl-en\">constructor</span><span class=\"pl-kos\">(</span><span class=\"pl-k\">public</span> <span class=\"pl-s1\">value</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n        <span class=\"pl-k\">private</span> <span class=\"pl-c1\">notused</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">i.e. you cannot create another type that will satisfy this structure, because of the private member...</p>\n<ol dir=\"auto\">\n<li>Would it be possible to formalise <em>this</em> behaviour with a keyword so the private member isn't needed?</li>\n<li>Would it be possible to get this behaviour for interfaces?</li>\n</ol>\n<p dir=\"auto\">The first of these two questions would probably cover 80% of the use cases. The second would allow similar cases and would be very useful from a <code class=\"notranslate\">.d.ts</code> perspective.</p>\n<p dir=\"auto\">This limits the feature to the creation of types that cannot be matched, which is already possible as described and for classes simply moves a \"magic fix\" into a more deliberate keyword.</p>\n<p dir=\"auto\">I would be happy to write up something for this.</p>",
        "createdAt": "2014-08-01T20:20:04Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50930292",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 30
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwOTMxOTkw",
        "author": {
          "login": "danquirk"
        },
        "authorAssociation": "MEMBER",
        "body": "Certainly feel free to try to write up something more complete that can be evaluated, although I will be honest and say the chances of us taking a change like seem quite slim to me.\n\nAnother data point to consider is that TypeScript classes had this behavior by default for some time (ie always behaved as a nominal type) and it was just very incongruous with the rest of the type system and ways in which object types were used. Obviously the ability to turn nominal on/off is quite different from always on but something to consider nonetheless. Also, as you note this pattern does allow some amount of nominal typing today, so it would be interesting to see if there are any codebases that have used this intermixing to a non-trivial degree (in a way that isn't just all nominal all the time).\n",
        "bodyHTML": "<p dir=\"auto\">Certainly feel free to try to write up something more complete that can be evaluated, although I will be honest and say the chances of us taking a change like seem quite slim to me.</p>\n<p dir=\"auto\">Another data point to consider is that TypeScript classes had this behavior by default for some time (ie always behaved as a nominal type) and it was just very incongruous with the rest of the type system and ways in which object types were used. Obviously the ability to turn nominal on/off is quite different from always on but something to consider nonetheless. Also, as you note this pattern does allow some amount of nominal typing today, so it would be interesting to see if there are any codebases that have used this intermixing to a non-trivial degree (in a way that isn't just all nominal all the time).</p>",
        "createdAt": "2014-08-01T20:37:19Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50931990",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwOTM0NzEy",
        "author": {
          "login": "iislucas"
        },
        "authorAssociation": "NONE",
        "body": "Note: lets not mix up the baby and bathwater here: the proposal in this\nissue is not a nominal keyword for any type, but to support a specific\ninterface declaration of a nominal type. Nominal types are easy get right,\nand pretty well understood to provide value; while a 'sticky' nominal type\nannotation is tricky to do right. I'd suggest moving discussion of a\nanywhere nominal type-tag to a different issue so as not to confuse the\ntwo.\n\nOn Fri, Aug 1, 2014 at 4:37 PM, Dan Quirk notifications@github.com wrote:\n\n> Certainly feel free to try to write up something more complete that can be\n> evaluated, although I will be honest and say the chances of us taking a\n> change like seem quite slim to me.\n> \n> Another data point to consider is that TypeScript classes had this\n> behavior by default for some time (ie always behaved as a nominal type) and\n> it was just very incongruous with the rest of the type system and ways in\n> which object types were used. Obviously the ability to turn nominal on/off\n> is quite different from always on but something to consider nonetheless.\n> Also, as you note this pattern does allow some amount of nominal typing\n> today, so it would be interesting to see if there are any codebases that\n> have used this intermixing to a non-trivial degree (in a way that isn't\n> just all nominal all the time).\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/Microsoft/TypeScript/issues/202#issuecomment-50931990\n> .\n\n## \n\nLucas Dixon | Google Ideas\n",
        "bodyHTML": "<p dir=\"auto\">Note: lets not mix up the baby and bathwater here: the proposal in this<br>\nissue is not a nominal keyword for any type, but to support a specific<br>\ninterface declaration of a nominal type. Nominal types are easy get right,<br>\nand pretty well understood to provide value; while a 'sticky' nominal type<br>\nannotation is tricky to do right. I'd suggest moving discussion of a<br>\nanywhere nominal type-tag to a different issue so as not to confuse the<br>\ntwo.</p>\n<p dir=\"auto\">On Fri, Aug 1, 2014 at 4:37 PM, Dan Quirk <a href=\"mailto:notifications@github.com\">notifications@github.com</a> wrote:</p>\n<blockquote>\n<p dir=\"auto\">Certainly feel free to try to write up something more complete that can be<br>\nevaluated, although I will be honest and say the chances of us taking a<br>\nchange like seem quite slim to me.</p>\n<p dir=\"auto\">Another data point to consider is that TypeScript classes had this<br>\nbehavior by default for some time (ie always behaved as a nominal type) and<br>\nit was just very incongruous with the rest of the type system and ways in<br>\nwhich object types were used. Obviously the ability to turn nominal on/off<br>\nis quite different from always on but something to consider nonetheless.<br>\nAlso, as you note this pattern does allow some amount of nominal typing<br>\ntoday, so it would be interesting to see if there are any codebases that<br>\nhave used this intermixing to a non-trivial degree (in a way that isn't<br>\njust all nominal all the time).</p>\n<p dir=\"auto\">—<br>\nReply to this email directly or view it on GitHub<br>\n<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard?comment_id=50931990&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-50931990\">#202 (comment)</a><br>\n.</p>\n</blockquote>\n<h2 dir=\"auto\"></h2>\n<p dir=\"auto\">Lucas Dixon | Google Ideas</p>",
        "createdAt": "2014-08-01T21:05:23Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50934712",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwOTM1ODY2",
        "author": {
          "login": "jntrnr"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@iislucas - as mentioned earlier, structural and nominal are fundamental choices in the type system.  Any time you rethink part of the fundamental design choices, you need to understand the full impact.  Even if it seems to be isolated to a small set of scenarios.  \n\nThe best way to full understand the impact is to have a more complete suggestion.  I wouldn't confuse @danquirk's response as throwing the baby with the bathwater, but instead as the minimal amount of work any proposal would need that touches a fundamental design choice.  \n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/iislucas/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/iislucas\">@iislucas</a> - as mentioned earlier, structural and nominal are fundamental choices in the type system.  Any time you rethink part of the fundamental design choices, you need to understand the full impact.  Even if it seems to be isolated to a small set of scenarios.</p>\n<p dir=\"auto\">The best way to full understand the impact is to have a more complete suggestion.  I wouldn't confuse <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/danquirk/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/danquirk\">@danquirk</a>'s response as throwing the baby with the bathwater, but instead as the minimal amount of work any proposal would need that touches a fundamental design choice.</p>",
        "createdAt": "2014-08-01T21:17:30Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50935866",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUwOTM2Mjc3",
        "author": {
          "login": "iislucas"
        },
        "authorAssociation": "NONE",
        "body": "I agree that a fully proposal is a good idea, and I'll do that. I worked a\nlong time in type-systems, so I'm pretty confident in my understanding of\nwhats involved here. But there are wildly different things being suggested.\nSo probably good to put each one into it's own discussion :)\n\nOn Fri, Aug 1, 2014 at 5:17 PM, Jonathan Turner notifications@github.com\nwrote:\n\n> @iislucas https://github.com/iislucas - as mentioned earlier,\n> structural and nominal are fundamental choices in the type system. Any time\n> you rethink part of the fundamental design choices, you need to understand\n> the full impact. Even if it seems to be isolated to a small set of\n> scenarios.\n> \n> The best way to full understand the impact is to have a more complete\n> suggestion. I wouldn't confuse @danquirk https://github.com/danquirk's\n> response as throwing the baby with the bathwater, but instead as the\n> minimal amount of work any proposal would need that touches a fundamental\n> design choice.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/Microsoft/TypeScript/issues/202#issuecomment-50935866\n> .\n\n## \n\nLucas Dixon | Google Ideas\n",
        "bodyHTML": "<p dir=\"auto\">I agree that a fully proposal is a good idea, and I'll do that. I worked a<br>\nlong time in type-systems, so I'm pretty confident in my understanding of<br>\nwhats involved here. But there are wildly different things being suggested.<br>\nSo probably good to put each one into it's own discussion :)</p>\n<p dir=\"auto\">On Fri, Aug 1, 2014 at 5:17 PM, Jonathan Turner <a href=\"mailto:notifications@github.com\">notifications@github.com</a><br>\nwrote:</p>\n<blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/iislucas/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/iislucas\">@iislucas</a> <a href=\"https://github.com/iislucas\">https://github.com/iislucas</a> - as mentioned earlier,<br>\nstructural and nominal are fundamental choices in the type system. Any time<br>\nyou rethink part of the fundamental design choices, you need to understand<br>\nthe full impact. Even if it seems to be isolated to a small set of<br>\nscenarios.</p>\n<p dir=\"auto\">The best way to full understand the impact is to have a more complete<br>\nsuggestion. I wouldn't confuse <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/danquirk/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/danquirk\">@danquirk</a> <a href=\"https://github.com/danquirk's\">https://github.com/danquirk's</a><br>\nresponse as throwing the baby with the bathwater, but instead as the<br>\nminimal amount of work any proposal would need that touches a fundamental<br>\ndesign choice.</p>\n<p dir=\"auto\">—<br>\nReply to this email directly or view it on GitHub<br>\n<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard?comment_id=50935866&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-50935866\">#202 (comment)</a><br>\n.</p>\n</blockquote>\n<h2 dir=\"auto\"></h2>\n<p dir=\"auto\">Lucas Dixon | Google Ideas</p>",
        "createdAt": "2014-08-01T21:21:38Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-50936277",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY4Mzc0Mzg0",
        "author": {
          "login": "iislucas"
        },
        "authorAssociation": "NONE",
        "body": "@jonathandturner just wanted to check what you think of the example use-cases proposed in the description. Do they make sense? Happy to clarify/expand on them if that helps (and also of https://github.com/Microsoft/TypeScript/issues/202#issuecomment-50930292 which is a case of entry (2) in the issue description)\n\nAnd also w.r.t. the suggestion of @aleksey-bykov : https://github.com/Microsoft/TypeScript/issues/202#issuecomment-50199713\nit seems that it could be implemented as a simple abbreviation to existing type-script without introducing any new concepts. The only optimization that would make sense to add would be for the compiler to optimize away self-referential nominal field.\n\nI realize that I've offered to do something but not actually 100% sure what you'd like me to write - I could look through code and start pointing to how I would implement it? but maybe there's something more to do before that? \n\nNominal types (and new kinds of indexable types) that don't get confused between each other would be a big improvement in my opinion. They let you separate layers of abstraction and implementation details. And they are widely used in other typed functional languages too (F#, Haskell, SML/Ocaml, etc).\n\nThanks,\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"organization\" data-hovercard-url=\"/orgs/jonathandturner/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jonathandturner\">@jonathandturner</a> just wanted to check what you think of the example use-cases proposed in the description. Do they make sense? Happy to clarify/expand on them if that helps (and also of <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard?comment_id=50930292&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-50930292\">#202 (comment)</a> which is a case of entry (2) in the issue description)</p>\n<p dir=\"auto\">And also w.r.t. the suggestion of <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Aleksey-Bykov/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Aleksey-Bykov\">@Aleksey-Bykov</a> : <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard?comment_id=50199713&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-50199713\">#202 (comment)</a><br>\nit seems that it could be implemented as a simple abbreviation to existing type-script without introducing any new concepts. The only optimization that would make sense to add would be for the compiler to optimize away self-referential nominal field.</p>\n<p dir=\"auto\">I realize that I've offered to do something but not actually 100% sure what you'd like me to write - I could look through code and start pointing to how I would implement it? but maybe there's something more to do before that?</p>\n<p dir=\"auto\">Nominal types (and new kinds of indexable types) that don't get confused between each other would be a big improvement in my opinion. They let you separate layers of abstraction and implementation details. And they are widely used in other typed functional languages too (F#, Haskell, SML/Ocaml, etc).</p>\n<p dir=\"auto\">Thanks,</p>",
        "createdAt": "2014-12-30T17:04:05Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-68374384",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY4Mzk1ODYy",
        "author": {
          "login": "jntrnr"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Hi @iislucas,\n\nFor a proposal for nominal types, you'll need to show strong use cases.  As listed in the design goals for TypeScript: https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals, being structural is something that TypeScript is committed to.  The assumption that checking is structural is carried throughout the type checker, the spec, and how it's used in practice.  In short, augmenting or going away from structural is going to be uphill all the way.\n\nAdding some additional nominal checking would need to be weighed against the benefit.  For this to have a chance of success, the types of new patterns that the new nominal capabilities provide would need to enable fundamental improvements in how JavaScript is typed.\n\nLooking at the examples in the original post, I'm not sure which JavaScript patterns this enables.  Starting with that might the best place.  Also, you may want to look at other new functionality, like type guards, and how this might impact that.\n",
        "bodyHTML": "<p dir=\"auto\">Hi <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/iislucas/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/iislucas\">@iislucas</a>,</p>\n<p dir=\"auto\">For a proposal for nominal types, you'll need to show strong use cases.  As listed in the design goals for TypeScript: <a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals\">https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals</a>, being structural is something that TypeScript is committed to.  The assumption that checking is structural is carried throughout the type checker, the spec, and how it's used in practice.  In short, augmenting or going away from structural is going to be uphill all the way.</p>\n<p dir=\"auto\">Adding some additional nominal checking would need to be weighed against the benefit.  For this to have a chance of success, the types of new patterns that the new nominal capabilities provide would need to enable fundamental improvements in how JavaScript is typed.</p>\n<p dir=\"auto\">Looking at the examples in the original post, I'm not sure which JavaScript patterns this enables.  Starting with that might the best place.  Also, you may want to look at other new functionality, like type guards, and how this might impact that.</p>",
        "createdAt": "2014-12-30T20:39:39Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-68395862",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY4NTQ5Mjk3",
        "author": {
          "login": "iislucas"
        },
        "authorAssociation": "NONE",
        "body": "@jonathandturner I don't see why you make it seem like an exclusive choice of nominal vs structural: sometimes structural checking is what you want, sometimes nominal is. There are already a set of base nominals (string, number, etc). What I see as a good insight in typescript, and in the design goals, is that structural checking is important and will be supported. Many typed languages don't have this. It sounded to me that support for structural checking in the design goals was saying it's something TypeScript wanted to include rather than a claim about never adding an more base-types or never supporting nominal definitions. I don't see this as being a philosophical question that undermines TypeScript. \n\nw.r.t. JavaScript patterns: it is not a JavaScript pattern that it enables. It is enables stronger levels of abstraction and more type-checking. \n\nw.r.t. difficulty: support for nominal types is the easiest kind of extension there is to a type-system. We're not here proposing dependent types, or any fancy new computation in typing (although coming from that universe, I'm tempted... ;-) ). Just the ability to define new nominal types/interfaces. \n\nBut if I've mis-understood TypeScirpt's goals, and it is a goal to not support nominal types, then of course much stronger arguments and examples are needed. \n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"organization\" data-hovercard-url=\"/orgs/jonathandturner/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jonathandturner\">@jonathandturner</a> I don't see why you make it seem like an exclusive choice of nominal vs structural: sometimes structural checking is what you want, sometimes nominal is. There are already a set of base nominals (string, number, etc). What I see as a good insight in typescript, and in the design goals, is that structural checking is important and will be supported. Many typed languages don't have this. It sounded to me that support for structural checking in the design goals was saying it's something TypeScript wanted to include rather than a claim about never adding an more base-types or never supporting nominal definitions. I don't see this as being a philosophical question that undermines TypeScript.</p>\n<p dir=\"auto\">w.r.t. JavaScript patterns: it is not a JavaScript pattern that it enables. It is enables stronger levels of abstraction and more type-checking.</p>\n<p dir=\"auto\">w.r.t. difficulty: support for nominal types is the easiest kind of extension there is to a type-system. We're not here proposing dependent types, or any fancy new computation in typing (although coming from that universe, I'm tempted... ;-) ). Just the ability to define new nominal types/interfaces.</p>\n<p dir=\"auto\">But if I've mis-understood TypeScirpt's goals, and it is a goal to not support nominal types, then of course much stronger arguments and examples are needed.</p>",
        "createdAt": "2015-01-02T18:29:16Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-68549297",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY4ODkyMzk2",
        "author": {
          "login": "jntrnr"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@iislucas - TypeScript's main goal is to enable large-scale JavaScript applications.  It does this by staying very close to JavaScript.  Most of what the type system was built for is working with JavaScript and enabling JavaScript patterns in a type-safe way.\n\nWhen we were setting ourselves up for how to go about that, we went back and forth a bit on supporting both nominal and structural.  At one point, we had a structural system that would tag classes with \"brands\" that would allow users to use them more nominally.\n\nThe more we worked with the system, though, the more it felt like going completely structural seemed closer to the spirit of JavaScript and how flexible it is in practice.  Once we realized that, we went completely in the direction of structural and aren't looking to backtrack.\n\nThat's why I said it would take a lot of strong benefits to make us backtrack and re-think going fully structural.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/iislucas/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/iislucas\">@iislucas</a> - TypeScript's main goal is to enable large-scale JavaScript applications.  It does this by staying very close to JavaScript.  Most of what the type system was built for is working with JavaScript and enabling JavaScript patterns in a type-safe way.</p>\n<p dir=\"auto\">When we were setting ourselves up for how to go about that, we went back and forth a bit on supporting both nominal and structural.  At one point, we had a structural system that would tag classes with \"brands\" that would allow users to use them more nominally.</p>\n<p dir=\"auto\">The more we worked with the system, though, the more it felt like going completely structural seemed closer to the spirit of JavaScript and how flexible it is in practice.  Once we realized that, we went completely in the direction of structural and aren't looking to backtrack.</p>\n<p dir=\"auto\">That's why I said it would take a lot of strong benefits to make us backtrack and re-think going fully structural.</p>",
        "createdAt": "2015-01-06T16:49:14Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-68892396",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY5NTIxNDYw",
        "author": {
          "login": "iislucas"
        },
        "authorAssociation": "NONE",
        "body": "@jonathandturner - thanks for the history and background. JS has generally been a difficult platform for creating large scale JS applications, and supporting this is why I and my team use it. Type-abstraction is specifically thought to help with this, and in my experience in other languages, it helps a lot. There's a long history of it in many languages, but primarily in the typed functional programming world (e.g. SML and Haskell). So if the problem is that it may be difficult to (re)implement, the thing to do is look into the details of what it would take to support it. If it is easy, then it's less of a issue. If it's hard and requires significant refactoring, then it makes sense to discuss examples and try and persuade more people - probably to do some research and point to it's role in other languages/frameworks. \n\nThe proposal of @aleksey-bykov : https://github.com/Microsoft/TypeScript/issues/202#issuecomment-50199713 seems easy to me. What would you say the next step in exploring this is for those of us who think it would make the language better? Is the next step a patch for typescript, or more examples using the proposed TypeScript syntax, along with errors/compilations?\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"organization\" data-hovercard-url=\"/orgs/jonathandturner/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jonathandturner\">@jonathandturner</a> - thanks for the history and background. JS has generally been a difficult platform for creating large scale JS applications, and supporting this is why I and my team use it. Type-abstraction is specifically thought to help with this, and in my experience in other languages, it helps a lot. There's a long history of it in many languages, but primarily in the typed functional programming world (e.g. SML and Haskell). So if the problem is that it may be difficult to (re)implement, the thing to do is look into the details of what it would take to support it. If it is easy, then it's less of a issue. If it's hard and requires significant refactoring, then it makes sense to discuss examples and try and persuade more people - probably to do some research and point to it's role in other languages/frameworks.</p>\n<p dir=\"auto\">The proposal of <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Aleksey-Bykov/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Aleksey-Bykov\">@Aleksey-Bykov</a> : <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard?comment_id=50199713&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-50199713\">#202 (comment)</a> seems easy to me. What would you say the next step in exploring this is for those of us who think it would make the language better? Is the next step a patch for typescript, or more examples using the proposed TypeScript syntax, along with errors/compilations?</p>",
        "createdAt": "2015-01-12T01:16:27Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-69521460",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY5NjM1ODgz",
        "author": {
          "login": "danquirk"
        },
        "authorAssociation": "MEMBER",
        "body": "The implementation is not particularly difficult (nominal classes existed before, and you can hack the same effect in today via private members). What's difficult is reconciling how nominal code would interact with structural parts of a program and all the JS libraries that are built on structural typing. As mentioned, we essentially had a system like this before (classes were nominal, interfaces and object literals were structural) and it did not mesh very well with what people already do with JS.\n",
        "bodyHTML": "<p dir=\"auto\">The implementation is not particularly difficult (nominal classes existed before, and you can hack the same effect in today via private members). What's difficult is reconciling how nominal code would interact with structural parts of a program and all the JS libraries that are built on structural typing. As mentioned, we essentially had a system like this before (classes were nominal, interfaces and object literals were structural) and it did not mesh very well with what people already do with JS.</p>",
        "createdAt": "2015-01-12T20:05:04Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-69635883",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY5NjM3OTE1",
        "author": {
          "login": "iislucas"
        },
        "authorAssociation": "NONE",
        "body": "Good to know the implementation is not difficult. \n\nw.r.t. existing libraries: how about leaving all the existing JS libraries as is (using structural typing)? Nominal types can be included incrementally in new projects to catch more errors at compile time and support abstraction in newer larger software projects - it gives a nice way to move towards increased reliability in a project, e.g. to start you might introduce some nominal types for different kinds of strings to avoid mixing them up. \n\nI would start using new nominal types in my projects pretty quickly, but I don't mind that libraries I use don't. I can always introduce an abstraction layer (e.g. a new interface) by writing a new .d.ts file for an existing library when I feel it would help me (e.g. to start with, I might do so for things like socket identifiers for chrome-app environments, see: https://developer.chrome.com/apps/sockets_tcp ).\n",
        "bodyHTML": "<p dir=\"auto\">Good to know the implementation is not difficult.</p>\n<p dir=\"auto\">w.r.t. existing libraries: how about leaving all the existing JS libraries as is (using structural typing)? Nominal types can be included incrementally in new projects to catch more errors at compile time and support abstraction in newer larger software projects - it gives a nice way to move towards increased reliability in a project, e.g. to start you might introduce some nominal types for different kinds of strings to avoid mixing them up.</p>\n<p dir=\"auto\">I would start using new nominal types in my projects pretty quickly, but I don't mind that libraries I use don't. I can always introduce an abstraction layer (e.g. a new interface) by writing a new .d.ts file for an existing library when I feel it would help me (e.g. to start with, I might do so for things like socket identifiers for chrome-app environments, see: <a href=\"https://developer.chrome.com/apps/sockets_tcp\" rel=\"nofollow\">https://developer.chrome.com/apps/sockets_tcp</a> ).</p>",
        "createdAt": "2015-01-12T20:17:11Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-69637915",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY5NjM4ODM5",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "@danquirk, your major argument is that all existing libs are structural, people tend to think structural, etc\n\nWell fine, having nominal types in addition to everything else being _structural by default_ isn't going to hurt, is it? \n\nThe difficulties of matching structural types to nominal and shortcomings of not being able to do so 100% nicely is going to be a problem of nominal types where compromises are possible since these are the problems of minority of nominal types and doesn't affect how structural types work which are in the heart of the language.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/danquirk/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/danquirk\">@danquirk</a>, your major argument is that all existing libs are structural, people tend to think structural, etc</p>\n<p dir=\"auto\">Well fine, having nominal types in addition to everything else being <em>structural by default</em> isn't going to hurt, is it?</p>\n<p dir=\"auto\">The difficulties of matching structural types to nominal and shortcomings of not being able to do so 100% nicely is going to be a problem of nominal types where compromises are possible since these are the problems of minority of nominal types and doesn't affect how structural types work which are in the heart of the language.</p>",
        "createdAt": "2015-01-12T20:23:03Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-69638839",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY5NjQ2ODk5",
        "author": {
          "login": "RyanCavanaugh"
        },
        "authorAssociation": "MEMBER",
        "body": "> Well fine, having nominal types in addition to everything else being structural by default isn't going to hurt, is it?\n\nAn increase in complexity needs to more than pay for itself in terms of value added. Every language feature we add is another row and column in the matrix of interactions between different aspects of the language. Especially for something as core as the rules of type compat, we're talking about permanently complicating the language in a major way and potentially preventing future features.\n\nThe thing I'm _not_ seeing in this thread is a bunch of real-world examples where people would have gotten desired behavior with nominal types, but instead got poor behavior because of structural types. When we have more urgent gaps in the language, those examples are very common and easy to find.\n",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">Well fine, having nominal types in addition to everything else being structural by default isn't going to hurt, is it?</p>\n</blockquote>\n<p dir=\"auto\">An increase in complexity needs to more than pay for itself in terms of value added. Every language feature we add is another row and column in the matrix of interactions between different aspects of the language. Especially for something as core as the rules of type compat, we're talking about permanently complicating the language in a major way and potentially preventing future features.</p>\n<p dir=\"auto\">The thing I'm <em>not</em> seeing in this thread is a bunch of real-world examples where people would have gotten desired behavior with nominal types, but instead got poor behavior because of structural types. When we have more urgent gaps in the language, those examples are very common and easy to find.</p>",
        "createdAt": "2015-01-12T21:12:52Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-69646899",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY5NjUzODQy",
        "author": {
          "login": "iislucas"
        },
        "authorAssociation": "NONE",
        "body": "I don't see where the potential bad interactions would be - maybe you can say a bit more about that? Happy to think about that more and document what the expected interactions might be. \n\nIf you remove nominal types, strictly more types match, so removing it isn't difficult in the future. So, I don't see it as long-term challenge to maintain. Also, sound like it's not complicated to implement either. \n\nw.r.t. more examples of where abstract types naturally occur, here's 3 groups that come off the top of my head: \n- Socket ids in pretty much all platforms (node, Chrome Apps, Firefox Add-ons; UDP and TCP). \n- User-names as keys in a table where you don't want to mix up usernames with other strings. \n- Crypto-keys or passwords; again to avoid mixup with other string values.\n",
        "bodyHTML": "<p dir=\"auto\">I don't see where the potential bad interactions would be - maybe you can say a bit more about that? Happy to think about that more and document what the expected interactions might be.</p>\n<p dir=\"auto\">If you remove nominal types, strictly more types match, so removing it isn't difficult in the future. So, I don't see it as long-term challenge to maintain. Also, sound like it's not complicated to implement either.</p>\n<p dir=\"auto\">w.r.t. more examples of where abstract types naturally occur, here's 3 groups that come off the top of my head:</p>\n<ul dir=\"auto\">\n<li>Socket ids in pretty much all platforms (node, Chrome Apps, Firefox Add-ons; UDP and TCP).</li>\n<li>User-names as keys in a table where you don't want to mix up usernames with other strings.</li>\n<li>Crypto-keys or passwords; again to avoid mixup with other string values.</li>\n</ul>",
        "createdAt": "2015-01-12T21:55:04Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-69653842",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY5NzU5NTky",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "@RyanCavanaugh, [Tiny types](https://www.google.com/search?q=tiny+types) is where nominals would be so very handy. Consider:\n\n```\ninterface Age {}\ninterface Height {}\ninterface Person {\n   height: Height;\n   age: Age;\n}\n\nfunction ageFrom(value: number): Age {\n   if (value > 0) return <any> value;\n   throw new Error('Invalid age');\n}\n\nfunction heightFrom(value: number): Height {\n  if (value > 0) return <any> value;\n  throw new Error('Invalid height');\n}\n\nfunction formatAge(age: Age): string {\n   return (<any> age).toFixed(0);\n}\n\nfunction formatHeightheight: Height) : string {\n   return (<any> height).toFixed(0);\n}\n\nvar person: Person = { age: ageFrom(35), height: heightFrom(180) };\nconsole.log(formatAge(person.height)); // <= problem!\n```\n\nThis gives another type safety measure that prevents you from mistaking a height for an age. Which otherwise would be interchangeable if plain numbers were used.\n\nIn Haskell same thing is done by `newtype` and it's a crazy popular feature.\n\nYour point that there is little demand for nominal types is flawed, there is no demand because no one ever seen them in JavaScript and don't know they could have existed let alone possible at all. People including myself coming from other languages where there is a feature like this would certainly appreciate it.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/RyanCavanaugh/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/RyanCavanaugh\">@RyanCavanaugh</a>, <a href=\"https://www.google.com/search?q=tiny+types\" rel=\"nofollow\">Tiny types</a> is where nominals would be so very handy. Consider:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"interface Age {}\ninterface Height {}\ninterface Person {\n   height: Height;\n   age: Age;\n}\n\nfunction ageFrom(value: number): Age {\n   if (value &gt; 0) return &lt;any&gt; value;\n   throw new Error('Invalid age');\n}\n\nfunction heightFrom(value: number): Height {\n  if (value &gt; 0) return &lt;any&gt; value;\n  throw new Error('Invalid height');\n}\n\nfunction formatAge(age: Age): string {\n   return (&lt;any&gt; age).toFixed(0);\n}\n\nfunction formatHeightheight: Height) : string {\n   return (&lt;any&gt; height).toFixed(0);\n}\n\nvar person: Person = { age: ageFrom(35), height: heightFrom(180) };\nconsole.log(formatAge(person.height)); // &lt;= problem!\"><pre class=\"notranslate\"><code class=\"notranslate\">interface Age {}\ninterface Height {}\ninterface Person {\n   height: Height;\n   age: Age;\n}\n\nfunction ageFrom(value: number): Age {\n   if (value &gt; 0) return &lt;any&gt; value;\n   throw new Error('Invalid age');\n}\n\nfunction heightFrom(value: number): Height {\n  if (value &gt; 0) return &lt;any&gt; value;\n  throw new Error('Invalid height');\n}\n\nfunction formatAge(age: Age): string {\n   return (&lt;any&gt; age).toFixed(0);\n}\n\nfunction formatHeightheight: Height) : string {\n   return (&lt;any&gt; height).toFixed(0);\n}\n\nvar person: Person = { age: ageFrom(35), height: heightFrom(180) };\nconsole.log(formatAge(person.height)); // &lt;= problem!\n</code></pre></div>\n<p dir=\"auto\">This gives another type safety measure that prevents you from mistaking a height for an age. Which otherwise would be interchangeable if plain numbers were used.</p>\n<p dir=\"auto\">In Haskell same thing is done by <code class=\"notranslate\">newtype</code> and it's a crazy popular feature.</p>\n<p dir=\"auto\">Your point that there is little demand for nominal types is flawed, there is no demand because no one ever seen them in JavaScript and don't know they could have existed let alone possible at all. People including myself coming from other languages where there is a feature like this would certainly appreciate it.</p>",
        "createdAt": "2015-01-13T15:18:57Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-69759592",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 11
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY5ODA2ODA5",
        "author": {
          "login": "danquirk"
        },
        "authorAssociation": "MEMBER",
        "body": "For that scenario my preferred solution would be something like F#'s Units of Measure ( https://github.com/Microsoft/TypeScript/issues/364). There's essentially a huge class of types inside `number` that cannot be specified as incompatible with one another. What you want are basically additional (user specified) primitive types.\n\nThere are scenarios where nominal types give you safety over structural types. There are also scenarios where nominal types create unnecessary friction trying to represent patterns that structural typing easily models. There are trade offs with each. Most languages I can think of have had to choose one or the other as trying to mix them is confusing or painful or both. Your latest example seems emblematic of some of my concerns. I take it you just want an error on the last line. But then in the same small snippet of code you've taken advantage of structural typing (a number is an Age since Age has no members) while also doing a nominal comparison a few lines later (to get an error using Height where Age is expected). Essentially every type comparison operation would require you to do the additional work of deducing whether the comparison was a structural or a nominal one, rather than having an easily predictable set of behavior.\n",
        "bodyHTML": "<p dir=\"auto\">For that scenario my preferred solution would be something like F#'s Units of Measure ( <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"39567277\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/364\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/364/hovercard\" href=\"https://github.com/microsoft/TypeScript/issues/364\">#364</a>). There's essentially a huge class of types inside <code class=\"notranslate\">number</code> that cannot be specified as incompatible with one another. What you want are basically additional (user specified) primitive types.</p>\n<p dir=\"auto\">There are scenarios where nominal types give you safety over structural types. There are also scenarios where nominal types create unnecessary friction trying to represent patterns that structural typing easily models. There are trade offs with each. Most languages I can think of have had to choose one or the other as trying to mix them is confusing or painful or both. Your latest example seems emblematic of some of my concerns. I take it you just want an error on the last line. But then in the same small snippet of code you've taken advantage of structural typing (a number is an Age since Age has no members) while also doing a nominal comparison a few lines later (to get an error using Height where Age is expected). Essentially every type comparison operation would require you to do the additional work of deducing whether the comparison was a structural or a nominal one, rather than having an easily predictable set of behavior.</p>",
        "createdAt": "2015-01-13T19:46:30Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-69806809",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY5ODE5Mjk0",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "@danquirk, I don't mind trading nominals for units of measure if... units of measure can be applicable to any type, not necessarily just numbers. Strings are the next after numbers problematic type that just too broad to be used safely. So doing something like this for string would be just great: `\"aleksey.bykov@gmail.com\"<email>`. Now if we go further down this road why not to make Dates capable of units? I remember lots of bugs when I did heavy calculations on dates cause by mistaking one date for another. Do you think units of measure have a better chance for making it as a feature?\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/danquirk/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/danquirk\">@danquirk</a>, I don't mind trading nominals for units of measure if... units of measure can be applicable to any type, not necessarily just numbers. Strings are the next after numbers problematic type that just too broad to be used safely. So doing something like this for string would be just great: <code class=\"notranslate\">\"aleksey.bykov@gmail.com\"&lt;email&gt;</code>. Now if we go further down this road why not to make Dates capable of units? I remember lots of bugs when I did heavy calculations on dates cause by mistaking one date for another. Do you think units of measure have a better chance for making it as a feature?</p>",
        "createdAt": "2015-01-13T21:02:51Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-69819294",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY5ODIxMjk2",
        "author": {
          "login": "danquirk"
        },
        "authorAssociation": "MEMBER",
        "body": "Yeah I can see the applicability to other primitive types given JavaScript's penchant for string based APIs. We haven't had any serious discussions about UoM (ES6 features are keeping us fairly busy as far as new language stuff goes) but yes I would say it's more likely we do that at some point than add nominal semantics.\n",
        "bodyHTML": "<p dir=\"auto\">Yeah I can see the applicability to other primitive types given JavaScript's penchant for string based APIs. We haven't had any serious discussions about UoM (ES6 features are keeping us fairly busy as far as new language stuff goes) but yes I would say it's more likely we do that at some point than add nominal semantics.</p>",
        "createdAt": "2015-01-13T21:14:17Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-69821296",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDgwNzM3MDgy",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "Put together an article on faking nominal types in TypeScript: https://gist.github.com/aleksey-bykov/0ab85f0b5e83fc848f85\n",
        "bodyHTML": "<p dir=\"auto\">Put together an article on faking nominal types in TypeScript: <a href=\"https://gist.github.com/aleksey-bykov/0ab85f0b5e83fc848f85\">https://gist.github.com/aleksey-bykov/0ab85f0b5e83fc848f85</a></p>",
        "createdAt": "2015-03-14T21:54:03Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-80737082",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDgwNzU4OTYw",
        "author": {
          "login": "iislucas"
        },
        "authorAssociation": "NONE",
        "body": "Thank you! This is very helpful. Obviously, I've love to see native support this in TS, but this is the nicest workaround I've seen so far. \n",
        "bodyHTML": "<p dir=\"auto\">Thank you! This is very helpful. Obviously, I've love to see native support this in TS, but this is the nicest workaround I've seen so far.</p>",
        "createdAt": "2015-03-14T23:20:52Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-80758960",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDE0MjE0MTUyMg==",
        "author": {
          "login": "sampsyo"
        },
        "authorAssociation": "NONE",
        "body": "FWIW, I'm using a `void` field as a workaround. It works nicely and doesn't get in the way.\n\n``` typescript\nclass Foo {};\nlet x : Foo = 42;  // OK :(\n\nclass Bar {\n    _nominal_Foo: void;\n};\nlet y : Bar = 42;  // Error :)\n```\n\n[Playground.](http://www.typescriptlang.org/Playground#src=class%20Foo%20%7B%7D%3B%0Alet%20x%20%3A%20Foo%20%3D%2042%3B%20%20%2F%2F%20OK%0A%0Aclass%20Bar%20%7B%0A%09_nominal_Foo%3A%20void%3B%0A%7D%3B%0Alet%20y%20%3A%20Bar%20%3D%2042%3B%20%20%2F%2F%20Error)\n",
        "bodyHTML": "<p dir=\"auto\">FWIW, I'm using a <code class=\"notranslate\">void</code> field as a workaround. It works nicely and doesn't get in the way.</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"class Foo {};\nlet x : Foo = 42;  // OK :(\n\nclass Bar {\n    _nominal_Foo: void;\n};\nlet y : Bar = 42;  // Error :)\"><pre class=\"notranslate\"><span class=\"pl-k\">class</span> <span class=\"pl-smi\">Foo</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">x</span> : <span class=\"pl-smi\">Foo</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">42</span><span class=\"pl-kos\">;</span>  <span class=\"pl-c\">// OK :(</span>\n\n<span class=\"pl-k\">class</span> <span class=\"pl-smi\">Bar</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">_nominal_Foo</span>: <span class=\"pl-smi\"><span class=\"pl-k\">void</span></span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">y</span> : <span class=\"pl-smi\">Bar</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">42</span><span class=\"pl-kos\">;</span>  <span class=\"pl-c\">// Error :)</span></pre></div>\n<p dir=\"auto\"><a href=\"http://www.typescriptlang.org/Playground#src=class%20Foo%20%7B%7D%3B%0Alet%20x%20%3A%20Foo%20%3D%2042%3B%20%20%2F%2F%20OK%0A%0Aclass%20Bar%20%7B%0A%09_nominal_Foo%3A%20void%3B%0A%7D%3B%0Alet%20y%20%3A%20Bar%20%3D%2042%3B%20%20%2F%2F%20Error\" rel=\"nofollow\">Playground.</a></p>",
        "createdAt": "2015-09-21T23:55:39Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-142141522",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDE0MjE0NDM1Nw==",
        "author": {
          "login": "basarat"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> I'm using a void field as a workaround\n\nmaking it `any` is just as good. And I prefer the term `Brand` as that is what is used by the TypeScript team e.g. : https://github.com/Microsoft/TypeScript/blob/7b48a182c05ea4dea81bab73ecbbe9e013a79e99/src/compiler/types.ts#L693-L698\n\n``` ts\n    export interface Expression extends Node {\n        _expressionBrand: any;\n        contextualType?: Type;  // Used to temporarily assign a contextual type during overload resolution\n    }\n```\n",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">I'm using a void field as a workaround</p>\n</blockquote>\n<p dir=\"auto\">making it <code class=\"notranslate\">any</code> is just as good. And I prefer the term <code class=\"notranslate\">Brand</code> as that is what is used by the TypeScript team e.g. : <a href=\"https://github.com/Microsoft/TypeScript/blob/7b48a182c05ea4dea81bab73ecbbe9e013a79e99/src/compiler/types.ts#L693-L698\">https://github.com/Microsoft/TypeScript/blob/7b48a182c05ea4dea81bab73ecbbe9e013a79e99/src/compiler/types.ts#L693-L698</a></p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"    export interface Expression extends Node {\n        _expressionBrand: any;\n        contextualType?: Type;  // Used to temporarily assign a contextual type during overload resolution\n    }\"><pre class=\"notranslate\">    <span class=\"pl-k\">export</span> <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">Expression</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Node</span> <span class=\"pl-kos\">{</span>\n        <span class=\"pl-c1\">_expressionBrand</span>: <span class=\"pl-smi\">any</span><span class=\"pl-kos\">;</span>\n        <span class=\"pl-c1\">contextualType</span>?: <span class=\"pl-smi\">Type</span><span class=\"pl-kos\">;</span>  <span class=\"pl-c\">// Used to temporarily assign a contextual type during overload resolution</span>\n    <span class=\"pl-kos\">}</span></pre></div>",
        "createdAt": "2015-09-22T00:18:39Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-142144357",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDE0MjE0NzI5OA==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "The real type or a brand propeety is an empty enum, since enums are unique\nin ts.\nOn Sep 21, 2015 8:19 PM, \"Basarat Ali Syed\" notifications@github.com\nwrote:\n\n> I'm using a void field as a workaround\n> \n> making it any is just as good. And I prefer the term brand as that is\n> what is used by the TypeScript team e.g. :\n> https://github.com/Microsoft/TypeScript/blob/7b48a182c05ea4dea81bab73ecbbe9e013a79e99/src/compiler/types.ts#L693-L698\n> \n> ```\n> export interface Expression extends Node {\n>     _expressionBrand: any;\n>     contextualType?: Type;  // Used to temporarily assign a contextual type during overload resolution\n> }\n> ```\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/Microsoft/TypeScript/issues/202#issuecomment-142144357\n> .\n",
        "bodyHTML": "<p dir=\"auto\">The real type or a brand propeety is an empty enum, since enums are unique<br>\nin ts.<br>\nOn Sep 21, 2015 8:19 PM, \"Basarat Ali Syed\" <a href=\"mailto:notifications@github.com\">notifications@github.com</a><br>\nwrote:</p>\n<blockquote>\n<p dir=\"auto\">I'm using a void field as a workaround</p>\n<p dir=\"auto\">making it any is just as good. And I prefer the term brand as that is<br>\nwhat is used by the TypeScript team e.g. :<br>\n<a href=\"https://github.com/Microsoft/TypeScript/blob/7b48a182c05ea4dea81bab73ecbbe9e013a79e99/src/compiler/types.ts#L693-L698\">https://github.com/Microsoft/TypeScript/blob/7b48a182c05ea4dea81bab73ecbbe9e013a79e99/src/compiler/types.ts#L693-L698</a></p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"export interface Expression extends Node {\n    _expressionBrand: any;\n    contextualType?: Type;  // Used to temporarily assign a contextual type during overload resolution\n}\"><pre class=\"notranslate\"><code class=\"notranslate\">export interface Expression extends Node {\n    _expressionBrand: any;\n    contextualType?: Type;  // Used to temporarily assign a contextual type during overload resolution\n}\n</code></pre></div>\n<p dir=\"auto\">—<br>\nReply to this email directly or view it on GitHub<br>\n<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard?comment_id=142144357&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-142144357\">#202 (comment)</a><br>\n.</p>\n</blockquote>",
        "createdAt": "2015-09-22T00:36:52Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-142147298",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDE1NjcxOTA5OQ==",
        "author": {
          "login": "plalx"
        },
        "authorAssociation": "NONE",
        "body": "I agree that structural typing almost always creates abstractions that are far too wide to be practical in real-world scenarios. A concept is usually bound to a context and there's a lot of cases where two objects will accidentally share the same structure but shouldn't be interchangeable.\n\nIn my opinion, the default behavior should have been that structural type checking is used only where contracts are defined in terms of interfaces and nominal typing is used when contracts are defined in terms of concrete classes: concrete classes also makes the promise of an implementation which is a form of contract.\n\nConsider the code below:\n\n``` typescript\nclass Username {\n    public value: string;\n\n    constructor(value: string) {\n        if (!(this.value = value.trim())) throw new Error('value must not be empty');\n        Object.freeze(this);\n    }\n\n    toString() { return this.value; }\n}\n\nlet username: Username = { value: '' };\n```\n\nWhen `Username` is used as a contract it should not only carry the promise of having a `value: string` member, but also to be immutable and to wrap a non-empty string (supporting a `final` keyword would also be necessary to avoid breaking encapsulation through inheritance). The fact that you can accidentally break encapsulation could be problematic.\n\nChanging the implementation and have a `private _value: string` as well as a `get value(): string` getter would achieve a form of nominal typing naturally because different types with private members cannot be made equal, but supporting a `nominal` keyword which decorates interfaces & classes would be much better.\n",
        "bodyHTML": "<p dir=\"auto\">I agree that structural typing almost always creates abstractions that are far too wide to be practical in real-world scenarios. A concept is usually bound to a context and there's a lot of cases where two objects will accidentally share the same structure but shouldn't be interchangeable.</p>\n<p dir=\"auto\">In my opinion, the default behavior should have been that structural type checking is used only where contracts are defined in terms of interfaces and nominal typing is used when contracts are defined in terms of concrete classes: concrete classes also makes the promise of an implementation which is a form of contract.</p>\n<p dir=\"auto\">Consider the code below:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"class Username {\n    public value: string;\n\n    constructor(value: string) {\n        if (!(this.value = value.trim())) throw new Error('value must not be empty');\n        Object.freeze(this);\n    }\n\n    toString() { return this.value; }\n}\n\nlet username: Username = { value: '' };\"><pre class=\"notranslate\"><span class=\"pl-k\">class</span> <span class=\"pl-smi\">Username</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">public</span> <span class=\"pl-c1\">value</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n\n    <span class=\"pl-en\">constructor</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">value</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n        <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-c1\">!</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">this</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">value</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">value</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">trim</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span> <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Error</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'value must not be empty'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n        <span class=\"pl-smi\">Object</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">freeze</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">this</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-kos\">}</span>\n\n    <span class=\"pl-en\">toString</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">return</span> <span class=\"pl-smi\">this</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">value</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">username</span>: <span class=\"pl-smi\">Username</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">value</span>: <span class=\"pl-s\">''</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">When <code class=\"notranslate\">Username</code> is used as a contract it should not only carry the promise of having a <code class=\"notranslate\">value: string</code> member, but also to be immutable and to wrap a non-empty string (supporting a <code class=\"notranslate\">final</code> keyword would also be necessary to avoid breaking encapsulation through inheritance). The fact that you can accidentally break encapsulation could be problematic.</p>\n<p dir=\"auto\">Changing the implementation and have a <code class=\"notranslate\">private _value: string</code> as well as a <code class=\"notranslate\">get value(): string</code> getter would achieve a form of nominal typing naturally because different types with private members cannot be made equal, but supporting a <code class=\"notranslate\">nominal</code> keyword which decorates interfaces &amp; classes would be much better.</p>",
        "createdAt": "2015-11-14T16:51:53Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-156719099",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDE3MTI4NzQwMg==",
        "author": {
          "login": "AJamesPhillips"
        },
        "authorAssociation": "NONE",
        "body": "Can I confirm that this is still awaiting a proposal and that with a proposal this might move forwards?  @aleksey-bykov 's [contribution here](https://gist.github.com/aleksey-bykov/0ab85f0b5e83fc848f85) looks interesting or does it need more refinement / improvement?  To me though it's as \"simple\" as what @plalx said above:\n\n> structural type checking is used only where contracts are defined in terms of interfaces and nominal typing is used when contracts are defined in terms of concrete classes: concrete classes also makes the promise of an implementation which is a form of contract.\n\nHowever if it was as \"simple\" as this it would have been implemented so I know I must be missing a lot of thinking around this simpler use case which would avoid very easy to make runtime bugs like #251.\n\nThanks :)\n\n*\\* **edit** *\\* I retract my previous statement and disagree with @plalx .  Interfaces should be treated nominally as well.  For example if you serialised an a JetPlane, you want not want to be able to use it to construct a chicken:\n\n```\ninterface IChicken {\n  id: number;\n  name: string;\n}\nclass Chicken implements IChicken {\n  id: number;\n  name: string;\n  constructor(kwargs: IChicken) {\n    this.id = kwargs.id;\n    this.name = kwargs.name;\n  }\n}\n\ninterface IJetPlane {\n  id: number;\n  name: string;\n}\n\nvar serialisedJetPlane: IJetPlane = {id: 1, name: 'Vulcan'};\nvar chick = new Chicken(serialisedJetPlane);  // should error\n```\n\nIf you actually wanted to do that then perhaps you could cast:  `var chick = new Chicken(<IChicken> serialisedJetPlane);`\n",
        "bodyHTML": "<p dir=\"auto\">Can I confirm that this is still awaiting a proposal and that with a proposal this might move forwards?  <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Aleksey-Bykov/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Aleksey-Bykov\">@Aleksey-Bykov</a> 's <a href=\"https://gist.github.com/aleksey-bykov/0ab85f0b5e83fc848f85\">contribution here</a> looks interesting or does it need more refinement / improvement?  To me though it's as \"simple\" as what <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/plalx/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/plalx\">@plalx</a> said above:</p>\n<blockquote>\n<p dir=\"auto\">structural type checking is used only where contracts are defined in terms of interfaces and nominal typing is used when contracts are defined in terms of concrete classes: concrete classes also makes the promise of an implementation which is a form of contract.</p>\n</blockquote>\n<p dir=\"auto\">However if it was as \"simple\" as this it would have been implemented so I know I must be missing a lot of thinking around this simpler use case which would avoid very easy to make runtime bugs like <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38759571\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/251\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/251/hovercard\" href=\"https://github.com/microsoft/TypeScript/issues/251\">#251</a>.</p>\n<p dir=\"auto\">Thanks :)</p>\n<p dir=\"auto\">** <strong>edit</strong> ** I retract my previous statement and disagree with <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/plalx/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/plalx\">@plalx</a> .  Interfaces should be treated nominally as well.  For example if you serialised an a JetPlane, you want not want to be able to use it to construct a chicken:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"interface IChicken {\n  id: number;\n  name: string;\n}\nclass Chicken implements IChicken {\n  id: number;\n  name: string;\n  constructor(kwargs: IChicken) {\n    this.id = kwargs.id;\n    this.name = kwargs.name;\n  }\n}\n\ninterface IJetPlane {\n  id: number;\n  name: string;\n}\n\nvar serialisedJetPlane: IJetPlane = {id: 1, name: 'Vulcan'};\nvar chick = new Chicken(serialisedJetPlane);  // should error\"><pre class=\"notranslate\"><code class=\"notranslate\">interface IChicken {\n  id: number;\n  name: string;\n}\nclass Chicken implements IChicken {\n  id: number;\n  name: string;\n  constructor(kwargs: IChicken) {\n    this.id = kwargs.id;\n    this.name = kwargs.name;\n  }\n}\n\ninterface IJetPlane {\n  id: number;\n  name: string;\n}\n\nvar serialisedJetPlane: IJetPlane = {id: 1, name: 'Vulcan'};\nvar chick = new Chicken(serialisedJetPlane);  // should error\n</code></pre></div>\n<p dir=\"auto\">If you actually wanted to do that then perhaps you could cast:  <code class=\"notranslate\">var chick = new Chicken(&lt;IChicken&gt; serialisedJetPlane);</code></p>",
        "createdAt": "2016-01-13T13:18:47Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-171287402",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDE3MzEzODMxNw==",
        "author": {
          "login": "antanas-arvasevicius"
        },
        "authorAssociation": "NONE",
        "body": "Hi,\nI really miss a nominal types in TypeScript as it would allow code DSLs and other stuff more easily. Now we cannot constrain API to allow only certain type, for example \n\n```\ntype OrderId = string;\n\nfunction processOrder(id:OrderId)\n```\n\nnow any id/string can be passed to any API and we just get very little by doing that - no compile type checking.\n\nHow could be useful nominal typing can be seen in this excellent example of usage in Scala's Squant library: http://www.squants.com/\n",
        "bodyHTML": "<p dir=\"auto\">Hi,<br>\nI really miss a nominal types in TypeScript as it would allow code DSLs and other stuff more easily. Now we cannot constrain API to allow only certain type, for example</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"type OrderId = string;\n\nfunction processOrder(id:OrderId)\"><pre class=\"notranslate\"><code class=\"notranslate\">type OrderId = string;\n\nfunction processOrder(id:OrderId)\n</code></pre></div>\n<p dir=\"auto\">now any id/string can be passed to any API and we just get very little by doing that - no compile type checking.</p>\n<p dir=\"auto\">How could be useful nominal typing can be seen in this excellent example of usage in Scala's Squant library: <a href=\"http://www.squants.com/\" rel=\"nofollow\">http://www.squants.com/</a></p>",
        "createdAt": "2016-01-20T09:12:02Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-173138317",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDE3MzE0Mzk4Mw==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "@antanas-arvasevicius\n\nnominals are scheduled some time past 2.0: https://github.com/Microsoft/TypeScript/wiki/Roadmap\n\nfor now the only type that is somewhat nominal is enum, in your example it would be\n\n``` typescript\nconst enum AsOrderId {}\ntype OrderId = string & AsOrderId;\nlet orderId = <OrderId> '123';\norderId = '124'; // <-- problem\n\n```\n\nI am saying somewhat because enum's coerce to numbers and back.\n\nsome languages have units of measure as a first class feature: https://msdn.microsoft.com/en-us/library/dd233243.aspx\n\nwe here hope to get them too long time: https://github.com/Microsoft/TypeScript/issues/364\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/antanas-arvasevicius/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/antanas-arvasevicius\">@antanas-arvasevicius</a></p>\n<p dir=\"auto\">nominals are scheduled some time past 2.0: <a href=\"https://github.com/Microsoft/TypeScript/wiki/Roadmap\">https://github.com/Microsoft/TypeScript/wiki/Roadmap</a></p>\n<p dir=\"auto\">for now the only type that is somewhat nominal is enum, in your example it would be</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const enum AsOrderId {}\ntype OrderId = string &amp; AsOrderId;\nlet orderId = &lt;OrderId&gt; '123';\norderId = '124'; // &lt;-- problem\n\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-k\">enum</span> <span class=\"pl-smi\">AsOrderId</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">OrderId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">string</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">AsOrderId</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">orderId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">OrderId</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-s\">'123'</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">orderId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'124'</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// &lt;-- problem</span></pre></div>\n<p dir=\"auto\">I am saying somewhat because enum's coerce to numbers and back.</p>\n<p dir=\"auto\">some languages have units of measure as a first class feature: <a href=\"https://msdn.microsoft.com/en-us/library/dd233243.aspx\" rel=\"nofollow\">https://msdn.microsoft.com/en-us/library/dd233243.aspx</a></p>\n<p dir=\"auto\">we here hope to get them too long time: <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"39567277\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/364\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/364/hovercard\" href=\"https://github.com/microsoft/TypeScript/issues/364\">#364</a></p>",
        "createdAt": "2016-01-20T09:31:04Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-173143983",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDE3MzE4Mjc1Ng==",
        "author": {
          "login": "antanas-arvasevicius"
        },
        "authorAssociation": "NONE",
        "body": "Thank you Alexey! This should be enough for enforcing compiler to type check arguments.\n\nOh, didn't know that this kind of stuff already exists :)\n",
        "bodyHTML": "<p dir=\"auto\">Thank you Alexey! This should be enough for enforcing compiler to type check arguments.</p>\n<p dir=\"auto\">Oh, didn't know that this kind of stuff already exists :)</p>",
        "createdAt": "2016-01-20T11:55:24Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-173182756",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDE4NDIzNDYyOQ==",
        "author": {
          "login": "nahuel"
        },
        "authorAssociation": "NONE",
        "body": "@aleksey-bykov\n\nyour workaround seems to fail for the `number` type (but `string`, `boolean`, etc, works ok): \n\n``` typescript\nconst enum AsOrderId {}\ntype OrderId = number & AsOrderId;\nlet orderId = <OrderId> 123;\norderId = 124; // <-- passes ok (but is wrong)\n```\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Aleksey-Bykov/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Aleksey-Bykov\">@Aleksey-Bykov</a></p>\n<p dir=\"auto\">your workaround seems to fail for the <code class=\"notranslate\">number</code> type (but <code class=\"notranslate\">string</code>, <code class=\"notranslate\">boolean</code>, etc, works ok):</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const enum AsOrderId {}\ntype OrderId = number &amp; AsOrderId;\nlet orderId = &lt;OrderId&gt; 123;\norderId = 124; // &lt;-- passes ok (but is wrong)\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-k\">enum</span> <span class=\"pl-smi\">AsOrderId</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">OrderId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">AsOrderId</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">orderId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">OrderId</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-c1\">123</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">orderId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">124</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// &lt;-- passes ok (but is wrong)</span></pre></div>",
        "createdAt": "2016-02-15T14:41:49Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-184234629",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDE4NDM1MjYyNg==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "that's right, because numbers coerce to enums and enums coerce to numbers, in order to overcome this you might want consider the following:\n\n``` typescript\nmodule AsOrderId { export const enum Brand {} }\ninterface AsOrderId { '': AsOrderId.Brand; }\ntype OrderId = number & AsOrderId;\nlet orderId = <OrderId> 123;\norderId = 124; // <-- now complaints as expected\n```\n",
        "bodyHTML": "<p dir=\"auto\">that's right, because numbers coerce to enums and enums coerce to numbers, in order to overcome this you might want consider the following:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"module AsOrderId { export const enum Brand {} }\ninterface AsOrderId { '': AsOrderId.Brand; }\ntype OrderId = number &amp; AsOrderId;\nlet orderId = &lt;OrderId&gt; 123;\norderId = 124; // &lt;-- now complaints as expected\"><pre class=\"notranslate\">module <span class=\"pl-smi\">AsOrderId</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">export</span> <span class=\"pl-k\">const</span> <span class=\"pl-k\">enum</span> <span class=\"pl-smi\">Brand</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">AsOrderId</span> <span class=\"pl-kos\">{</span> <span class=\"pl-s\">''</span>: <span class=\"pl-smi\">AsOrderId</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Brand</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">OrderId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">AsOrderId</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">orderId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">OrderId</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-c1\">123</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">orderId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">124</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// &lt;-- now complaints as expected</span></pre></div>",
        "createdAt": "2016-02-15T19:21:51Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-184352626",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDE5ODIyODc3Ng==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "Here's a use case where I know I'll need nominal types for: number subtyping. In a performance-critical section of code for a project I'm intermittently working on, I need several different pointer types used with a reference-counting cache. Because of certain API hooks, I already have to do significant manual management, but mostly using numbers will help reduce memory dramatically and drastically increase speed for this.\n\nSomething like this, but imagine several files full of this madness:\n\n``` ts\n// ./types.ts\nexport nominal Pointer extends number {}\nexport nominal TypePointer extends Pointer {}\nexport nominal AttrPointer extends Pointer {}\nexport nominal ChildrenPointer extends Pointer {}\nexport nominal ChildPointer extends Pointer {}\nexport interface Node {}\n\n// ./caches.ts\nimport {AttrPointer, ChildrenPointer} from \"./types\"\n\nclass ReferenceCache<T, U extends number> {\n  // properties\n  function get(entry: U): T { /* whatever */ }\n  function add(entry: T): U { /* whatever */ }\n  function delete(entry: U): void { /* whatever */ }\n}\n\nexport const attrCache = new ReferenceCache<any, AttrPointer>()\nexport const childCache = new ReferenceCache<Child[], ChildrenPointer>()\n\n// ./patch.ts\nimport {attrCache, childCache} from \"./caches\"\nimport {Pointer, Node, AttrPointer, ChildrenPointer} from \"./types\"\n\nfunction patch(nodes: Pointer[], start: i, node: Node) {\n  const attrs = attrCache.get(<AttrPointer> nodes[i + 1])\n  checkAttrs(attrs, node.attrs)\n\n  const children = childCache.get(<ChildrenPointer> nodes[i + 2])\n  const normalized = normalize(node.children)\n  checkChildren(attrs, node.attrs)\n}\n```\n",
        "bodyHTML": "<p dir=\"auto\">Here's a use case where I know I'll need nominal types for: number subtyping. In a performance-critical section of code for a project I'm intermittently working on, I need several different pointer types used with a reference-counting cache. Because of certain API hooks, I already have to do significant manual management, but mostly using numbers will help reduce memory dramatically and drastically increase speed for this.</p>\n<p dir=\"auto\">Something like this, but imagine several files full of this madness:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// ./types.ts\nexport nominal Pointer extends number {}\nexport nominal TypePointer extends Pointer {}\nexport nominal AttrPointer extends Pointer {}\nexport nominal ChildrenPointer extends Pointer {}\nexport nominal ChildPointer extends Pointer {}\nexport interface Node {}\n\n// ./caches.ts\nimport {AttrPointer, ChildrenPointer} from &quot;./types&quot;\n\nclass ReferenceCache&lt;T, U extends number&gt; {\n  // properties\n  function get(entry: U): T { /* whatever */ }\n  function add(entry: T): U { /* whatever */ }\n  function delete(entry: U): void { /* whatever */ }\n}\n\nexport const attrCache = new ReferenceCache&lt;any, AttrPointer&gt;()\nexport const childCache = new ReferenceCache&lt;Child[], ChildrenPointer&gt;()\n\n// ./patch.ts\nimport {attrCache, childCache} from &quot;./caches&quot;\nimport {Pointer, Node, AttrPointer, ChildrenPointer} from &quot;./types&quot;\n\nfunction patch(nodes: Pointer[], start: i, node: Node) {\n  const attrs = attrCache.get(&lt;AttrPointer&gt; nodes[i + 1])\n  checkAttrs(attrs, node.attrs)\n\n  const children = childCache.get(&lt;ChildrenPointer&gt; nodes[i + 2])\n  const normalized = normalize(node.children)\n  checkChildren(attrs, node.attrs)\n}\"><pre class=\"notranslate\"><span class=\"pl-c\">// ./types.ts</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-s1\">nominal</span> <span class=\"pl-smi\">Pointer</span> <span class=\"pl-s1\">extends</span> number <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-s1\">nominal</span> <span class=\"pl-smi\">TypePointer</span> <span class=\"pl-s1\">extends</span> <span class=\"pl-smi\">Pointer</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-s1\">nominal</span> <span class=\"pl-smi\">AttrPointer</span> <span class=\"pl-s1\">extends</span> <span class=\"pl-smi\">Pointer</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-s1\">nominal</span> <span class=\"pl-smi\">ChildrenPointer</span> <span class=\"pl-s1\">extends</span> <span class=\"pl-smi\">Pointer</span><span class=\"pl-kos\"></span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-s1\">nominal</span> <span class=\"pl-smi\">ChildPointer</span> <span class=\"pl-s1\">extends</span> <span class=\"pl-smi\">Pointer</span><span class=\"pl-kos\"></span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">Node</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n\n<span class=\"pl-c\">// ./caches.ts</span>\n<span class=\"pl-k\">import</span> <span class=\"pl-kos\">{</span><span class=\"pl-smi\">AttrPointer</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">ChildrenPointer</span><span class=\"pl-kos\">}</span> <span class=\"pl-k\">from</span> <span class=\"pl-s\">\"./types\"</span>\n\n<span class=\"pl-k\">class</span> <span class=\"pl-smi\">ReferenceCache</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">U</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">number</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c\">// properties</span>\n  <span class=\"pl-en\">function</span> <span class=\"pl-s1\">get</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">entry</span>: <span class=\"pl-smi\">U</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">T</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c\">/* whatever */</span> <span class=\"pl-kos\">}</span>\n  <span class=\"pl-en\">function</span> <span class=\"pl-s1\">add</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">entry</span>: <span class=\"pl-smi\">T</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">U</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c\">/* whatever */</span> <span class=\"pl-kos\">}</span>\n  <span class=\"pl-en\">function</span> <span class=\"pl-s1\">delete</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">entry</span>: <span class=\"pl-smi\">U</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\"><span class=\"pl-k\">void</span></span> <span class=\"pl-kos\">{</span> <span class=\"pl-c\">/* whatever */</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">attrCache</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">ReferenceCache</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">any</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">AttrPointer</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">childCache</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">ReferenceCache</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Child</span><span class=\"pl-kos\">[</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">ChildrenPointer</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>\n\n<span class=\"pl-c\">// ./patch.ts</span>\n<span class=\"pl-k\">import</span> <span class=\"pl-kos\">{</span><span class=\"pl-s1\">attrCache</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">childCache</span><span class=\"pl-kos\">}</span> <span class=\"pl-k\">from</span> <span class=\"pl-s\">\"./caches\"</span>\n<span class=\"pl-k\">import</span> <span class=\"pl-kos\">{</span><span class=\"pl-smi\">Pointer</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">Node</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">AttrPointer</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">ChildrenPointer</span><span class=\"pl-kos\">}</span> <span class=\"pl-k\">from</span> <span class=\"pl-s\">\"./types\"</span>\n\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">patch</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">nodes</span>: <span class=\"pl-smi\">Pointer</span><span class=\"pl-kos\">[</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">start</span>: <span class=\"pl-smi\">i</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">node</span>: <span class=\"pl-smi\">Node</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">attrs</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">attrCache</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">get</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">AttrPointer</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-s1\">nodes</span><span class=\"pl-kos\">[</span><span class=\"pl-s1\">i</span> <span class=\"pl-c1\">+</span> <span class=\"pl-c1\">1</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">)</span>\n  <span class=\"pl-en\">checkAttrs</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">attrs</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">attrs</span><span class=\"pl-kos\">)</span>\n\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">children</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">childCache</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">get</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">ChildrenPointer</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-s1\">nodes</span><span class=\"pl-kos\">[</span><span class=\"pl-s1\">i</span> <span class=\"pl-c1\">+</span> <span class=\"pl-c1\">2</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">)</span>\n  <span class=\"pl-k\">const</span> <span class=\"pl-s1\">normalized</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">normalize</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">children</span><span class=\"pl-kos\">)</span>\n  <span class=\"pl-en\">checkChildren</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">attrs</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">attrs</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-kos\">}</span></pre></div>",
        "createdAt": "2016-03-18T06:36:33Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-198228776",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDIwNzc2MjY1Mg==",
        "author": {
          "login": "patrickjuchli"
        },
        "authorAssociation": "NONE",
        "body": "I disagree with the chicken example by @AJamesPhillips, the distinction between classes and interfaces @plalx made is important. \n\nIf two `interface` declarations are structurally the same then they offer the same behaviour and should be treated the same. Isn't that the main point of interfaces? To implement a Toaster and a Mixer and have them satisfy the same IPowerSwitch interface? From the perspective of such an interface, a Toaster and a Mixer are the same thing. And if someone creates a second interface having the same behaviour then that means that it doesn't matter which one you use. Maybe I have this opinion because to me interfaces are first about behaviour and less about what something _is_.\n",
        "bodyHTML": "<p dir=\"auto\">I disagree with the chicken example by <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/AJamesPhillips/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/AJamesPhillips\">@AJamesPhillips</a>, the distinction between classes and interfaces <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/plalx/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/plalx\">@plalx</a> made is important.</p>\n<p dir=\"auto\">If two <code class=\"notranslate\">interface</code> declarations are structurally the same then they offer the same behaviour and should be treated the same. Isn't that the main point of interfaces? To implement a Toaster and a Mixer and have them satisfy the same IPowerSwitch interface? From the perspective of such an interface, a Toaster and a Mixer are the same thing. And if someone creates a second interface having the same behaviour then that means that it doesn't matter which one you use. Maybe I have this opinion because to me interfaces are first about behaviour and less about what something <em>is</em>.</p>",
        "createdAt": "2016-04-09T10:04:20Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-207762652",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDIwNzgzNjg0Mg==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@patrickjuchli BTW, some libraries return instances of classes and match with `instanceof`, but don't provide the constructor.\n\nAlthough IMHO after #7642 gets addressed, the only desire I have for nominal typing is for opaque numeric subtypes (used as pointers) and types whose structure is purely an implementation detail.\n\nI'd love to see if I can crack the nut of asm.js in TypeScript, but numeric subtypes are the only realistic way I could do that and keep types straight.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/patrickjuchli/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/patrickjuchli\">@patrickjuchli</a> BTW, some libraries return instances of classes and match with <code class=\"notranslate\">instanceof</code>, but don't provide the constructor.</p>\n<p dir=\"auto\">Although IMHO after <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"142767954\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/7642\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/7642/hovercard\" href=\"https://github.com/microsoft/TypeScript/issues/7642\">#7642</a> gets addressed, the only desire I have for nominal typing is for opaque numeric subtypes (used as pointers) and types whose structure is purely an implementation detail.</p>\n<p dir=\"auto\">I'd love to see if I can crack the nut of asm.js in TypeScript, but numeric subtypes are the only realistic way I could do that and keep types straight.</p>",
        "createdAt": "2016-04-09T19:17:12Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-207836842",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDIwNzk5OTk5NQ==",
        "author": {
          "login": "AJamesPhillips"
        },
        "authorAssociation": "NONE",
        "body": "@patrickjuchli I think I've come round to that point of view.  For \"nominal\" interfaces I'm using the following:\n\n``` typescript\ninterface IJetPlane {\n  IJetPlane: string;\n  id: number;\n  name: string;\n  optional?: string;\n}\n```\n\nIt's slightly ungainly.  It is a leaky implementation of nominal interfaces but serves it's purpose for my project using POJOs & Redux (I don't want to continuously go from class instances and back).  Alternatively [aleksey-bykov's comment](https://github.com/Microsoft/TypeScript/issues/202#issuecomment-184352626) is useful.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/patrickjuchli/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/patrickjuchli\">@patrickjuchli</a> I think I've come round to that point of view.  For \"nominal\" interfaces I'm using the following:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"interface IJetPlane {\n  IJetPlane: string;\n  id: number;\n  name: string;\n  optional?: string;\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">interface</span> <span class=\"pl-smi\">IJetPlane</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c1\">IJetPlane</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-c1\">id</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-c1\">name</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-c1\">optional</span>?: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">It's slightly ungainly.  It is a leaky implementation of nominal interfaces but serves it's purpose for my project using POJOs &amp; Redux (I don't want to continuously go from class instances and back).  Alternatively <a href=\"https://github.com/Microsoft/TypeScript/issues/202#issuecomment-184352626\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">aleksey-bykov's comment</a> is useful.</p>",
        "createdAt": "2016-04-10T15:30:18Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-207999995",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDIwODA5NzgwMA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@patrickjuchli @AJamesPhillips \n\nWhat I'm currently using is this (it's in a `.d.ts` file):\n\n``` ts\ninterface AddUpdate<T> extends Update {\n  \"update add\": this;\n  mask: nodes;\n  index: number;\n  child: Child<T>;\n}\n```\n\nGranted, this would fare better with [const enums also being permitted as types](https://github.com/Microsoft/TypeScript/issues/7642), but that or nominal types would be okay.\n\n``` ts\ninterface AddUpdate<T> extends Update {\n  mask: nodes.ADD;\n  index: number;\n  child: Child<T>;\n}\n```\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/patrickjuchli/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/patrickjuchli\">@patrickjuchli</a> <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/AJamesPhillips/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/AJamesPhillips\">@AJamesPhillips</a></p>\n<p dir=\"auto\">What I'm currently using is this (it's in a <code class=\"notranslate\">.d.ts</code> file):</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"interface AddUpdate&lt;T&gt; extends Update {\n  &quot;update add&quot;: this;\n  mask: nodes;\n  index: number;\n  child: Child&lt;T&gt;;\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">interface</span> <span class=\"pl-smi\">AddUpdate</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Update</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-s\">\"update add\"</span>: this<span class=\"pl-kos\">;</span>\n  <span class=\"pl-c1\">mask</span>: <span class=\"pl-smi\">nodes</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-c1\">index</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-c1\">child</span>: <span class=\"pl-smi\">Child</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">Granted, this would fare better with <a href=\"https://github.com/Microsoft/TypeScript/issues/7642\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/7642/hovercard\">const enums also being permitted as types</a>, but that or nominal types would be okay.</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"interface AddUpdate&lt;T&gt; extends Update {\n  mask: nodes.ADD;\n  index: number;\n  child: Child&lt;T&gt;;\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">interface</span> <span class=\"pl-smi\">AddUpdate</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Update</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c1\">mask</span>: <span class=\"pl-s1\">nodes</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">ADD</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-c1\">index</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-c1\">child</span>: <span class=\"pl-smi\">Child</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>",
        "createdAt": "2016-04-11T00:02:51Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-208097800",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDIwOTE1NjcxNg==",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "Note that nominal types will lead to surprising results with npm (node_modules) style commonjs modules. Nominal types that come from different versions of the same module will be different and incompatible (unless they are explicitly told what their unique name is).\n\nShould be less of an issue with npm version 3.\n",
        "bodyHTML": "<p dir=\"auto\">Note that nominal types will lead to surprising results with npm (node_modules) style commonjs modules. Nominal types that come from different versions of the same module will be different and incompatible (unless they are explicitly told what their unique name is).</p>\n<p dir=\"auto\">Should be less of an issue with npm version 3.</p>",
        "createdAt": "2016-04-13T00:01:33Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-209156716",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDIxMDU3OTk2MQ==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "By the way, I would expect nominal types to still match equivalent\nstructural interfaces. But I would mainly find nominal types useful for\nkeeping number subtypes straight. This varies from units in scientific\ncalculations to numeric pointers to types that their type is computed from\nthe result of a value (such as a combination of bitwise flags).\n\nThe last one requires dependent types (types dependent on their value),\nwhich are probably not making it into TypeScript anytime soon, since it's\nonly just now getting past the purely academic and experimental world into\nHaskell. It also makes a type system Turing complete, which a lot of\nlanguage writers don't usually like, by allowing type-level functions and\nlambdas.\n\nOn Tue, Apr 12, 2016, 20:02 Gorgi Kosev notifications@github.com wrote:\n\n> Note that nominal types will lead to surprising results with npm\n> (node_modules) style commonjs modules (unless they are explicitly told what\n> their unique name is). Nominal types that come from different versions of\n> the same module will likely be different.\n> \n> —\n> You are receiving this because you commented.\n> Reply to this email directly or view it on GitHub\n> https://github.com/Microsoft/TypeScript/issues/202#issuecomment-209156716\n",
        "bodyHTML": "<p dir=\"auto\">By the way, I would expect nominal types to still match equivalent<br>\nstructural interfaces. But I would mainly find nominal types useful for<br>\nkeeping number subtypes straight. This varies from units in scientific<br>\ncalculations to numeric pointers to types that their type is computed from<br>\nthe result of a value (such as a combination of bitwise flags).</p>\n<p dir=\"auto\">The last one requires dependent types (types dependent on their value),<br>\nwhich are probably not making it into TypeScript anytime soon, since it's<br>\nonly just now getting past the purely academic and experimental world into<br>\nHaskell. It also makes a type system Turing complete, which a lot of<br>\nlanguage writers don't usually like, by allowing type-level functions and<br>\nlambdas.</p>\n<p dir=\"auto\">On Tue, Apr 12, 2016, 20:02 Gorgi Kosev <a href=\"mailto:notifications@github.com\">notifications@github.com</a> wrote:</p>\n<blockquote>\n<p dir=\"auto\">Note that nominal types will lead to surprising results with npm<br>\n(node_modules) style commonjs modules (unless they are explicitly told what<br>\ntheir unique name is). Nominal types that come from different versions of<br>\nthe same module will likely be different.</p>\n<p dir=\"auto\">—<br>\nYou are receiving this because you commented.<br>\nReply to this email directly or view it on GitHub<br>\n<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard?comment_id=209156716&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-209156716\">#202 (comment)</a></p>\n</blockquote>",
        "createdAt": "2016-04-15T18:31:40Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-210579961",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDIxOTI2MDE5Nw==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "I need a nominal type for an opaque object whose structure is an implementation detail. I need this badly.\n",
        "bodyHTML": "<p dir=\"auto\">I need a nominal type for an opaque object whose structure is an implementation detail. I need this badly.</p>",
        "createdAt": "2016-05-15T01:06:06Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-219260197",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDIyMTQzNzkwOA==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "Intersecting with a branded interface seems pretty close to what we want to be possible:\n\n```\n> enum YearsBrand {}\nundefined\n> type Years = number & { _brand: YearsBrand }\nundefined\n> enum DaysBrand {}\nundefined\n> type Days = number & { _brand: DaysBrand }\nundefined\n> function yearsToDays(years: Years): Days { return <Days> years * 365; }\n⨯ Unable to compile TypeScript\n[eval].ts (6,51): Neither type 'number & { _brand: YearsBrand; }' nor type 'number & { _brand: DaysBrand; }' is assignable to the other.\n  Type 'number & { _brand: YearsBrand; }' is not assignable to type '{ _brand: DaysBrand; }'.\n    Type '{ _brand: YearsBrand; }' is not assignable to type '{ _brand: DaysBrand; }'.\n      Types of property '_brand' are incompatible.\n        Type 'YearsBrand' is not assignable to type 'DaysBrand'. (2352)\n[eval].ts (6,51): The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type. (2362)\n[eval].ts (6,51): Type 'number' is not assignable to type 'number & { _brand: DaysBrand; }'.\n  Type 'number' is not assignable to type '{ _brand: DaysBrand; }'. (2322)\n> function yearsToDays(years: Years): Days { return <Days> (<number> years * 365); }\nundefined\n> yearsToDays(30)\n⨯ Unable to compile TypeScript\n[eval].ts (7,13): Argument of type 'number' is not assignable to parameter of type 'number & { _brand: YearsBrand; }'.\n  Type 'number' is not assignable to type '{ _brand: YearsBrand; }'. (2345)\n> let age = <Years> 30\nundefined\n> yearsToDays(age)\n10950\n```\n\nIt would be nice if Typescript gave better errors and supported lifting operators, which implies a declaration syntax (I favor `new type Foo = Bar` to avoid more keywords, and it looks like the same feature in Haskell)\n\nBeing able to use them as keys would also be handy:\n\n```\n> enum UserIdBrand {}\nundefined\n> type UserId = string & { _brand: UserIdBrand }\nundefined\n> interface SessionCache { [userId: UserId]: any }\n⨯ Unable to compile TypeScript\n[eval].ts (10,27): An index signature parameter type must be 'string' or 'number'. (1023)\n```\n",
        "bodyHTML": "<p dir=\"auto\">Intersecting with a branded interface seems pretty close to what we want to be possible:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"&gt; enum YearsBrand {}\nundefined\n&gt; type Years = number &amp; { _brand: YearsBrand }\nundefined\n&gt; enum DaysBrand {}\nundefined\n&gt; type Days = number &amp; { _brand: DaysBrand }\nundefined\n&gt; function yearsToDays(years: Years): Days { return &lt;Days&gt; years * 365; }\n⨯ Unable to compile TypeScript\n[eval].ts (6,51): Neither type 'number &amp; { _brand: YearsBrand; }' nor type 'number &amp; { _brand: DaysBrand; }' is assignable to the other.\n  Type 'number &amp; { _brand: YearsBrand; }' is not assignable to type '{ _brand: DaysBrand; }'.\n    Type '{ _brand: YearsBrand; }' is not assignable to type '{ _brand: DaysBrand; }'.\n      Types of property '_brand' are incompatible.\n        Type 'YearsBrand' is not assignable to type 'DaysBrand'. (2352)\n[eval].ts (6,51): The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type. (2362)\n[eval].ts (6,51): Type 'number' is not assignable to type 'number &amp; { _brand: DaysBrand; }'.\n  Type 'number' is not assignable to type '{ _brand: DaysBrand; }'. (2322)\n&gt; function yearsToDays(years: Years): Days { return &lt;Days&gt; (&lt;number&gt; years * 365); }\nundefined\n&gt; yearsToDays(30)\n⨯ Unable to compile TypeScript\n[eval].ts (7,13): Argument of type 'number' is not assignable to parameter of type 'number &amp; { _brand: YearsBrand; }'.\n  Type 'number' is not assignable to type '{ _brand: YearsBrand; }'. (2345)\n&gt; let age = &lt;Years&gt; 30\nundefined\n&gt; yearsToDays(age)\n10950\"><pre class=\"notranslate\"><code class=\"notranslate\">&gt; enum YearsBrand {}\nundefined\n&gt; type Years = number &amp; { _brand: YearsBrand }\nundefined\n&gt; enum DaysBrand {}\nundefined\n&gt; type Days = number &amp; { _brand: DaysBrand }\nundefined\n&gt; function yearsToDays(years: Years): Days { return &lt;Days&gt; years * 365; }\n⨯ Unable to compile TypeScript\n[eval].ts (6,51): Neither type 'number &amp; { _brand: YearsBrand; }' nor type 'number &amp; { _brand: DaysBrand; }' is assignable to the other.\n  Type 'number &amp; { _brand: YearsBrand; }' is not assignable to type '{ _brand: DaysBrand; }'.\n    Type '{ _brand: YearsBrand; }' is not assignable to type '{ _brand: DaysBrand; }'.\n      Types of property '_brand' are incompatible.\n        Type 'YearsBrand' is not assignable to type 'DaysBrand'. (2352)\n[eval].ts (6,51): The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type. (2362)\n[eval].ts (6,51): Type 'number' is not assignable to type 'number &amp; { _brand: DaysBrand; }'.\n  Type 'number' is not assignable to type '{ _brand: DaysBrand; }'. (2322)\n&gt; function yearsToDays(years: Years): Days { return &lt;Days&gt; (&lt;number&gt; years * 365); }\nundefined\n&gt; yearsToDays(30)\n⨯ Unable to compile TypeScript\n[eval].ts (7,13): Argument of type 'number' is not assignable to parameter of type 'number &amp; { _brand: YearsBrand; }'.\n  Type 'number' is not assignable to type '{ _brand: YearsBrand; }'. (2345)\n&gt; let age = &lt;Years&gt; 30\nundefined\n&gt; yearsToDays(age)\n10950\n</code></pre></div>\n<p dir=\"auto\">It would be nice if Typescript gave better errors and supported lifting operators, which implies a declaration syntax (I favor <code class=\"notranslate\">new type Foo = Bar</code> to avoid more keywords, and it looks like the same feature in Haskell)</p>\n<p dir=\"auto\">Being able to use them as keys would also be handy:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"&gt; enum UserIdBrand {}\nundefined\n&gt; type UserId = string &amp; { _brand: UserIdBrand }\nundefined\n&gt; interface SessionCache { [userId: UserId]: any }\n⨯ Unable to compile TypeScript\n[eval].ts (10,27): An index signature parameter type must be 'string' or 'number'. (1023)\"><pre class=\"notranslate\"><code class=\"notranslate\">&gt; enum UserIdBrand {}\nundefined\n&gt; type UserId = string &amp; { _brand: UserIdBrand }\nundefined\n&gt; interface SessionCache { [userId: UserId]: any }\n⨯ Unable to compile TypeScript\n[eval].ts (10,27): An index signature parameter type must be 'string' or 'number'. (1023)\n</code></pre></div>",
        "createdAt": "2016-05-25T00:04:55Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-221437908",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDIyMTc4MTkwMA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@simonbuchan \n\nThat's the essence of nominal subtypes: sometimes you need numbers with formally correct unit handling, sometimes you need just an ordered, statically known set of numbers (that's enums of today), and sometimes you need to handle certain string keys as if they were their own type (where there are _n_ possibilities, but they are more than just strings).\n\nI've had a case where I need nominal interfaces for objects, because it would be an acceptable compromise to dependent types for a definition file. In my case, the object's type is dependent on the first few bits of a mask on the object itself, but since dependent types (types that depend on the value) won't likely exist in TypeScript for quite a while if ever, nominal interfaces with casting would work.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/simonbuchan/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/simonbuchan\">@simonbuchan</a></p>\n<p dir=\"auto\">That's the essence of nominal subtypes: sometimes you need numbers with formally correct unit handling, sometimes you need just an ordered, statically known set of numbers (that's enums of today), and sometimes you need to handle certain string keys as if they were their own type (where there are <em>n</em> possibilities, but they are more than just strings).</p>\n<p dir=\"auto\">I've had a case where I need nominal interfaces for objects, because it would be an acceptable compromise to dependent types for a definition file. In my case, the object's type is dependent on the first few bits of a mask on the object itself, but since dependent types (types that depend on the value) won't likely exist in TypeScript for quite a while if ever, nominal interfaces with casting would work.</p>",
        "createdAt": "2016-05-26T05:35:42Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-221781900",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDIyMTc4MzYzNw==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows Yes? My comment was that Typescript already allows the creation of distinct (that is, nominal) types without changing the runtime shape (e.g. `{ ObjectId_value: string }`), so the (real!) concern of \"How do we avoid breaking the entire typesystem\" can be approached as \"How do we make this terrible hack on the type system less unusable\", or in other words: if it would be broken with a new feature, it may already be broken! (In a bizzare edge-case, not a hopefully heavily used new feature)\n",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows Yes? My comment was that Typescript already allows the creation of distinct (that is, nominal) types without changing the runtime shape (e.g. <code class=\"notranslate\">{ ObjectId_value: string }</code>), so the (real!) concern of \"How do we avoid breaking the entire typesystem\" can be approached as \"How do we make this terrible hack on the type system less unusable\", or in other words: if it would be broken with a new feature, it may already be broken! (In a bizzare edge-case, not a hopefully heavily used new feature)</p>",
        "createdAt": "2016-05-26T05:50:07Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-221783637",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDIyMTc4Mzk5OQ==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "Of course, you can get many of the same \"benefits\" with just `class Foo {}; let x = <Foo><any> 123` - the intersect hack is only slightly safer without the extra `<any>` (and of course it doesn't generate any extra JS)\n",
        "bodyHTML": "<p dir=\"auto\">Of course, you can get many of the same \"benefits\" with just <code class=\"notranslate\">class Foo {}; let x = &lt;Foo&gt;&lt;any&gt; 123</code> - the intersect hack is only slightly safer without the extra <code class=\"notranslate\">&lt;any&gt;</code> (and of course it doesn't generate any extra JS)</p>",
        "createdAt": "2016-05-26T05:53:18Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-221783999",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDIyMTgwMzk2Mw==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@simonbuchan I'd rather not even expose members that don't exist in the first place. That's why I try to avoid those hacks in the first place.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/simonbuchan/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/simonbuchan\">@simonbuchan</a> I'd rather not even expose members that don't exist in the first place. That's why I try to avoid those hacks in the first place.</p>",
        "createdAt": "2016-05-26T08:02:22Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-221803963",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDIyNDMwMzU3Mg==",
        "author": {
          "login": "patrickjuchli"
        },
        "authorAssociation": "NONE",
        "body": "The V8 team is doing some experiments with SaneScript and SoundScript (in this order). [Short description here](https://github.com/v8/v8/wiki/Experiments%20with%20Strengthening%20JavaScript#soundscript) where they also refer to TypeScript to be used as a basis. \n\nThere is also [a presentation](https://drive.google.com/file/d/0B1v38H64XQBNT1p2XzFGWWhCR1k/view?pref=2&pli=1) with detailed information. On pages 25 and following they talk about introducing nominal classes. Maybe these experiments could be helpful in this discussion.\n",
        "bodyHTML": "<p dir=\"auto\">The V8 team is doing some experiments with SaneScript and SoundScript (in this order). <a href=\"https://github.com/v8/v8/wiki/Experiments%20with%20Strengthening%20JavaScript#soundscript\">Short description here</a> where they also refer to TypeScript to be used as a basis.</p>\n<p dir=\"auto\">There is also <a href=\"https://drive.google.com/file/d/0B1v38H64XQBNT1p2XzFGWWhCR1k/view?pref=2&amp;pli=1\" rel=\"nofollow\">a presentation</a> with detailed information. On pages 25 and following they talk about introducing nominal classes. Maybe these experiments could be helpful in this discussion.</p>",
        "createdAt": "2016-06-07T14:45:12Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-224303572",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDIyNDU3NDI1Nw==",
        "author": {
          "login": "svieira"
        },
        "authorAssociation": "NONE",
        "body": "A slightly generified version of @simonbuchan's state of the art for nominal types in TypeScript is:\n\n``` typescript\n/**\n * Nominal typing for any TypeScript interface or class.\n *\n * If T is an enum type, any type which includes this interface\n * will only match other types that are tagged with the same\n * enum type.\n */\ninterface Nominal<T> { 'nominal structural brand': T }\n```\n\nUsage is identical to his version (and the error messages are _slightly_ better, in my opinion):\n\n``` typescript\ndeclare module Dates {\n  export const enum Years {}\n  export const enum Days {}\n}\n\ntype Years = Nominal<Dates.Years> & number;\ntype Days = Nominal<Dates.Days> & number;\n\nvar day: Days;\nvar years: Years;\nday = years;\n// Type 'Nominal<Year> & number' is not assignable to type 'Nominal<Day> & number'.\n//   Type 'Nominal<Year> & number' is not assignable to type 'Nominal<Day>'.\n//     Type 'number' is not assignable to type 'Nominal<Day>'.\n```\n\nIf it were possible to restrict the type of `T` in the `Nominal` interface to enum types this could be completely type-safe from the consumer's perspective.\n\n### A syntax proposal\n\nAssuming that there was some way of restricting `T` to enum subtypes, the `Nominal` interface could be added as (for example) `lang.Nominal` and some syntactical sugar could be added for creating an interface or class that uses `Nominal`.  I suggest the keyword  `distinct` to tag a type which should be treated as a nominal type:\n\n``` typescript\ndistinct interface SomeInterface { x: number, y: number, z: number }\ndistinct class SomeClass { a: string; b: string; c: string; }\ndistinct type SomeId = number\n```\n\nwould be translated by the compiler (for ES5 and lower targets) as:\n\n``` typescript\ninterface __SomeInterface  { x: number, y: number, z: number }\nconst enum __SomeInterfaceTag {}\ntype SomeInterface = __SomeInterface & lang.Nominal<__SomeInterfaceTag>\n\nclass SomeClass implements lang.Nominal<__SomeClassTag>  {\n  'nominal structural brand': __SomeClassTag;\n  a: string; b: string; c: string;\n}\nconst enum __SomeClassTag {}\n\ntype SomeId = number & lang.Nominal<__SomeIdTag>;\nconst enum __SomeIdTag {};\n```\n\nthe `__`-prefixed enums and interfaces being compiler-generated and inaccessible[1] to user code.\n\n#### Usage\n\nCasts would be necessary for any usage of a `distinct type` or `distinct interface` (but they are necessary for other languages too - such as the [Scala shapeless library's `Tagged` utility](https://github.com/milessabin/shapeless/blob/3a02b7cb3f645077ad16caecbd07a74ff01813cf/core/src/main/scala/shapeless/typeoperators.scala#L25-L34)).  At it's simplest[2]:\n\n``` typescript\n// Types and interfaces just need to be \"tagged\"\nvar interfaceTagging = {x: 1, y: 1, z: 1} as SomeInterface;\nvar typeTagging = 123 as SomeId;\n\n// Classes should be constructed specifically by the nominal constructor\nvar classCreation = new SomeClass('a', 'b', 'c');\n// A cast is also possible, but at that point all type-safety is out the window.\n```\n\n#### Notes\n1. The compiler-generated enum _is_ available to consuming code if it accesses the `'nominal structural brand'` field and uses a type query.  This could be mitigated by using a `Symbol` for the key.\n2. A specific keyword could be added for a \"tagging\" cast:\n   \n   ``` typescript\n   var x = new Point(1, 2, 3) taggedAs SomeInterface;\n   // Errors if SomeInterface is not a lang.Nominal\n   ```\n   \n   I would argue for it since it documents the _purpose_ of the cast and prevents using non-nominative types in nominative (i. e. \"tagging\") casts.\n3. @SimonMeskens [points out an excellent ES2015+ approach that could be very useful as well](https://github.com/Microsoft/TypeScript/issues/10190#issuecomment-238116323) - instead of using the string-keyed 'nominal structural brand' use `Symbol.species` for the brand key and the enum (or the type itself) for the type.\n",
        "bodyHTML": "<p dir=\"auto\">A slightly generified version of <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/simonbuchan/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/simonbuchan\">@simonbuchan</a>'s state of the art for nominal types in TypeScript is:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"/**\n * Nominal typing for any TypeScript interface or class.\n *\n * If T is an enum type, any type which includes this interface\n * will only match other types that are tagged with the same\n * enum type.\n */\ninterface Nominal&lt;T&gt; { 'nominal structural brand': T }\"><pre class=\"notranslate\"><span class=\"pl-c\">/**</span>\n<span class=\"pl-c\"> * Nominal typing for any TypeScript interface or class.</span>\n<span class=\"pl-c\"> *</span>\n<span class=\"pl-c\"> * If T is an enum type, any type which includes this interface</span>\n<span class=\"pl-c\"> * will only match other types that are tagged with the same</span>\n<span class=\"pl-c\"> * enum type.</span>\n<span class=\"pl-c\"> */</span>\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-s\">'nominal structural brand'</span>: <span class=\"pl-smi\">T</span> <span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">Usage is identical to his version (and the error messages are <em>slightly</em> better, in my opinion):</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"declare module Dates {\n  export const enum Years {}\n  export const enum Days {}\n}\n\ntype Years = Nominal&lt;Dates.Years&gt; &amp; number;\ntype Days = Nominal&lt;Dates.Days&gt; &amp; number;\n\nvar day: Days;\nvar years: Years;\nday = years;\n// Type 'Nominal&lt;Year&gt; &amp; number' is not assignable to type 'Nominal&lt;Day&gt; &amp; number'.\n//   Type 'Nominal&lt;Year&gt; &amp; number' is not assignable to type 'Nominal&lt;Day&gt;'.\n//     Type 'number' is not assignable to type 'Nominal&lt;Day&gt;'.\"><pre class=\"notranslate\"><span class=\"pl-k\">declare</span> module <span class=\"pl-smi\">Dates</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">export</span> <span class=\"pl-k\">const</span> <span class=\"pl-k\">enum</span> <span class=\"pl-smi\">Years</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n  <span class=\"pl-k\">export</span> <span class=\"pl-k\">const</span> <span class=\"pl-k\">enum</span> <span class=\"pl-smi\">Days</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Years</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Dates</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Years</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Days</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Dates</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Days</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">var</span> <span class=\"pl-s1\">day</span>: <span class=\"pl-smi\">Days</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">var</span> <span class=\"pl-s1\">years</span>: <span class=\"pl-smi\">Years</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">day</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">years</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-c\">// Type 'Nominal&lt;Year&gt; &amp; number' is not assignable to type 'Nominal&lt;Day&gt; &amp; number'.</span>\n<span class=\"pl-c\">//   Type 'Nominal&lt;Year&gt; &amp; number' is not assignable to type 'Nominal&lt;Day&gt;'.</span>\n<span class=\"pl-c\">//     Type 'number' is not assignable to type 'Nominal&lt;Day&gt;'.</span></pre></div>\n<p dir=\"auto\">If it were possible to restrict the type of <code class=\"notranslate\">T</code> in the <code class=\"notranslate\">Nominal</code> interface to enum types this could be completely type-safe from the consumer's perspective.</p>\n<h3 dir=\"auto\">A syntax proposal</h3>\n<p dir=\"auto\">Assuming that there was some way of restricting <code class=\"notranslate\">T</code> to enum subtypes, the <code class=\"notranslate\">Nominal</code> interface could be added as (for example) <code class=\"notranslate\">lang.Nominal</code> and some syntactical sugar could be added for creating an interface or class that uses <code class=\"notranslate\">Nominal</code>.  I suggest the keyword  <code class=\"notranslate\">distinct</code> to tag a type which should be treated as a nominal type:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"distinct interface SomeInterface { x: number, y: number, z: number }\ndistinct class SomeClass { a: string; b: string; c: string; }\ndistinct type SomeId = number\"><pre class=\"notranslate\"><span class=\"pl-s1\">distinct</span> <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">SomeInterface</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">x</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">y</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">z</span>: <span class=\"pl-smi\">number</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-s1\">distinct</span><span class=\"pl-kos\"></span> <span class=\"pl-k\">class</span> <span class=\"pl-smi\">SomeClass</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">a</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span> <span class=\"pl-c1\">b</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span> <span class=\"pl-c1\">c</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-s1\">distinct</span><span class=\"pl-kos\"></span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">SomeId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span></pre></div>\n<p dir=\"auto\">would be translated by the compiler (for ES5 and lower targets) as:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"interface __SomeInterface  { x: number, y: number, z: number }\nconst enum __SomeInterfaceTag {}\ntype SomeInterface = __SomeInterface &amp; lang.Nominal&lt;__SomeInterfaceTag&gt;\n\nclass SomeClass implements lang.Nominal&lt;__SomeClassTag&gt;  {\n  'nominal structural brand': __SomeClassTag;\n  a: string; b: string; c: string;\n}\nconst enum __SomeClassTag {}\n\ntype SomeId = number &amp; lang.Nominal&lt;__SomeIdTag&gt;;\nconst enum __SomeIdTag {};\"><pre class=\"notranslate\"><span class=\"pl-k\">interface</span> <span class=\"pl-smi\">__SomeInterface</span>  <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">x</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">y</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">z</span>: <span class=\"pl-smi\">number</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-k\">enum</span> <span class=\"pl-s1\">__SomeInterfaceTag</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">SomeInterface</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">__SomeInterface</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-s1\">lang</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">__SomeInterfaceTag</span><span class=\"pl-kos\">&gt;</span>\n\n<span class=\"pl-k\">class</span> <span class=\"pl-smi\">SomeClass</span> <span class=\"pl-k\">implements</span> <span class=\"pl-s1\">lang</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">__SomeClassTag</span><span class=\"pl-kos\">&gt;</span>  <span class=\"pl-kos\">{</span>\n  <span class=\"pl-s\">'nominal structural brand'</span>: <span class=\"pl-smi\">__SomeClassTag</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-c1\">a</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span> <span class=\"pl-c1\">b</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span> <span class=\"pl-c1\">c</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-k\">enum</span> <span class=\"pl-s1\">__SomeClassTag</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">SomeId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-s1\">lang</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">__SomeIdTag</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-k\">enum</span> <span class=\"pl-s1\">__SomeIdTag</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">the <code class=\"notranslate\">__</code>-prefixed enums and interfaces being compiler-generated and inaccessible[1] to user code.</p>\n<h4 dir=\"auto\">Usage</h4>\n<p dir=\"auto\">Casts would be necessary for any usage of a <code class=\"notranslate\">distinct type</code> or <code class=\"notranslate\">distinct interface</code> (but they are necessary for other languages too - such as the <a href=\"https://github.com/milessabin/shapeless/blob/3a02b7cb3f645077ad16caecbd07a74ff01813cf/core/src/main/scala/shapeless/typeoperators.scala#L25-L34\">Scala shapeless library's <code class=\"notranslate\">Tagged</code> utility</a>).  At it's simplest[2]:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// Types and interfaces just need to be &quot;tagged&quot;\nvar interfaceTagging = {x: 1, y: 1, z: 1} as SomeInterface;\nvar typeTagging = 123 as SomeId;\n\n// Classes should be constructed specifically by the nominal constructor\nvar classCreation = new SomeClass('a', 'b', 'c');\n// A cast is also possible, but at that point all type-safety is out the window.\"><pre class=\"notranslate\"><span class=\"pl-c\">// Types and interfaces just need to be \"tagged\"</span>\n<span class=\"pl-k\">var</span> <span class=\"pl-s1\">interfaceTagging</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span><span class=\"pl-c1\">x</span>: <span class=\"pl-c1\">1</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">y</span>: <span class=\"pl-c1\">1</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">z</span>: <span class=\"pl-c1\">1</span><span class=\"pl-kos\">}</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">SomeInterface</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">var</span> <span class=\"pl-s1\">typeTagging</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">123</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">SomeId</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// Classes should be constructed specifically by the nominal constructor</span>\n<span class=\"pl-k\">var</span> <span class=\"pl-s1\">classCreation</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">SomeClass</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'a'</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'b'</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'c'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-c\">// A cast is also possible, but at that point all type-safety is out the window.</span></pre></div>\n<h4 dir=\"auto\">Notes</h4>\n<ol dir=\"auto\">\n<li>\n<p dir=\"auto\">The compiler-generated enum <em>is</em> available to consuming code if it accesses the <code class=\"notranslate\">'nominal structural brand'</code> field and uses a type query.  This could be mitigated by using a <code class=\"notranslate\">Symbol</code> for the key.</p>\n</li>\n<li>\n<p dir=\"auto\">A specific keyword could be added for a \"tagging\" cast:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"var x = new Point(1, 2, 3) taggedAs SomeInterface;\n// Errors if SomeInterface is not a lang.Nominal\"><pre class=\"notranslate\"><span class=\"pl-k\">var</span> <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Point</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">2</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">3</span><span class=\"pl-kos\">)</span> <span class=\"pl-s1\">taggedAs</span> <span class=\"pl-smi\">SomeInterface</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-c\">// Errors if SomeInterface is not a lang.Nominal</span></pre></div>\n<p dir=\"auto\">I would argue for it since it documents the <em>purpose</em> of the cast and prevents using non-nominative types in nominative (i. e. \"tagging\") casts.</p>\n</li>\n<li>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a> <a href=\"https://github.com/Microsoft/TypeScript/issues/10190#issuecomment-238116323\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/10190/hovercard\">points out an excellent ES2015+ approach that could be very useful as well</a> - instead of using the string-keyed 'nominal structural brand' use <code class=\"notranslate\">Symbol.species</code> for the brand key and the enum (or the type itself) for the type.</p>\n</li>\n</ol>",
        "createdAt": "2016-06-08T12:30:06Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-224574257",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDIyNTM3MDAzMQ==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@svieira :+1:, but I'd like to point out that classes are already nominally typed, so the `distinct` keyword redundant for those cases.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/svieira/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/svieira\">@svieira</a> 👍, but I'd like to point out that classes are already nominally typed, so the <code class=\"notranslate\">distinct</code> keyword redundant for those cases.</p>",
        "createdAt": "2016-06-11T15:29:47Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-225370031",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDIyNTM5MTgzNg==",
        "author": {
          "login": "svieira"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows - thanks!\n\nRegarding classes being nominally typed, I may be reading [section 8.1](https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#81-class-declarations) wrong but I am pretty sure that they are still structurally typed:\n\n> The following example introduces both a named type called 'Point' (the class type) and a named value called 'Point' (the constructor function) in the containing declaration space.\n> \n> ``` typescript\n> class Point {  \n>     constructor(public x: number, public y: number) { }  \n>     public length() { return Math.sqrt(this.x * this.x + this.y * this.y); }  \n>     static origin = new Point(0, 0);  \n> }\n> ```\n> \n> The named type 'Point' is exactly equivalent to\n> \n> ``` typescript\n> interface Point {  \n>     x: number;  \n>     y: number;  \n>     length(): number;  \n> }\n> ```\n> \n> The named value 'Point' is a constructor function whose type corresponds to the declaration\n> \n> ``` typescript\n> var Point: {  \n>     new(x: number, y: number): Point;  \n>     origin: Point;  \n> };\n> ```\n",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows - thanks!</p>\n<p dir=\"auto\">Regarding classes being nominally typed, I may be reading <a href=\"https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#81-class-declarations\">section 8.1</a> wrong but I am pretty sure that they are still structurally typed:</p>\n<blockquote>\n<p dir=\"auto\">The following example introduces both a named type called 'Point' (the class type) and a named value called 'Point' (the constructor function) in the containing declaration space.</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"class Point {  \n    constructor(public x: number, public y: number) { }  \n    public length() { return Math.sqrt(this.x * this.x + this.y * this.y); }  \n    static origin = new Point(0, 0);  \n}\"><pre class=\"notranslate\"><span class=\"pl-k\">class</span> <span class=\"pl-smi\">Point</span> <span class=\"pl-kos\">{</span>  \n    <span class=\"pl-en\">constructor</span><span class=\"pl-kos\">(</span><span class=\"pl-k\">public</span> <span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">,</span> <span class=\"pl-k\">public</span> <span class=\"pl-s1\">y</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">}</span>  \n    <span class=\"pl-k\">public</span> <span class=\"pl-en\">length</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">return</span> <span class=\"pl-smi\">Math</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">sqrt</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">this</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">x</span> <span class=\"pl-c1\">*</span> <span class=\"pl-smi\">this</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">x</span> <span class=\"pl-c1\">+</span> <span class=\"pl-smi\">this</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">y</span> <span class=\"pl-c1\">*</span> <span class=\"pl-smi\">this</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">y</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span>  \n    <span class=\"pl-k\">static</span> <span class=\"pl-c1\">origin</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Point</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">0</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">0</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>  \n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">The named type 'Point' is exactly equivalent to</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"interface Point {  \n    x: number;  \n    y: number;  \n    length(): number;  \n}\"><pre class=\"notranslate\"><span class=\"pl-k\">interface</span> <span class=\"pl-smi\">Point</span> <span class=\"pl-kos\">{</span>  \n    <span class=\"pl-c1\">x</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>  \n    <span class=\"pl-c1\">y</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>  \n    <span class=\"pl-c1\">length</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>  \n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">The named value 'Point' is a constructor function whose type corresponds to the declaration</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"var Point: {  \n    new(x: number, y: number): Point;  \n    origin: Point;  \n};\"><pre class=\"notranslate\"><span class=\"pl-k\">var</span> <span class=\"pl-smi\">Point</span>: <span class=\"pl-kos\">{</span>  \n    <span class=\"pl-k\">new</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">y</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">Point</span><span class=\"pl-kos\">;</span>  \n    <span class=\"pl-c1\">origin</span>: <span class=\"pl-smi\">Point</span><span class=\"pl-kos\">;</span>  \n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span></pre></div>\n</blockquote>",
        "createdAt": "2016-06-11T20:14:35Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-225391836",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDIyNjgwMzY4Mw==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@svieira Okay...that's news to me. I didn't know that. I went and checked in the playground, and you are correct. Still, :+1: from me.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/svieira/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/svieira\">@svieira</a> Okay...that's news to me. I didn't know that. I went and checked in the playground, and you are correct. Still, 👍 from me.</p>",
        "createdAt": "2016-06-17T15:39:30Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-226803683",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NDgyNjYzMA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "I just had an idea: if you modeled primitive types as nominal types extending interfaces (mod `typeof` narrowing, and assuming this isn't already the case), that could make this easier to do.\n\n``` ts\nnominal boolean extends Boolean {}\nnominal number extends Number {}\nnominal string extends String {}\nnominal symbol extends Symbol {}\n// `void` is basically the same as `undefined | null`\n// functions and objects use syntax instead.\n```\n\n_(Note that primitives will need compiler help, though.)_\n",
        "bodyHTML": "<p dir=\"auto\">I just had an idea: if you modeled primitive types as nominal types extending interfaces (mod <code class=\"notranslate\">typeof</code> narrowing, and assuming this isn't already the case), that could make this easier to do.</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"nominal boolean extends Boolean {}\nnominal number extends Number {}\nnominal string extends String {}\nnominal symbol extends Symbol {}\n// `void` is basically the same as `undefined | null`\n// functions and objects use syntax instead.\"><pre class=\"notranslate\"><span class=\"pl-s1\">nominal</span> <span class=\"pl-s1\">boolean</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Boolean</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-s1\">nominal</span> <span class=\"pl-s1\">number</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Number</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-s1\">nominal</span> <span class=\"pl-s1\">string</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">String</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-s1\">nominal</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Symbol</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-c\">// `void` is basically the same as `undefined | null`</span>\n<span class=\"pl-c\">// functions and objects use syntax instead.</span></pre></div>\n<p dir=\"auto\"><em>(Note that primitives will need compiler help, though.)</em></p>",
        "createdAt": "2016-09-06T00:53:53Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-244826630",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NTk3ODcwNQ==",
        "author": {
          "login": "shelby3"
        },
        "authorAssociation": "NONE",
        "body": "@danquirk [wrote](https://github.com/Microsoft/TypeScript/issues/202#issuecomment-69806809):\n\n> Your latest example seems emblematic of some of my concerns. I take it you just want an error on the last line. But then in the same small snippet of code you've taken advantage of structural typing (a number is an Age since Age has no members) while also doing a nominal comparison a few lines later (to get an error using Height where Age is expected).\n\nHe could just as well have expressed the type as `any`, `number`, or `string | number` as desired. He wasn't forced to use structural typing, but probably did so as convenience. What is the concern specifically? Would you prefer that structural coercions are not allowed to be assigned to nominal types thus he would have been forced to declare the type?\n\n> Essentially every type comparison operation would require you to do the additional work of deducing whether the comparison was a structural or a nominal one, rather than having an easily predictable set of behavior.\n\nWhen we compare any two instances of anything, we need to know their types to understand implications of implicit coercions (conversions) which don't even emit a compile-time error. How is it more difficult knowing whether only one of the types is nominal which will emit a compiler error if it is not?\n\n> For that scenario my preferred solution would be something like F#'s Units of Measure ( [#364](https://github.com/Microsoft/TypeScript/issues/364)).\n\nThat seems to me to be the \"kitchen sink\" syntax pollution school-of-design. Nominal types can accomplish that and are the more general, generative essence construct.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/danquirk/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/danquirk\">@danquirk</a> <a href=\"https://github.com/Microsoft/TypeScript/issues/202#issuecomment-69806809\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">wrote</a>:</p>\n<blockquote>\n<p dir=\"auto\">Your latest example seems emblematic of some of my concerns. I take it you just want an error on the last line. But then in the same small snippet of code you've taken advantage of structural typing (a number is an Age since Age has no members) while also doing a nominal comparison a few lines later (to get an error using Height where Age is expected).</p>\n</blockquote>\n<p dir=\"auto\">He could just as well have expressed the type as <code class=\"notranslate\">any</code>, <code class=\"notranslate\">number</code>, or <code class=\"notranslate\">string | number</code> as desired. He wasn't forced to use structural typing, but probably did so as convenience. What is the concern specifically? Would you prefer that structural coercions are not allowed to be assigned to nominal types thus he would have been forced to declare the type?</p>\n<blockquote>\n<p dir=\"auto\">Essentially every type comparison operation would require you to do the additional work of deducing whether the comparison was a structural or a nominal one, rather than having an easily predictable set of behavior.</p>\n</blockquote>\n<p dir=\"auto\">When we compare any two instances of anything, we need to know their types to understand implications of implicit coercions (conversions) which don't even emit a compile-time error. How is it more difficult knowing whether only one of the types is nominal which will emit a compiler error if it is not?</p>\n<blockquote>\n<p dir=\"auto\">For that scenario my preferred solution would be something like F#'s Units of Measure ( <a href=\"https://github.com/Microsoft/TypeScript/issues/364\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/364/hovercard\">#364</a>).</p>\n</blockquote>\n<p dir=\"auto\">That seems to me to be the \"kitchen sink\" syntax pollution school-of-design. Nominal types can accomplish that and are the more general, generative essence construct.</p>",
        "createdAt": "2016-09-09T17:17:00Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-245978705",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NTk5NzI4OQ==",
        "author": {
          "login": "shelby3"
        },
        "authorAssociation": "NONE",
        "body": "@plalx [wrote](https://github.com/Microsoft/TypeScript/issues/202#issuecomment-156719099):\n\n> In my opinion, the default behavior should have been that structural type checking is used only where contracts are defined in terms of `interface`s and nominal typing is used when contracts are defined in terms of concrete `class`es\n\nAgreed. See below...\n\n> Changing the implementation and have a private _value: ~~string as well as a get value(): string getter~~ would achieve a form of nominal typing naturally because different types with private member properties cannot be made equal, but supporting a nominal keyword which decorates ~~`interface`s &~~ `class`es would be much better.\n\nAgreed. See below...\n\nNote if we must decorate `class`, I would prefer `nominal class` instead of `named class`, because `class` can also be anonymous (nameless) so `named` is confusing. Also I would prefer a breaking change that is only turned on by flag where by default undecorated `class` is nominal and use `interface` for all structural typing.\n\n@sampsyo [wrote](https://github.com/Microsoft/TypeScript/issues/202#issuecomment-142141522):\n\n> I'm using a void field as a workaround. It works nicely and doesn't get in the way.\n\nIf we make the unused field private, it doesn't appear in the JS output and it doesn't get in the way of structural casts if there is a matching member property:\n\n``` ts\nclass Bar {\n    private _nominal:void\n}\n\nclass Baz {\n    value: number\n    private _nominal:void\n}\nlet x: Bar = <Bar>42,          // Error\n    y: Bar = <Bar>{},          // Ok\n    z: Baz = <Baz>{value: 42}  // Ok\ny = z                          // Error\n```\n\nSince classes can also be used as interfaces, then that is also the way to create a nominal \"interface\", so we can leave `interface` for structural (and since interface can't have `private` member properties).\n\nTangentially, I'd prefer the `abstract` keyword is removed. When you don't provide an implementation for a member property, then it is abstract. Why the need to decorate it? Verbosity is code smell. Is it to be sure I didn't intend to provide an implementation? As if I can't see that I didn't, lol.\n\nTo nominally subtype the built-in nominal types, which I think is more self-documenting and less likely to produce an accidental collision that [the recommendation currently in the FAQ](https://github.com/Microsoft/TypeScript-wiki/issues/89#issue-176188655):\n\n``` ts\nclass Nominal<T> {\n    private _nominal:T\n}\ntype Bar = number & Nominal<'Bar'> // employing string literal type\ntype Baz = number & Nominal<'Baz'>\nlet y: Bar = <Bar>42,         // Ok\n    z: Baz = <Baz>53          // Ok\ny = z                         // Error\n```\n\nSo that now that we see TypeScript already effectively has nominal typing, I suppose the need to justify it's implementation is vacated.\n\nEdit: [afaics `instanceof` is always nominal](https://github.com/Microsoft/TypeScript/issues/1007#issuecomment-246085962) and a `sealed` keyword [would be required](https://github.com/Microsoft/TypeScript/issues/186#issuecomment-246087546) for exhaustive checking with a class subtyping nominal sum type if SPOT and DNRY are to be respected. **Typeclasses would be an alternative to formalizing class nominal subtyping**.\n\nEdit#2: I wanted to change from `private _nominal:void` to `private _nominal = undefined` to make it explicit that no other class (not even a subclass given it's `private` not `protected`) is able to set the member property to any value, but this creates a property in the emitted output. In version 2.0, I anticipate this could be instead `private _nominal: undefined`, but I haven't tested it.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/plalx/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/plalx\">@plalx</a> <a href=\"https://github.com/Microsoft/TypeScript/issues/202#issuecomment-156719099\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">wrote</a>:</p>\n<blockquote>\n<p dir=\"auto\">In my opinion, the default behavior should have been that structural type checking is used only where contracts are defined in terms of <code class=\"notranslate\">interface</code>s and nominal typing is used when contracts are defined in terms of concrete <code class=\"notranslate\">class</code>es</p>\n</blockquote>\n<p dir=\"auto\">Agreed. See below...</p>\n<blockquote>\n<p dir=\"auto\">Changing the implementation and have a private _value: <del>string as well as a get value(): string getter</del> would achieve a form of nominal typing naturally because different types with private member properties cannot be made equal, but supporting a nominal keyword which decorates <del><code class=\"notranslate\">interface</code>s &amp;</del> <code class=\"notranslate\">class</code>es would be much better.</p>\n</blockquote>\n<p dir=\"auto\">Agreed. See below...</p>\n<p dir=\"auto\">Note if we must decorate <code class=\"notranslate\">class</code>, I would prefer <code class=\"notranslate\">nominal class</code> instead of <code class=\"notranslate\">named class</code>, because <code class=\"notranslate\">class</code> can also be anonymous (nameless) so <code class=\"notranslate\">named</code> is confusing. Also I would prefer a breaking change that is only turned on by flag where by default undecorated <code class=\"notranslate\">class</code> is nominal and use <code class=\"notranslate\">interface</code> for all structural typing.</p>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/sampsyo/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/sampsyo\">@sampsyo</a> <a href=\"https://github.com/Microsoft/TypeScript/issues/202#issuecomment-142141522\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">wrote</a>:</p>\n<blockquote>\n<p dir=\"auto\">I'm using a void field as a workaround. It works nicely and doesn't get in the way.</p>\n</blockquote>\n<p dir=\"auto\">If we make the unused field private, it doesn't appear in the JS output and it doesn't get in the way of structural casts if there is a matching member property:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"class Bar {\n    private _nominal:void\n}\n\nclass Baz {\n    value: number\n    private _nominal:void\n}\nlet x: Bar = &lt;Bar&gt;42,          // Error\n    y: Bar = &lt;Bar&gt;{},          // Ok\n    z: Baz = &lt;Baz&gt;{value: 42}  // Ok\ny = z                          // Error\"><pre class=\"notranslate\"><span class=\"pl-k\">class</span> <span class=\"pl-smi\">Bar</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">private</span> <span class=\"pl-c1\">_nominal</span>:<span class=\"pl-smi\"><span class=\"pl-k\">void</span></span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">class</span> <span class=\"pl-smi\">Baz</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">value</span>: <span class=\"pl-smi\">number</span>\n    <span class=\"pl-k\">private</span> <span class=\"pl-c1\">_nominal</span>:<span class=\"pl-smi\"><span class=\"pl-k\">void</span></span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">Bar</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Bar</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-c1\">42</span><span class=\"pl-kos\">,</span>          <span class=\"pl-c\">// Error</span>\n    <span class=\"pl-s1\">y</span>: <span class=\"pl-smi\">Bar</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Bar</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span>          <span class=\"pl-c\">// Ok</span>\n    <span class=\"pl-s1\">z</span>: <span class=\"pl-smi\">Baz</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Baz</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">{</span><span class=\"pl-c1\">value</span>: <span class=\"pl-c1\">42</span><span class=\"pl-kos\">}</span>  <span class=\"pl-c\">// Ok</span>\n<span class=\"pl-s1\">y</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">z</span>                          <span class=\"pl-c\">// Error</span></pre></div>\n<p dir=\"auto\">Since classes can also be used as interfaces, then that is also the way to create a nominal \"interface\", so we can leave <code class=\"notranslate\">interface</code> for structural (and since interface can't have <code class=\"notranslate\">private</code> member properties).</p>\n<p dir=\"auto\">Tangentially, I'd prefer the <code class=\"notranslate\">abstract</code> keyword is removed. When you don't provide an implementation for a member property, then it is abstract. Why the need to decorate it? Verbosity is code smell. Is it to be sure I didn't intend to provide an implementation? As if I can't see that I didn't, lol.</p>\n<p dir=\"auto\">To nominally subtype the built-in nominal types, which I think is more self-documenting and less likely to produce an accidental collision that <a href=\"https://github.com/Microsoft/TypeScript-wiki/issues/89#issue-176188655\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript-wiki/issues/89/hovercard\">the recommendation currently in the FAQ</a>:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"class Nominal&lt;T&gt; {\n    private _nominal:T\n}\ntype Bar = number &amp; Nominal&lt;'Bar'&gt; // employing string literal type\ntype Baz = number &amp; Nominal&lt;'Baz'&gt;\nlet y: Bar = &lt;Bar&gt;42,         // Ok\n    z: Baz = &lt;Baz&gt;53          // Ok\ny = z                         // Error\"><pre class=\"notranslate\"><span class=\"pl-k\">class</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">private</span> <span class=\"pl-c1\">_nominal</span>:<span class=\"pl-smi\">T</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Bar</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'Bar'</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-c\">// employing string literal type</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Baz</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'Baz'</span><span class=\"pl-kos\">&gt;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">y</span>: <span class=\"pl-smi\">Bar</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Bar</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-c1\">42</span><span class=\"pl-kos\">,</span>         <span class=\"pl-c\">// Ok</span>\n    <span class=\"pl-s1\">z</span>: <span class=\"pl-smi\">Baz</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Baz</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-c1\">53</span>          <span class=\"pl-c\">// Ok</span>\n<span class=\"pl-s1\">y</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">z</span>                         <span class=\"pl-c\">// Error</span></pre></div>\n<p dir=\"auto\">So that now that we see TypeScript already effectively has nominal typing, I suppose the need to justify it's implementation is vacated.</p>\n<p dir=\"auto\">Edit: <a href=\"https://github.com/Microsoft/TypeScript/issues/1007#issuecomment-246085962\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/1007/hovercard\">afaics <code class=\"notranslate\">instanceof</code> is always nominal</a> and a <code class=\"notranslate\">sealed</code> keyword <a href=\"https://github.com/Microsoft/TypeScript/issues/186#issuecomment-246087546\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/186/hovercard\">would be required</a> for exhaustive checking with a class subtyping nominal sum type if SPOT and DNRY are to be respected. <strong>Typeclasses would be an alternative to formalizing class nominal subtyping</strong>.</p>\n<p dir=\"auto\">Edit#2: I wanted to change from <code class=\"notranslate\">private _nominal:void</code> to <code class=\"notranslate\">private _nominal = undefined</code> to make it explicit that no other class (not even a subclass given it's <code class=\"notranslate\">private</code> not <code class=\"notranslate\">protected</code>) is able to set the member property to any value, but this creates a property in the emitted output. In version 2.0, I anticipate this could be instead <code class=\"notranslate\">private _nominal: undefined</code>, but I haven't tested it.</p>",
        "createdAt": "2016-09-09T18:23:35Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-245997289",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjE2MzcxOA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@shelby3 \n1. [Classes aren't nominal. Not in the slightest.](http://www.typescriptlang.org/play/index.html#src=class%20A%20%7B%0D%0A%09foo%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Aclass%20B%20%7B%0D%0A%09foo%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Adeclare%20function%20foo%28b%3A%20B%29%3A%20void%0D%0A%0D%0Aconst%20a%3A%20B%20%3D%20new%20A%28%29%0D%0Aconst%20b%3A%20A%20%3D%20new%20B%28%29%0D%0Aconst%20obj%3A%20any%20%3D%20new%20A%28%29%0D%0A%0D%0Aif%20%28obj%20instanceof%20A%29%20%7B%0D%0A%09foo%28a%29%0D%0A%7D)\n2. The nominal subtyping mechanism you mention isn't really nominal. It's still structural; it's just using a string literal type to namespace it. With TypeScript 2.0, I believe you may be able to create nominal types with private opaque enum values like this:\n   \n   ``` ts\n   const enum Marker {Value}\n   class Private { private _marker: Marker.Value }\n   export type MyType = number & Private\n   ```\n   \n   I'd recommend not trying to force nominal types into TypeScript in a way that requires frequent explicit casting in the meantime, though. If you focus on the data instead of the interface, you'd be surprised how far duck typing actually gets you.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/shelby3/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/shelby3\">@shelby3</a></p>\n<ol dir=\"auto\">\n<li>\n<p dir=\"auto\"><a href=\"http://www.typescriptlang.org/play/index.html#src=class%20A%20%7B%0D%0A%09foo%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Aclass%20B%20%7B%0D%0A%09foo%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Adeclare%20function%20foo%28b%3A%20B%29%3A%20void%0D%0A%0D%0Aconst%20a%3A%20B%20%3D%20new%20A%28%29%0D%0Aconst%20b%3A%20A%20%3D%20new%20B%28%29%0D%0Aconst%20obj%3A%20any%20%3D%20new%20A%28%29%0D%0A%0D%0Aif%20%28obj%20instanceof%20A%29%20%7B%0D%0A%09foo%28a%29%0D%0A%7D\" rel=\"nofollow\">Classes aren't nominal. Not in the slightest.</a></p>\n</li>\n<li>\n<p dir=\"auto\">The nominal subtyping mechanism you mention isn't really nominal. It's still structural; it's just using a string literal type to namespace it. With TypeScript 2.0, I believe you may be able to create nominal types with private opaque enum values like this:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const enum Marker {Value}\nclass Private { private _marker: Marker.Value }\nexport type MyType = number &amp; Private\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-k\">enum</span> <span class=\"pl-smi\">Marker</span> <span class=\"pl-kos\">{</span><span class=\"pl-c1\">Value</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">class</span> <span class=\"pl-smi\">Private</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">private</span> <span class=\"pl-c1\">_marker</span>: <span class=\"pl-smi\">Marker</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Value</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">MyType</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">Private</span></pre></div>\n<p dir=\"auto\">I'd recommend not trying to force nominal types into TypeScript in a way that requires frequent explicit casting in the meantime, though. If you focus on the data instead of the interface, you'd be surprised how far duck typing actually gets you.</p>\n</li>\n</ol>",
        "createdAt": "2016-09-11T05:56:35Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246163718",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjE3NjAyMg==",
        "author": {
          "login": "shelby3"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows wrote:\n\n> 1​. [Classes aren't nominal. Not in the slightest.](http://www.typescriptlang.org/play/index.html#src=class%20A%20%7B%0D%0A%09foo%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Aclass%20B%20%7B%0D%0A%09foo%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Adeclare%20function%20foo%28b%3A%20B%29%3A%20void%0D%0A%0D%0Aconst%20a%3A%20B%20%3D%20new%20A%28%29%0D%0Aconst%20b%3A%20A%20%3D%20new%20B%28%29%0D%0Aconst%20obj%3A%20any%20%3D%20new%20A%28%29%0D%0A%0D%0Aif%20%28obj%20instanceof%20A%29%20%7B%0D%0A%09foo%28a%29%0D%0A%7D)\n\nI never wrote that classes are nominal or providing any effectively nominal typing simulation by default. I hope you were not implying that I made such an incorrect assertion.\n\n> 2​. The nominal subtyping mechanism you mention isn't really nominal. It's still structural\n\nI didn't write that the nominal typing simulation isn't achieved with the structural type checker. The ability to enforce that every `private` or `protected` property is unique between nominal classes, is in effect a nominally associated typing feature. Also apparently `instanceof` remains nominal for instantiated classes.\n\n> I'd recommend not trying to force nominal types into TypeScript in a way that requires frequent explicit casting in the meantime, though. If you focus on the data instead of the interface, you'd be surprised how far duck typing actually gets you.\n\nI intend to convince[1] that subclassing is a non-extensible anti-pattern and typeclasses is the superior paradigm for nominal typing.\n\n[1] See the [THE COVARIANCE OF GENERICS](https://groups.google.com/forum/embed/#!msg/strengthen-js/611mdeOu2qw/wDDfqQUtAgAJ) section and the link back to a [TypeScript issue](https://github.com/Microsoft/TypeScript/issues/10844).\n",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows wrote:</p>\n<blockquote>\n<p dir=\"auto\">1​. <a href=\"http://www.typescriptlang.org/play/index.html#src=class%20A%20%7B%0D%0A%09foo%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Aclass%20B%20%7B%0D%0A%09foo%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Adeclare%20function%20foo%28b%3A%20B%29%3A%20void%0D%0A%0D%0Aconst%20a%3A%20B%20%3D%20new%20A%28%29%0D%0Aconst%20b%3A%20A%20%3D%20new%20B%28%29%0D%0Aconst%20obj%3A%20any%20%3D%20new%20A%28%29%0D%0A%0D%0Aif%20%28obj%20instanceof%20A%29%20%7B%0D%0A%09foo%28a%29%0D%0A%7D\" rel=\"nofollow\">Classes aren't nominal. Not in the slightest.</a></p>\n</blockquote>\n<p dir=\"auto\">I never wrote that classes are nominal or providing any effectively nominal typing simulation by default. I hope you were not implying that I made such an incorrect assertion.</p>\n<blockquote>\n<p dir=\"auto\">2​. The nominal subtyping mechanism you mention isn't really nominal. It's still structural</p>\n</blockquote>\n<p dir=\"auto\">I didn't write that the nominal typing simulation isn't achieved with the structural type checker. The ability to enforce that every <code class=\"notranslate\">private</code> or <code class=\"notranslate\">protected</code> property is unique between nominal classes, is in effect a nominally associated typing feature. Also apparently <code class=\"notranslate\">instanceof</code> remains nominal for instantiated classes.</p>\n<blockquote>\n<p dir=\"auto\">I'd recommend not trying to force nominal types into TypeScript in a way that requires frequent explicit casting in the meantime, though. If you focus on the data instead of the interface, you'd be surprised how far duck typing actually gets you.</p>\n</blockquote>\n<p dir=\"auto\">I intend to convince[1] that subclassing is a non-extensible anti-pattern and typeclasses is the superior paradigm for nominal typing.</p>\n<p dir=\"auto\">[1] See the <a href=\"https://groups.google.com/forum/embed/#!msg/strengthen-js/611mdeOu2qw/wDDfqQUtAgAJ\" rel=\"nofollow\">THE COVARIANCE OF GENERICS</a> section and the link back to a <a href=\"https://github.com/Microsoft/TypeScript/issues/10844\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/10844/hovercard\">TypeScript issue</a>.</p>",
        "createdAt": "2016-09-11T11:43:40Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246176022",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjI3NTUxMQ==",
        "author": {
          "login": "shelby3"
        },
        "authorAssociation": "NONE",
        "body": "There is [some evidence](https://github.com/Microsoft/TypeScript/issues/1007#issuecomment-246267371) that TypeScript is conflating it design patterns around the separation-of-concepts for structural and nominal typing.\n\nI hope we can get more organized.\n",
        "bodyHTML": "<p dir=\"auto\">There is <a href=\"https://github.com/Microsoft/TypeScript/issues/1007#issuecomment-246267371\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/1007/hovercard\">some evidence</a> that TypeScript is conflating it design patterns around the separation-of-concepts for structural and nominal typing.</p>\n<p dir=\"auto\">I hope we can get more organized.</p>",
        "createdAt": "2016-09-12T08:00:54Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246275511",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjM5MTk1NA==",
        "author": {
          "login": "shelby3"
        },
        "authorAssociation": "NONE",
        "body": "Why is it nearly everyone wants [to deny that the `prototype` chain is a feature of JavaScript that enables nominal typing](https://github.com/Microsoft/TypeScript/issues/1007#issuecomment-246329125) (i.e. deny that JavaScript has nominal typing)?\n\nAnd that [nominal typing is not only subclassing](https://github.com/Microsoft/TypeScript/issues/1007#issuecomment-246374896)?\n",
        "bodyHTML": "<p dir=\"auto\">Why is it nearly everyone wants <a href=\"https://github.com/Microsoft/TypeScript/issues/1007#issuecomment-246329125\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/1007/hovercard\">to deny that the <code class=\"notranslate\">prototype</code> chain is a feature of JavaScript that enables nominal typing</a> (i.e. deny that JavaScript has nominal typing)?</p>\n<p dir=\"auto\">And that <a href=\"https://github.com/Microsoft/TypeScript/issues/1007#issuecomment-246374896\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/1007/hovercard\">nominal typing is not only subclassing</a>?</p>",
        "createdAt": "2016-09-12T15:46:56Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246391954",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjQwMDMyMQ==",
        "author": {
          "login": "MartinJohns"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@shelby3 Can you please elaborate how `prototype` would be a suitable candidate to solve nominal typing?\n\nThe example I have in mind is that my API returns the following _JSON_:\n\n```\n{\n    \"id\": \"ProductId\",\n    \"name\": \"name\"\n}\n```\n\nWhich then is deserialized to the following data structure:\n\n```\ninterface Product {\n    id: ProductId,\n    name: string\n}\n```\n\nThe `ProductId` should be nominal typed. It's a `string` behind the scenes, but you can't just assign random strings to it. Same as you could not assign a `UserId` to it, even when that nominal type is also a `string`.\n\nSince the data structure is deserialized I don't see how the `prototype` chain would work.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/shelby3/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/shelby3\">@shelby3</a> Can you please elaborate how <code class=\"notranslate\">prototype</code> would be a suitable candidate to solve nominal typing?</p>\n<p dir=\"auto\">The example I have in mind is that my API returns the following <em>JSON</em>:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"{\n    &quot;id&quot;: &quot;ProductId&quot;,\n    &quot;name&quot;: &quot;name&quot;\n}\"><pre class=\"notranslate\"><code class=\"notranslate\">{\n    \"id\": \"ProductId\",\n    \"name\": \"name\"\n}\n</code></pre></div>\n<p dir=\"auto\">Which then is deserialized to the following data structure:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"interface Product {\n    id: ProductId,\n    name: string\n}\"><pre class=\"notranslate\"><code class=\"notranslate\">interface Product {\n    id: ProductId,\n    name: string\n}\n</code></pre></div>\n<p dir=\"auto\">The <code class=\"notranslate\">ProductId</code> should be nominal typed. It's a <code class=\"notranslate\">string</code> behind the scenes, but you can't just assign random strings to it. Same as you could not assign a <code class=\"notranslate\">UserId</code> to it, even when that nominal type is also a <code class=\"notranslate\">string</code>.</p>\n<p dir=\"auto\">Since the data structure is deserialized I don't see how the <code class=\"notranslate\">prototype</code> chain would work.</p>",
        "createdAt": "2016-09-12T16:13:24Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246400321",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjQ1NzE0OA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@shelby3 \n\n> There is some evidence that TypeScript is conflating it design patterns around the separation-of-concepts for structural and nominal typing.\n> \n> I hope we can get more organized.\n> \n> ---\n> \n> Why is it nearly everyone wants to deny that the  prototype  chain is a feature of JavaScript that enables nominal typing (i.e. deny that JavaScript has nominal typing)?\n> \n> And that nominal typing is not only subclassing?\n1. Please keep this civil. Accusing people of some supposed wrongdoing or speaking down to a group of people, isn't going to get you anywhere, even if you're right. This includes the above two comments, as well as [both](https://github.com/Microsoft/TypeScript/issues/1007#issuecomment-246267371) [of](https://github.com/Microsoft/TypeScript/issues/1007#issuecomment-246329125) the links to your comments from these two above ones.\n2. @spion in [his comment](https://github.com/Microsoft/TypeScript/issues/1007#issuecomment-246374896) did not in fact claim, much less imply, that nominal typing is not just subclassing. He was stating benefits of having nominally different structural types that still matched, using Thenables in the promise world as an example. This has nothing to do with subclassing, and is merely the fundamental difference between structural and nominal types.\n3. Yes, the prototype chain can be used for nominal typing. But is that useful in practice? It depends on the programmer. If you focus on the interface, then yes, nominal typing is a must. If you focus on the data, then nominal typing can actually get in the way at times. Call me crazy, but I'd rather have one way to define a simple point, not [three](http://docs.oracle.com/javase/8/docs/api/java/awt/geom/Point2D.Float.html) [different](http://docs.oracle.com/javase/8/docs/api/java/awt/geom/Point2D.Double.html) [classes](http://docs.oracle.com/javase/8/docs/api/java/awt/Point.html) to define the same thing in different precisions (`float`, `double`, and `int`), extending a superclass which only matches the precision of one of them. Structural typing lets me instead return `{x: 1, y: 2}`, while descriptively naming the instance `interface Point { x: number; y: number }`. I tend to focus on the data, not the interface, so structural typing works fairly well. YMMV, though.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/shelby3/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/shelby3\">@shelby3</a></p>\n<blockquote>\n<p dir=\"auto\">There is some evidence that TypeScript is conflating it design patterns around the separation-of-concepts for structural and nominal typing.</p>\n<p dir=\"auto\">I hope we can get more organized.</p>\n<hr>\n<p dir=\"auto\">Why is it nearly everyone wants to deny that the  prototype  chain is a feature of JavaScript that enables nominal typing (i.e. deny that JavaScript has nominal typing)?</p>\n<p dir=\"auto\">And that nominal typing is not only subclassing?</p>\n</blockquote>\n<ol dir=\"auto\">\n<li>Please keep this civil. Accusing people of some supposed wrongdoing or speaking down to a group of people, isn't going to get you anywhere, even if you're right. This includes the above two comments, as well as <a href=\"https://github.com/Microsoft/TypeScript/issues/1007#issuecomment-246267371\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/1007/hovercard\">both</a> <a href=\"https://github.com/Microsoft/TypeScript/issues/1007#issuecomment-246329125\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/1007/hovercard\">of</a> the links to your comments from these two above ones.</li>\n<li><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/spion/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/spion\">@spion</a> in <a href=\"https://github.com/Microsoft/TypeScript/issues/1007#issuecomment-246374896\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/1007/hovercard\">his comment</a> did not in fact claim, much less imply, that nominal typing is not just subclassing. He was stating benefits of having nominally different structural types that still matched, using Thenables in the promise world as an example. This has nothing to do with subclassing, and is merely the fundamental difference between structural and nominal types.</li>\n<li>Yes, the prototype chain can be used for nominal typing. But is that useful in practice? It depends on the programmer. If you focus on the interface, then yes, nominal typing is a must. If you focus on the data, then nominal typing can actually get in the way at times. Call me crazy, but I'd rather have one way to define a simple point, not <a href=\"http://docs.oracle.com/javase/8/docs/api/java/awt/geom/Point2D.Float.html\" rel=\"nofollow\">three</a> <a href=\"http://docs.oracle.com/javase/8/docs/api/java/awt/geom/Point2D.Double.html\" rel=\"nofollow\">different</a> <a href=\"http://docs.oracle.com/javase/8/docs/api/java/awt/Point.html\" rel=\"nofollow\">classes</a> to define the same thing in different precisions (<code class=\"notranslate\">float</code>, <code class=\"notranslate\">double</code>, and <code class=\"notranslate\">int</code>), extending a superclass which only matches the precision of one of them. Structural typing lets me instead return <code class=\"notranslate\">{x: 1, y: 2}</code>, while descriptively naming the instance <code class=\"notranslate\">interface Point { x: number; y: number }</code>. I tend to focus on the data, not the interface, so structural typing works fairly well. YMMV, though.</li>\n</ol>",
        "createdAt": "2016-09-12T19:08:23Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246457148",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjQ2MDY0MQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "Classes are [much more nominal than anything else](http://www.typescriptlang.org/play/index.html#src=declare%20class%20A%20%7B%0D%0A%09private%20shit%3A%20any%3B%0D%0A%09foo%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Adeclare%20class%20B%20%7B%0D%0A%09private%20shit%3A%20any%3B%0D%0A%09foo%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Adeclare%20function%20foo%28b%3A%20B%29%3A%20void%0D%0A%0D%0Aconst%20a%3A%20B%20%3D%20new%20A%28%29%0D%0Aconst%20b%3A%20A%20%3D%20new%20B%28%29%0D%0Aconst%20obj%3A%20any%20%3D%20new%20A%28%29%0D%0A%0D%0Aif%20%28obj%20instanceof%20A%29%20%7B%0D%0A%09foo%28a%29%0D%0A%7D) in TS.\n",
        "bodyHTML": "<p dir=\"auto\">Classes are <a href=\"http://www.typescriptlang.org/play/index.html#src=declare%20class%20A%20%7B%0D%0A%09private%20shit%3A%20any%3B%0D%0A%09foo%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Adeclare%20class%20B%20%7B%0D%0A%09private%20shit%3A%20any%3B%0D%0A%09foo%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Adeclare%20function%20foo%28b%3A%20B%29%3A%20void%0D%0A%0D%0Aconst%20a%3A%20B%20%3D%20new%20A%28%29%0D%0Aconst%20b%3A%20A%20%3D%20new%20B%28%29%0D%0Aconst%20obj%3A%20any%20%3D%20new%20A%28%29%0D%0A%0D%0Aif%20%28obj%20instanceof%20A%29%20%7B%0D%0A%09foo%28a%29%0D%0A%7D\" rel=\"nofollow\">much more nominal than anything else</a> in TS.</p>",
        "createdAt": "2016-09-12T19:20:15Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246460641",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjQ2NDgzMA==",
        "author": {
          "login": "shelby3"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows wrote:\n\n> Accusing people of some supposed wrongdoing or speaking down to a group of people\n\nWhat group of people did I doxx? Please be specific and show proof.\n\nThe way I see it, I referred to a common mindset in the JS community-at-large, including myself in the recent past. Douglas Crockford even points out that we don't give prototype chain inheritance enough attention.\n\nAll the worrying about little nuances of intent is getting tiresome. It isn't a big problem. Our egos are not that fragile.\n\n> @spion in his comment did not in fact claim, much less imply, that nominal typing is not just subclassing.\n\n[Incorrect](https://github.com/Microsoft/TypeScript/issues/1007#issuecomment-246390672). Typeclasses can use nominal typing and they don't have the problem he was asserting is a problem with nominal typing. The problem he was referring to is caused by subclassing. Apparently you didn't understand this. So now you do.\n\n> Yes, the prototype chain can be used for nominal typing. But is that useful in practice?\n\nYou will know soon.\n",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows wrote:</p>\n<blockquote>\n<p dir=\"auto\">Accusing people of some supposed wrongdoing or speaking down to a group of people</p>\n</blockquote>\n<p dir=\"auto\">What group of people did I doxx? Please be specific and show proof.</p>\n<p dir=\"auto\">The way I see it, I referred to a common mindset in the JS community-at-large, including myself in the recent past. Douglas Crockford even points out that we don't give prototype chain inheritance enough attention.</p>\n<p dir=\"auto\">All the worrying about little nuances of intent is getting tiresome. It isn't a big problem. Our egos are not that fragile.</p>\n<blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/spion/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/spion\">@spion</a> in his comment did not in fact claim, much less imply, that nominal typing is not just subclassing.</p>\n</blockquote>\n<p dir=\"auto\"><a href=\"https://github.com/Microsoft/TypeScript/issues/1007#issuecomment-246390672\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/1007/hovercard\">Incorrect</a>. Typeclasses can use nominal typing and they don't have the problem he was asserting is a problem with nominal typing. The problem he was referring to is caused by subclassing. Apparently you didn't understand this. So now you do.</p>\n<blockquote>\n<p dir=\"auto\">Yes, the prototype chain can be used for nominal typing. But is that useful in practice?</p>\n</blockquote>\n<p dir=\"auto\">You will know soon.</p>",
        "createdAt": "2016-09-12T19:34:39Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246464830",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjQ2NTYyMw==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@shelby3 Both of these rhetorical questions come across as somewhat personal:\n\n> Why is it nearly everyone wants to deny that the prototype chain is a feature of JavaScript that enables nominal typing (i.e. deny that JavaScript has nominal typing)?\n> \n> And that nominal typing is not only subclassing?\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/shelby3/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/shelby3\">@shelby3</a> Both of these rhetorical questions come across as somewhat personal:</p>\n<blockquote>\n<p dir=\"auto\">Why is it nearly everyone wants to deny that the prototype chain is a feature of JavaScript that enables nominal typing (i.e. deny that JavaScript has nominal typing)?</p>\n<p dir=\"auto\">And that nominal typing is not only subclassing?</p>\n</blockquote>",
        "createdAt": "2016-09-12T19:37:18Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246465623",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjQ2Njc3Nw==",
        "author": {
          "login": "shelby3"
        },
        "authorAssociation": "NONE",
        "body": "> Both of these rhetorical questions come across as somewhat personal:\n\nI repeat:\n\n> All the worrying about little nuances of intent is getting tiresome. Our egos are not that fragile.\n\nI will not reply further on that topic. Thanks. (No disrespect intended, just as I say it is tiresome)\n",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">Both of these rhetorical questions come across as somewhat personal:</p>\n</blockquote>\n<p dir=\"auto\">I repeat:</p>\n<blockquote>\n<p dir=\"auto\">All the worrying about little nuances of intent is getting tiresome. Our egos are not that fragile.</p>\n</blockquote>\n<p dir=\"auto\">I will not reply further on that topic. Thanks. (No disrespect intended, just as I say it is tiresome)</p>",
        "createdAt": "2016-09-12T19:41:11Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246466777",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjQ3ODMzNg==",
        "author": {
          "login": "mhegazy"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@shelby3, over the past few days you have had multiple posts on this forum that are antagonizing and disrespectful to other participants. This is not a comment to this specific issue, but rather a general one. This is a technical forum for discussing the TypeScript design and bugs, and not a political or social discussion group; and we do expect all participants to interact in a civil, respectful and productive manner.\n\nThis is not a request to explain your comments, or tone; this is rather a statement of how many others perceive them. If you are interested in participating in this forum, and have vested interest in future of the TypeScript community and JavaScript tooling in general, I would suggest you keep the discussion in technical terms, and keep the tone professional.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/shelby3/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/shelby3\">@shelby3</a>, over the past few days you have had multiple posts on this forum that are antagonizing and disrespectful to other participants. This is not a comment to this specific issue, but rather a general one. This is a technical forum for discussing the TypeScript design and bugs, and not a political or social discussion group; and we do expect all participants to interact in a civil, respectful and productive manner.</p>\n<p dir=\"auto\">This is not a request to explain your comments, or tone; this is rather a statement of how many others perceive them. If you are interested in participating in this forum, and have vested interest in future of the TypeScript community and JavaScript tooling in general, I would suggest you keep the discussion in technical terms, and keep the tone professional.</p>",
        "createdAt": "2016-09-12T20:19:51Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246478336",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjQ5MTc3Nw==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "I'm opposed to solutions that create a construction that works purely compile-time. Typescript should attempt to type existing javascript as precisely and concisely as possible. The problem with nominal types is that they are not nominal at run-time, unless they are tagged objects. Typescript can already type tagged objects, though obviously, we are waiting for symbol support in computed properties to really leverage this feature.\n\nCan anyone explain to me something that nominal types can do, that tagged objects don't do?\n",
        "bodyHTML": "<p dir=\"auto\">I'm opposed to solutions that create a construction that works purely compile-time. Typescript should attempt to type existing javascript as precisely and concisely as possible. The problem with nominal types is that they are not nominal at run-time, unless they are tagged objects. Typescript can already type tagged objects, though obviously, we are waiting for symbol support in computed properties to really leverage this feature.</p>\n<p dir=\"auto\">Can anyone explain to me something that nominal types can do, that tagged objects don't do?</p>",
        "createdAt": "2016-09-12T21:00:42Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246491777",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjUwMTA3Mw==",
        "author": {
          "login": "antanas-arvasevicius"
        },
        "authorAssociation": "NONE",
        "body": "Looks like two worlds colliding here.. but in the reality there is no such thing as \"nominal\" in javascript, but it would be nice to have a compile time check for type mismatch in nominal way. Best example which would work for is if we had a lot of services with methods like  update(id:SomethingId),  update(id:OrderId), update(id:UserId) an such, and how to model API in a way that developers won't mix up these ids which all are \"string\", but meaning is different, and they should be able to pass any \"string\" in these methods if they explicitly cast it to appropriate type. Is that hard to implement in TS?\n",
        "bodyHTML": "<p dir=\"auto\">Looks like two worlds colliding here.. but in the reality there is no such thing as \"nominal\" in javascript, but it would be nice to have a compile time check for type mismatch in nominal way. Best example which would work for is if we had a lot of services with methods like  update(id:SomethingId),  update(id:OrderId), update(id:UserId) an such, and how to model API in a way that developers won't mix up these ids which all are \"string\", but meaning is different, and they should be able to pass any \"string\" in these methods if they explicitly cast it to appropriate type. Is that hard to implement in TS?</p>",
        "createdAt": "2016-09-12T21:32:35Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246501073",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjUwMTcyMQ==",
        "author": {
          "login": "RyanCavanaugh"
        },
        "authorAssociation": "MEMBER",
        "body": "@antanas-arvasevicius this is already quite possible\n\n``` ts\n// Use whatever magic string you like\ntype UserId = string & { \"is user id\": void }\n```\n\nat this point you can use any string as a `UserId` with a type assertion and everything basically works the way you'd expect. _Technically_ this is still structural, though if everyone comes up with a unique magic string (not hard) it is effectively nominal.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/antanas-arvasevicius/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/antanas-arvasevicius\">@antanas-arvasevicius</a> this is already quite possible</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// Use whatever magic string you like\ntype UserId = string &amp; { &quot;is user id&quot;: void }\"><pre class=\"notranslate\"><span class=\"pl-c\">// Use whatever magic string you like</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">UserId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">string</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-s\">\"is user id\"</span>: <span class=\"pl-smi\"><span class=\"pl-k\">void</span></span> <span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">at this point you can use any string as a <code class=\"notranslate\">UserId</code> with a type assertion and everything basically works the way you'd expect. <em>Technically</em> this is still structural, though if everyone comes up with a unique magic string (not hard) it is effectively nominal.</p>",
        "createdAt": "2016-09-12T21:34:50Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246501721",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjUwNzMwNw==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@antanas-arvasevicius, as @RyanCavanaugh points out, Javascript has always had nominal types. Tagged objects are nominal if the tag is unique. By using a UUID as a property name, you ensure nominality. Even better is using the new ES2015 symbols, though Typescript can't properly type those yet (symbols in computed properties).\n\nIn fact, Javascript, as a prototypal language, provides a superset of classic OO, it is strictly MORE powerful. There isn't a single Java feature that Javascript can't do. The issue is: can Typescript express and typecheck the feature, which in case of nominal types, it can for UUIDs, but not for Symbols (yet).\n\n``` typescript\ninterface Tagged {\n    \"d3a8e9b5-07c2-4a2d-a245-8a5908826b0f\": void;\n}\n```\n\nA handy semantic way is to use Symbol.species:\n\n``` typescript\ninterface TaggedSpecies {\n    [Symbol.species]: \"d3a8e9b5-07c2-4a2d-a245-8a5908826b0f\"\n}\n```\n\nI haven't figured out a proper way to tag an object with multiple IDs yet when using the Symbol.species way, but I assume there's an elegant way to express it. Meanwhile, I suggest you just use the first sample I provided, which lets you tag as many IDs in an object as you want. Do note that for a robust code-base, you want to make sure that these tags are not enumerable, if you are actually adding them onto the object for runtime typechecking.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/antanas-arvasevicius/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/antanas-arvasevicius\">@antanas-arvasevicius</a>, as <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/RyanCavanaugh/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/RyanCavanaugh\">@RyanCavanaugh</a> points out, Javascript has always had nominal types. Tagged objects are nominal if the tag is unique. By using a UUID as a property name, you ensure nominality. Even better is using the new ES2015 symbols, though Typescript can't properly type those yet (symbols in computed properties).</p>\n<p dir=\"auto\">In fact, Javascript, as a prototypal language, provides a superset of classic OO, it is strictly MORE powerful. There isn't a single Java feature that Javascript can't do. The issue is: can Typescript express and typecheck the feature, which in case of nominal types, it can for UUIDs, but not for Symbols (yet).</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"interface Tagged {\n    &quot;d3a8e9b5-07c2-4a2d-a245-8a5908826b0f&quot;: void;\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">interface</span> <span class=\"pl-smi\">Tagged</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-s\">\"d3a8e9b5-07c2-4a2d-a245-8a5908826b0f\"</span>: <span class=\"pl-smi\"><span class=\"pl-k\">void</span></span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">A handy semantic way is to use Symbol.species:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"interface TaggedSpecies {\n    [Symbol.species]: &quot;d3a8e9b5-07c2-4a2d-a245-8a5908826b0f&quot;\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">interface</span> <span class=\"pl-smi\">TaggedSpecies</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-kos\">[</span><span class=\"pl-smi\">Symbol</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">species</span><span class=\"pl-kos\">]</span>: <span class=\"pl-s\">\"d3a8e9b5-07c2-4a2d-a245-8a5908826b0f\"</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">I haven't figured out a proper way to tag an object with multiple IDs yet when using the Symbol.species way, but I assume there's an elegant way to express it. Meanwhile, I suggest you just use the first sample I provided, which lets you tag as many IDs in an object as you want. Do note that for a robust code-base, you want to make sure that these tags are not enumerable, if you are actually adding them onto the object for runtime typechecking.</p>",
        "createdAt": "2016-09-12T21:55:13Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246507307",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjUwNzQwNw==",
        "author": {
          "login": "antanas-arvasevicius"
        },
        "authorAssociation": "NONE",
        "body": "But that way it looks like some language hack and is strange to read ;) would be nice to have such supportiness in a language itself instead of making constructs like these every time. I don't know maybe that behavior is significant to minorities and will be rarely used then whatever.\n",
        "bodyHTML": "<p dir=\"auto\">But that way it looks like some language hack and is strange to read ;) would be nice to have such supportiness in a language itself instead of making constructs like these every time. I don't know maybe that behavior is significant to minorities and will be rarely used then whatever.</p>",
        "createdAt": "2016-09-12T21:55:34Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246507407",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjUwNzk3MA==",
        "author": {
          "login": "RyanCavanaugh"
        },
        "authorAssociation": "MEMBER",
        "body": "You can fancy it up a little with string literal types\n\n``` ts\n// Once\ntype Branded<T, U> = T & { '__ kind': U };\n\n// Elsewhere\ntype OrderID = Branded<string, 'Order ID'>;\n```\n",
        "bodyHTML": "<p dir=\"auto\">You can fancy it up a little with string literal types</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// Once\ntype Branded&lt;T, U&gt; = T &amp; { '__ kind': U };\n\n// Elsewhere\ntype OrderID = Branded&lt;string, 'Order ID'&gt;;\"><pre class=\"notranslate\"><span class=\"pl-c\">// Once</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Branded</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">U</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-s\">'__ kind'</span>: <span class=\"pl-smi\">U</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// Elsewhere</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">OrderID</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Branded</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'Order ID'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span></pre></div>",
        "createdAt": "2016-09-12T21:57:43Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246507970",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjUwODA1Ng==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@antanas-arvasevicius It's not a hack, and it's widely used today. It may look strange, but what something like Java does, is add that same tag behind the scenes. I agree it might not look super elegant, but [I tried suggesting](https://github.com/Microsoft/TypeScript/issues/10190) a more elegant syntax and unfortunately, something like that is not within the current scope of Typescript.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/antanas-arvasevicius/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/antanas-arvasevicius\">@antanas-arvasevicius</a> It's not a hack, and it's widely used today. It may look strange, but what something like Java does, is add that same tag behind the scenes. I agree it might not look super elegant, but <a href=\"https://github.com/Microsoft/TypeScript/issues/10190\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/10190/hovercard\">I tried suggesting</a> a more elegant syntax and unfortunately, something like that is not within the current scope of Typescript.</p>",
        "createdAt": "2016-09-12T21:58:03Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246508056",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjUwODQwMw==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@RyanCavanaugh You should probably use Symbol.species instead of __kind, which is spec compliant and more semantic:\n\n``` typescript\n// Once\ntype Branded<T, U> = T & { [Symbol.species]: U };\n\n// Elsewhere\ntype OrderID = Branded<string, 'Order ID'>;\n```\n\nAnd remove the magic string maybe:\n\n``` typescript\ntype OrderUUID = \"d3a8e9b5-07c2-4a2d-a245-8a5908826b0f\";\n\n// Once\ntype Branded<T, U> = T & { [Symbol.species]: U };\n\n// Elsewhere\ntype OrderID = Branded<string, OrderUUID>;\n```\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/RyanCavanaugh/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/RyanCavanaugh\">@RyanCavanaugh</a> You should probably use Symbol.species instead of __kind, which is spec compliant and more semantic:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// Once\ntype Branded&lt;T, U&gt; = T &amp; { [Symbol.species]: U };\n\n// Elsewhere\ntype OrderID = Branded&lt;string, 'Order ID'&gt;;\"><pre class=\"notranslate\"><span class=\"pl-c\">// Once</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Branded</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">U</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">[</span><span class=\"pl-smi\">Symbol</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">species</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">U</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// Elsewhere</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">OrderID</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Branded</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'Order ID'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">And remove the magic string maybe:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type OrderUUID = &quot;d3a8e9b5-07c2-4a2d-a245-8a5908826b0f&quot;;\n\n// Once\ntype Branded&lt;T, U&gt; = T &amp; { [Symbol.species]: U };\n\n// Elsewhere\ntype OrderID = Branded&lt;string, OrderUUID&gt;;\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">OrderUUID</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">\"d3a8e9b5-07c2-4a2d-a245-8a5908826b0f\"</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// Once</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Branded</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">U</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">[</span><span class=\"pl-smi\">Symbol</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">species</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">U</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// Elsewhere</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">OrderID</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Branded</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">OrderUUID</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span></pre></div>",
        "createdAt": "2016-09-12T21:59:22Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246508403",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjUwOTk5OQ==",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "@shelby3 I was not referring to subclassing. That was only the mechanism via which I illustrated the problem with nominal types. \n\nTypeclasses only solve the initial step where you have to convince the owner to implement your nominal interface; you no longer need to do that - you can write your own instance. However, you still have to convince the first author as well as existing library writers to adopt your typeclass i.e. write their code as follows:\n\n``` typescript\nfunction f(x:TheNominalInterface) { ... }\n```\n\nrather then write their functions against the original nominal type written by the first author:\n\n``` typescript\nfunction f(x: TheNominalOriginalPromise) { ... }\n```\n\nIn short, I believe that nominal types are _not_ what you want by default, and it was brilliant of TypeScript to bring structural types to the mainstream. I also quite like the idea (its fresh, really) of a type system that doesn't put absolute type safety and soundness on a pedestal above all else, but gives it rational practical consideration with all other concerns.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/shelby3/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/shelby3\">@shelby3</a> I was not referring to subclassing. That was only the mechanism via which I illustrated the problem with nominal types.</p>\n<p dir=\"auto\">Typeclasses only solve the initial step where you have to convince the owner to implement your nominal interface; you no longer need to do that - you can write your own instance. However, you still have to convince the first author as well as existing library writers to adopt your typeclass i.e. write their code as follows:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"function f(x:TheNominalInterface) { ... }\"><pre class=\"notranslate\"><span class=\"pl-k\">function</span> <span class=\"pl-en\">f</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span>:<span class=\"pl-smi\">TheNominalInterface</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> ... <span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">rather then write their functions against the original nominal type written by the first author:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"function f(x: TheNominalOriginalPromise) { ... }\"><pre class=\"notranslate\"><span class=\"pl-k\">function</span> <span class=\"pl-en\">f</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">TheNominalOriginalPromise</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> ... <span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">In short, I believe that nominal types are <em>not</em> what you want by default, and it was brilliant of TypeScript to bring structural types to the mainstream. I also quite like the idea (its fresh, really) of a type system that doesn't put absolute type safety and soundness on a pedestal above all else, but gives it rational practical consideration with all other concerns.</p>",
        "createdAt": "2016-09-12T22:05:19Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246509999",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjU3NDI2MA==",
        "author": {
          "login": "MartinJohns"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@SimonMeskens Unfortunately these ~~hack~~ widely used workaround won't allow you to define a nominal alias for `string`, so that it can be used as an argument in an indexer.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a> Unfortunately these <del>hack</del> widely used workaround won't allow you to define a nominal alias for <code class=\"notranslate\">string</code>, so that it can be used as an argument in an indexer.</p>",
        "createdAt": "2016-09-13T04:59:25Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246574260",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjU3NTcxMw==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@MartinJohns Not hacks or workarounds at all, as evidenced by the inclusion of Symbol into the standard. Strings are object like anything else, so it does work for strings too. ~~You are correct they are not usable in indexers at present, which is a feature I could get behind (allow types that are either a subclass of string or a union with string in indexers). This is however a shortcoming of Typescript, not a shortcoming of tagged objects. It's also an issue easily fixed without adding new syntax to the language that creates a compile-time only construct.~~ I was wrong, see comment further down\n\nI get a bit tired when people call tagged objects hacks/workarounds. The literature disagrees with you and so does the standard.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/MartinJohns/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/MartinJohns\">@MartinJohns</a> Not hacks or workarounds at all, as evidenced by the inclusion of Symbol into the standard. Strings are object like anything else, so it does work for strings too. <del>You are correct they are not usable in indexers at present, which is a feature I could get behind (allow types that are either a subclass of string or a union with string in indexers). This is however a shortcoming of Typescript, not a shortcoming of tagged objects. It's also an issue easily fixed without adding new syntax to the language that creates a compile-time only construct.</del> I was wrong, see comment further down</p>\n<p dir=\"auto\">I get a bit tired when people call tagged objects hacks/workarounds. The literature disagrees with you and so does the standard.</p>",
        "createdAt": "2016-09-13T05:10:28Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246575713",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjU3NzI0Ng==",
        "author": {
          "login": "MartinJohns"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@SimonMeskens By no means I want to be offensive or disrespectful by calling it a _hack_. It's merely my current understanding of the proposed solution, unless it gets further language support.\n\nAm I understand this correctly that it would not only be a compile time thing, but also a runtime thing by adding a field to the JavaScript object? If yes, how would this play together with data structures parsed from, e.g. using `JSON.parse()`? The API backend surely would not include this brand information in the JSON. Then it also wouldn't be nominal typing, but still structural typing, wouldn't it?\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a> By no means I want to be offensive or disrespectful by calling it a <em>hack</em>. It's merely my current understanding of the proposed solution, unless it gets further language support.</p>\n<p dir=\"auto\">Am I understand this correctly that it would not only be a compile time thing, but also a runtime thing by adding a field to the JavaScript object? If yes, how would this play together with data structures parsed from, e.g. using <code class=\"notranslate\">JSON.parse()</code>? The API backend surely would not include this brand information in the JSON. Then it also wouldn't be nominal typing, but still structural typing, wouldn't it?</p>",
        "createdAt": "2016-09-13T05:21:54Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246577246",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjU3OTIyMw==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@MartinJohns The last project I worked on, which was purely Javascript, already used this concept. The API backend did indeed send brand information, facilitated by the fact that it was running on .NET and thus had the type information needed to brand JSON sent to client. I started adding TypeScript annotations, precisely to leverage this existing behavior. If you are in the unfortunate situation of having to work with a backend that sends back unbranded objects, you would simply brand them yourself, as they come in. Separation of concerns dictates that you would already put your JSON.parse() call in the layer where you fetch the data, which also wraps the ajax calls, etc. In that same layer, you do structural integrity checks, to make sure the data received is valid, at that point, you can easily brand the objects if they prove to be valid.\n\nApologies for being a bit snippy about the use of the word hack, I just think that lots of developers shy away from using this pattern, because of a bias. This is probably not the place to discuss that though.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/MartinJohns/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/MartinJohns\">@MartinJohns</a> The last project I worked on, which was purely Javascript, already used this concept. The API backend did indeed send brand information, facilitated by the fact that it was running on .NET and thus had the type information needed to brand JSON sent to client. I started adding TypeScript annotations, precisely to leverage this existing behavior. If you are in the unfortunate situation of having to work with a backend that sends back unbranded objects, you would simply brand them yourself, as they come in. Separation of concerns dictates that you would already put your JSON.parse() call in the layer where you fetch the data, which also wraps the ajax calls, etc. In that same layer, you do structural integrity checks, to make sure the data received is valid, at that point, you can easily brand the objects if they prove to be valid.</p>\n<p dir=\"auto\">Apologies for being a bit snippy about the use of the word hack, I just think that lots of developers shy away from using this pattern, because of a bias. This is probably not the place to discuss that though.</p>",
        "createdAt": "2016-09-13T05:35:08Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246579223",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjU4NjcyMA==",
        "author": {
          "login": "RyanCavanaugh"
        },
        "authorAssociation": "MEMBER",
        "body": "I think there are two different things being discussed here -- you can have branded _types_ in TypeScript (using whatever property key you want since the property is not actually manifest at runtime) using intersection types or brand properties of an arbitrary property type. This is useful because you can brand things which _can't_ actually have extra properties, such as strings and numbers.\n\nA different problem is discriminating objects that _are_ manifest, via some key. Here a discriminator property, usually with a string value, is well-supported.\n\nI would call the first thing about a 4 on a 0-10 \"hack\" scale (anything 6 or above I would not even mention in this forum without being forced to; people who were trying to fake non-nullability with `T | void` scored an 8 or 9), the second thing scores a solid 0.\n",
        "bodyHTML": "<p dir=\"auto\">I think there are two different things being discussed here -- you can have branded <em>types</em> in TypeScript (using whatever property key you want since the property is not actually manifest at runtime) using intersection types or brand properties of an arbitrary property type. This is useful because you can brand things which <em>can't</em> actually have extra properties, such as strings and numbers.</p>\n<p dir=\"auto\">A different problem is discriminating objects that <em>are</em> manifest, via some key. Here a discriminator property, usually with a string value, is well-supported.</p>\n<p dir=\"auto\">I would call the first thing about a 4 on a 0-10 \"hack\" scale (anything 6 or above I would not even mention in this forum without being forced to; people who were trying to fake non-nullability with <code class=\"notranslate\">T | void</code> scored an 8 or 9), the second thing scores a solid 0.</p>",
        "createdAt": "2016-09-13T06:23:56Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246586720",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjU4ODQyOA==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "Fair enough, yeah, that's why I mentioned earlier I don't like the idea of forcing anything into the language that is not present at runtime (TypeScript should be descriptive of Javascript at all times imo). In case of tagging objects, I don't see why you wouldn't just tag the object for real, unless you are indeed forced to use a pre-existing framework that doesn't let you tag objects, something that does come up in real code.\n",
        "bodyHTML": "<p dir=\"auto\">Fair enough, yeah, that's why I mentioned earlier I don't like the idea of forcing anything into the language that is not present at runtime (TypeScript should be descriptive of Javascript at all times imo). In case of tagging objects, I don't see why you wouldn't just tag the object for real, unless you are indeed forced to use a pre-existing framework that doesn't let you tag objects, something that does come up in real code.</p>",
        "createdAt": "2016-09-13T06:34:37Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246588428",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjU5MDcxNQ==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@MartinJohns I made a mistake earlier, you are indeed correct that if you want to use these nominal strings for property names, that is not possible and it's not a feature TypeScript could ever support in the way described. You are mistaken in thinking that you tag the property names though, all suggestions here for branding through a tag are by making the **value** a unique literal and using TypeScript's excellent support for literal string types:\n\n``` typescript\n// this works!\ninterface Example {\n    someTag: \"unique string goes here\"\n}\n```\n\nBy forcing any objects that satisfy this interface to have a tag with a unique value, you don't need the property **name** to be unique, and thus, indexers do not matter. The [suggested semantic way](https://github.com/Microsoft/TypeScript/issues/10882) I described uses `[Symbol.species]` as a property name, and a UUID as a value, to get both decent semantics and proper uniqueness.\n\nMy apologies for the confusion, I should've gone to bed quite a while ago.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/MartinJohns/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/MartinJohns\">@MartinJohns</a> I made a mistake earlier, you are indeed correct that if you want to use these nominal strings for property names, that is not possible and it's not a feature TypeScript could ever support in the way described. You are mistaken in thinking that you tag the property names though, all suggestions here for branding through a tag are by making the <strong>value</strong> a unique literal and using TypeScript's excellent support for literal string types:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// this works!\ninterface Example {\n    someTag: &quot;unique string goes here&quot;\n}\"><pre class=\"notranslate\"><span class=\"pl-c\">// this works!</span>\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">Example</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">someTag</span>: <span class=\"pl-s\">\"unique string goes here\"</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">By forcing any objects that satisfy this interface to have a tag with a unique value, you don't need the property <strong>name</strong> to be unique, and thus, indexers do not matter. The <a href=\"https://github.com/Microsoft/TypeScript/issues/10882\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/10882/hovercard\">suggested semantic way</a> I described uses <code class=\"notranslate\">[Symbol.species]</code> as a property name, and a UUID as a value, to get both decent semantics and proper uniqueness.</p>\n<p dir=\"auto\">My apologies for the confusion, I should've gone to bed quite a while ago.</p>",
        "createdAt": "2016-09-13T06:47:47Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246590715",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjYwMjAzNQ==",
        "author": {
          "login": "antanas-arvasevicius"
        },
        "authorAssociation": "NONE",
        "body": "Just my thoughts on \"discriminating objects\" problem, how about an idea that \"tagging\" would be implemented within some global WeakMap object where all tag information will be stored in?\nIn object constructions and typecasting (when writting <X>) we'll just add that object into  WeakMap.\nAnd when doing pattern matching / instanceof we'll can check for type match inside WeakMap.\n\nAnd we could explicitly or implicitly to \"tag\" an object with it's type information. \ne.g.  \n`let obj = <Point>{x: 10, y: 10};`\nwill be transpiled to:\n`var object = ___tag({x: 10, y: 10}, '{some_namespace_information}.Point');``\n\nany pros or cons?\n",
        "bodyHTML": "<p dir=\"auto\">Just my thoughts on \"discriminating objects\" problem, how about an idea that \"tagging\" would be implemented within some global WeakMap object where all tag information will be stored in?<br>\nIn object constructions and typecasting (when writting ) we'll just add that object into  WeakMap.<br>\nAnd when doing pattern matching / instanceof we'll can check for type match inside WeakMap.</p>\n<p dir=\"auto\">And we could explicitly or implicitly to \"tag\" an object with it's type information.<br>\ne.g.<br>\n<code class=\"notranslate\">let obj = &lt;Point&gt;{x: 10, y: 10};</code><br>\nwill be transpiled to:<br>\n`var object = ___tag({x: 10, y: 10}, '{some_namespace_information}.Point');``</p>\n<p dir=\"auto\">any pros or cons?</p>",
        "createdAt": "2016-09-13T07:45:45Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246602035",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjYwMjM0NQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "what exactly is wrong with T | void? after all it's been in the official \"what's new\" for a while written by you know who: https://github.com/Microsoft/TypeScript/wiki/What%27s-new-in-TypeScript#improved-unionintersection-type-inference\n\nOn Sep 13, 2016 2:24 AM, \"Ryan Cavanaugh\" notifications@github.com wrote:\n\n> I think there are two different things being discussed here I think -- you\n> can have branded _types_ in TypeScript (using whatever property key you\n> want since the property is not actually manifest at runtime) using\n> intersection types or brand properties of an arbitrary property type. This\n> is useful because you can brand things which _can't_ actually have extra\n> properties, such as strings and numbers.\n> \n> A different problem is discriminating objects that _are_ manifest, via\n> some key. Here a discriminator property, usually with a string value, is\n> well-supported.\n> \n> I would call the first thing about a 4 on a 0-10 \"hack\" scale (anything 6\n> or above I would not even mention in this forum without being forced to;\n> people who were trying to fake non-nullability with T | void scored an 8\n> or 9), the second thing scores a solid 0.\n> \n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/Microsoft/TypeScript/issues/202#issuecomment-246586720,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AA5PzU_eDqpxxXi8WlZX3MnUU55_xkcHks5qpkGcgaJpZM4CPxZP\n> .\n",
        "bodyHTML": "<p dir=\"auto\">what exactly is wrong with T | void? after all it's been in the official \"what's new\" for a while written by you know who: <a href=\"https://github.com/Microsoft/TypeScript/wiki/What%27s-new-in-TypeScript#improved-unionintersection-type-inference\">https://github.com/Microsoft/TypeScript/wiki/What%27s-new-in-TypeScript#improved-unionintersection-type-inference</a></p>\n<p dir=\"auto\">On Sep 13, 2016 2:24 AM, \"Ryan Cavanaugh\" <a href=\"mailto:notifications@github.com\">notifications@github.com</a> wrote:</p>\n<blockquote>\n<p dir=\"auto\">I think there are two different things being discussed here I think -- you<br>\ncan have branded <em>types</em> in TypeScript (using whatever property key you<br>\nwant since the property is not actually manifest at runtime) using<br>\nintersection types or brand properties of an arbitrary property type. This<br>\nis useful because you can brand things which <em>can't</em> actually have extra<br>\nproperties, such as strings and numbers.</p>\n<p dir=\"auto\">A different problem is discriminating objects that <em>are</em> manifest, via<br>\nsome key. Here a discriminator property, usually with a string value, is<br>\nwell-supported.</p>\n<p dir=\"auto\">I would call the first thing about a 4 on a 0-10 \"hack\" scale (anything 6<br>\nor above I would not even mention in this forum without being forced to;<br>\npeople who were trying to fake non-nullability with T | void scored an 8<br>\nor 9), the second thing scores a solid 0.</p>\n<p dir=\"auto\">—<br>\nYou are receiving this because you were mentioned.<br>\nReply to this email directly, view it on GitHub<br>\n<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard?comment_id=246586720&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-246586720\">#202 (comment)</a>,<br>\nor mute the thread<br>\n<a href=\"https://github.com/notifications/unsubscribe-auth/AA5PzU_eDqpxxXi8WlZX3MnUU55_xkcHks5qpkGcgaJpZM4CPxZP\">https://github.com/notifications/unsubscribe-auth/AA5PzU_eDqpxxXi8WlZX3MnUU55_xkcHks5qpkGcgaJpZM4CPxZP</a><br>\n.</p>\n</blockquote>",
        "createdAt": "2016-09-13T07:47:13Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246602345",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjY2NjE4Mg==",
        "author": {
          "login": "shelby3"
        },
        "authorAssociation": "NONE",
        "body": "@mhegazy [wrote](https://github.com/Microsoft/TypeScript/issues/202#issuecomment-246478336):\n\n> I would suggest you keep the discussion in technical terms, and keep the tone professional.\n\nI would suggest all of us do the same, and that includes your comment and my comment replying to your comment. I am sure before you posted your slander and ban-bait, that you read that [I wrote](https://github.com/Microsoft/TypeScript/issues/202#issuecomment-246466777) to @isiahmeadows that I didn't want to discuss this off-topic noise any more.\n\n> over the past few days you have had multiple posts on this forum that are antagonizing and disrespectful to other participants.\n\nI am tired of arguing with you about who antagonized whom, as that just feeds a goal of politically labeling the outsider as the antagonist (a form of discrimination, but do not worry I don't try to use discrimination accusations as weapons). From now on, anyone who makes non-technical posts will receive [a party hat](https://en.wikipedia.org/wiki/Dunce#Dunce_cap) emoticon in response as a big hooray for them focusing on personality instead of technical discussion.\n\n> This is not a request to explain your comments, or tone; this is rather a statement of how many others perceive them.\n\n**This is the last time others can bait me into replying with off-topic noise, by their slandering of my personality with off-topic noise.**\n\nThis is absolutely the last time I will reply on any non-technical discussion in TypeScript's community (unless the party hat icon is removed as a feature). So have fun collecting [party hats](https://www.google.com/search?q=asshat).\n\nIf you deride my personality (and/or don't like me because of my technical preferences and technical goals), that is a form of discrimination btw. (You can disagree with my technical issues without involving judgement of person and that is not discrimination) We are all different. Tolerance is a virtue. You might not like Kobe Byrant's oft-alleged \"arrogant and rude\" personality (and I am not agreeing I am arrogant and rude, it is just an example of what some here are accusing), but this isn't a discussion venue for adherence to some personality profile. I am also not going to comment on anyone's personality. Thanks for judging me and commenting on my personality over and over and over again (even you don't even know me). It ends here from my side. You may choose to collect [party hat](https://www.google.com/search?q=clown+in+hat) emoticons if you wish. It's all your choice. No one is forcing you to.\n\nOne person's perception of rude is another person's reality of being matter-of-fact and rushed. One person's perception of hate speech against groups is another person's reality of speaking about the reality of a particular demographic without referring to any specific person or specific group of persons who could be identified. One person's perception of antagonist, is another person's reality of being accused of \"wasting time\" once and \"employing feelings\" twice. Etc.. I am not going to argue this over and over.\n\n> If you are interested in participating in this forum, and have vested interest in future of the TypeScript community and JavaScript tooling in general, I would suggest you ...\n\nIf you want to ban me, then build your case and do it. I can't control what other people do. I will continue to try to do my best on technical aspects of discussion.\n\nThat doesn't mean I will refuse to adopt any criticism I think is valid or helpful to my goals. I am not closed-minded. But it also means I don't owe anyone anything in that regard. Constructive criticism is not a loan to a debt slave. Constructive criticism itself must normally be offered in an air of mutual appreciation and respect for it to be constructive.\n\nI am not a religious man.\n\n> Judging Others\n> 7 “Do not judge, or you too will be judged. 2 For in the same way you judge others, you will be judged, and with the measure you use, it will be measured to you.\n> \n> 3 “Why do you look at the speck of sawdust in your brother’s eye and pay no attention to the plank in your own eye? 4 How can you say to your brother, ‘Let me take the speck out of your eye,’ when all the time there is a plank in your own eye? 5 You hypocrite, first take the plank out of your own eye, and then you will see clearly to remove the speck from your brother’s eye.\n> \n> 6 “Do not give dogs what is sacred; do not throw your pearls to pigs. If you do, they may trample them under their feet, and turn and tear you to pieces.\n\n@yortus party hats can be comprised of any roughly cone shaped object. That the receiver has to determine the intent, is part of my strategy around intent and the ban rules (Code of Conduct) I've read. It is most elegant the receiver has to determine his reward, not the issuer. I issued you one, and you can determine my intent (Hint: you didn't discuss personality and you did make a technical point).\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/mhegazy/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/mhegazy\">@mhegazy</a> <a href=\"https://github.com/Microsoft/TypeScript/issues/202#issuecomment-246478336\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">wrote</a>:</p>\n<blockquote>\n<p dir=\"auto\">I would suggest you keep the discussion in technical terms, and keep the tone professional.</p>\n</blockquote>\n<p dir=\"auto\">I would suggest all of us do the same, and that includes your comment and my comment replying to your comment. I am sure before you posted your slander and ban-bait, that you read that <a href=\"https://github.com/Microsoft/TypeScript/issues/202#issuecomment-246466777\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">I wrote</a> to @isiahmeadows that I didn't want to discuss this off-topic noise any more.</p>\n<blockquote>\n<p dir=\"auto\">over the past few days you have had multiple posts on this forum that are antagonizing and disrespectful to other participants.</p>\n</blockquote>\n<p dir=\"auto\">I am tired of arguing with you about who antagonized whom, as that just feeds a goal of politically labeling the outsider as the antagonist (a form of discrimination, but do not worry I don't try to use discrimination accusations as weapons). From now on, anyone who makes non-technical posts will receive <a href=\"https://en.wikipedia.org/wiki/Dunce#Dunce_cap\" rel=\"nofollow\">a party hat</a> emoticon in response as a big hooray for them focusing on personality instead of technical discussion.</p>\n<blockquote>\n<p dir=\"auto\">This is not a request to explain your comments, or tone; this is rather a statement of how many others perceive them.</p>\n</blockquote>\n<p dir=\"auto\"><strong>This is the last time others can bait me into replying with off-topic noise, by their slandering of my personality with off-topic noise.</strong></p>\n<p dir=\"auto\">This is absolutely the last time I will reply on any non-technical discussion in TypeScript's community (unless the party hat icon is removed as a feature). So have fun collecting <a href=\"https://www.google.com/search?q=asshat\" rel=\"nofollow\">party hats</a>.</p>\n<p dir=\"auto\">If you deride my personality (and/or don't like me because of my technical preferences and technical goals), that is a form of discrimination btw. (You can disagree with my technical issues without involving judgement of person and that is not discrimination) We are all different. Tolerance is a virtue. You might not like Kobe Byrant's oft-alleged \"arrogant and rude\" personality (and I am not agreeing I am arrogant and rude, it is just an example of what some here are accusing), but this isn't a discussion venue for adherence to some personality profile. I am also not going to comment on anyone's personality. Thanks for judging me and commenting on my personality over and over and over again (even you don't even know me). It ends here from my side. You may choose to collect <a href=\"https://www.google.com/search?q=clown+in+hat\" rel=\"nofollow\">party hat</a> emoticons if you wish. It's all your choice. No one is forcing you to.</p>\n<p dir=\"auto\">One person's perception of rude is another person's reality of being matter-of-fact and rushed. One person's perception of hate speech against groups is another person's reality of speaking about the reality of a particular demographic without referring to any specific person or specific group of persons who could be identified. One person's perception of antagonist, is another person's reality of being accused of \"wasting time\" once and \"employing feelings\" twice. Etc.. I am not going to argue this over and over.</p>\n<blockquote>\n<p dir=\"auto\">If you are interested in participating in this forum, and have vested interest in future of the TypeScript community and JavaScript tooling in general, I would suggest you ...</p>\n</blockquote>\n<p dir=\"auto\">If you want to ban me, then build your case and do it. I can't control what other people do. I will continue to try to do my best on technical aspects of discussion.</p>\n<p dir=\"auto\">That doesn't mean I will refuse to adopt any criticism I think is valid or helpful to my goals. I am not closed-minded. But it also means I don't owe anyone anything in that regard. Constructive criticism is not a loan to a debt slave. Constructive criticism itself must normally be offered in an air of mutual appreciation and respect for it to be constructive.</p>\n<p dir=\"auto\">I am not a religious man.</p>\n<blockquote>\n<p dir=\"auto\">Judging Others<br>\n7 “Do not judge, or you too will be judged. 2 For in the same way you judge others, you will be judged, and with the measure you use, it will be measured to you.</p>\n<p dir=\"auto\">3 “Why do you look at the speck of sawdust in your brother’s eye and pay no attention to the plank in your own eye? 4 How can you say to your brother, ‘Let me take the speck out of your eye,’ when all the time there is a plank in your own eye? 5 You hypocrite, first take the plank out of your own eye, and then you will see clearly to remove the speck from your brother’s eye.</p>\n<p dir=\"auto\">6 “Do not give dogs what is sacred; do not throw your pearls to pigs. If you do, they may trample them under their feet, and turn and tear you to pieces.</p>\n</blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/yortus/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/yortus\">@yortus</a> party hats can be comprised of any roughly cone shaped object. That the receiver has to determine the intent, is part of my strategy around intent and the ban rules (Code of Conduct) I've read. It is most elegant the receiver has to determine his reward, not the issuer. I issued you one, and you can determine my intent (Hint: you didn't discuss personality and you did make a technical point).</p>",
        "createdAt": "2016-09-13T12:31:57Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246666182",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjY5OTcwMw==",
        "author": {
          "login": "yortus"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> anyone who makes non-technical posts will receive a party hat\n\n@shelby3 O/T nit: github does not (yet) allow giving people party hats. But you can give them [party poppers (U+1F389)](http://emojipedia.org/party-popper/).\n",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">anyone who makes non-technical posts will receive a party hat</p>\n</blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/shelby3/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/shelby3\">@shelby3</a> O/T nit: github does not (yet) allow giving people party hats. But you can give them <a href=\"http://emojipedia.org/party-popper/\" rel=\"nofollow\">party poppers (U+1F389)</a>.</p>",
        "createdAt": "2016-09-13T14:28:46Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246699703",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjczNjE3Ng==",
        "author": {
          "login": "shelby3"
        },
        "authorAssociation": "NONE",
        "body": "@spion wrote:\n\n> I was not referring to subclassing. That was only the mechanism via which I illustrated the problem with nominal types.\n\nAfaics, the problem you are concerned with only applies to subclassing.\n\n> Typeclasses only solve the initial step where you have to convince the owner to implement your nominal interface; you no longer need to do that - you can write your own instance. However, you still have to convince the first author as well as existing library writers to adopt your typeclass i.e. write their code as follows:\n> \n> ``` ts\n> function f(x:TheNominalInterface) { ... }\n> ```\n> \n> rather then write their functions against the original nominal type written by the first author:\n> \n> ``` ts\n> function f(x: TheNominalOriginalPromise) { ... }\n> ```\n\nAnyone can implement the typeclass for any preexisting data type. There is no owner any more with typeclasses. The data type can still encapsulate (via modules and/or class) any facets it wishes to, so there is an owner in that respect, but anyone can implement a typeclass interface employing the public interface of any type. It is all about composability and we build new interfaces on top of existing ones. Afaics, the main difference from subclassing is that we are encouraged to invert the hierarchy of inheritance, such that we don't implement a fixed set of interfaces conflated together in one class, but rather implement an unbounded future number of interfaces separately for any class. We change the way we design and think about our interfaces.\n\nAnd this allows us many benefits, including being able to add an interface to collection of instances and feed it to a function without having to manually rebuild the collection wrapping each instance in a new delegate wrapper shell instance (or in the case of a dynamic runtime, add properties manually to each instance...messing with the `prototype` chain is more analogous to typeclasses afaics).\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/spion/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/spion\">@spion</a> wrote:</p>\n<blockquote>\n<p dir=\"auto\">I was not referring to subclassing. That was only the mechanism via which I illustrated the problem with nominal types.</p>\n</blockquote>\n<p dir=\"auto\">Afaics, the problem you are concerned with only applies to subclassing.</p>\n<blockquote>\n<p dir=\"auto\">Typeclasses only solve the initial step where you have to convince the owner to implement your nominal interface; you no longer need to do that - you can write your own instance. However, you still have to convince the first author as well as existing library writers to adopt your typeclass i.e. write their code as follows:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"function f(x:TheNominalInterface) { ... }\"><pre class=\"notranslate\"><span class=\"pl-k\">function</span> <span class=\"pl-en\">f</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span>:<span class=\"pl-smi\">TheNominalInterface</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> ... <span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">rather then write their functions against the original nominal type written by the first author:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"function f(x: TheNominalOriginalPromise) { ... }\"><pre class=\"notranslate\"><span class=\"pl-k\">function</span> <span class=\"pl-en\">f</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">TheNominalOriginalPromise</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> ... <span class=\"pl-kos\">}</span></pre></div>\n</blockquote>\n<p dir=\"auto\">Anyone can implement the typeclass for any preexisting data type. There is no owner any more with typeclasses. The data type can still encapsulate (via modules and/or class) any facets it wishes to, so there is an owner in that respect, but anyone can implement a typeclass interface employing the public interface of any type. It is all about composability and we build new interfaces on top of existing ones. Afaics, the main difference from subclassing is that we are encouraged to invert the hierarchy of inheritance, such that we don't implement a fixed set of interfaces conflated together in one class, but rather implement an unbounded future number of interfaces separately for any class. We change the way we design and think about our interfaces.</p>\n<p dir=\"auto\">And this allows us many benefits, including being able to add an interface to collection of instances and feed it to a function without having to manually rebuild the collection wrapping each instance in a new delegate wrapper shell instance (or in the case of a dynamic runtime, add properties manually to each instance...messing with the <code class=\"notranslate\">prototype</code> chain is more analogous to typeclasses afaics).</p>",
        "createdAt": "2016-09-13T16:13:58Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246736176",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0Njc0NTU5Mg==",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "I don't deny that typeclasses are better and more flexible than subclassing-based interfaces.  But the problem doesn't just apply to subclassing.\n\n[Here is an instance of the problem in Haskell](http://delivery.acm.org/10.1145/2510000/2503785/p37-blazevic.pdf?ip=17.69.203.54&id=2503785&acc=ACTIVE%20SERVICE&key=C8755068B4FD57B4%2EC8755068B4FD57B4%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&CFID=667431291&CFTOKEN=48636493&__acm__=1473785005_8ab277173fe72704885433f66e787aa2) where despite having typeclasses, the community still haven't been able to fix the fragmentation that resulted from String, ByteString, ByteString.Lazy, Text and Text.Lazy. Libraries simply aren't adopting one common nominal interface: most still just use Text/String/ByteString directly, others implement their own personal and incompatible typeclass, and so on.\n\nWith structural types, you can implement the entire interface of an existing type and make all libraries that utilise the exiting type compatible with the new implementation. Without those libraries doing any changes whatsoever.\n",
        "bodyHTML": "<p dir=\"auto\">I don't deny that typeclasses are better and more flexible than subclassing-based interfaces.  But the problem doesn't just apply to subclassing.</p>\n<p dir=\"auto\"><a href=\"http://delivery.acm.org/10.1145/2510000/2503785/p37-blazevic.pdf?ip=17.69.203.54&amp;id=2503785&amp;acc=ACTIVE%20SERVICE&amp;key=C8755068B4FD57B4%2EC8755068B4FD57B4%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&amp;CFID=667431291&amp;CFTOKEN=48636493&amp;__acm__=1473785005_8ab277173fe72704885433f66e787aa2\" rel=\"nofollow\">Here is an instance of the problem in Haskell</a> where despite having typeclasses, the community still haven't been able to fix the fragmentation that resulted from String, ByteString, ByteString.Lazy, Text and Text.Lazy. Libraries simply aren't adopting one common nominal interface: most still just use Text/String/ByteString directly, others implement their own personal and incompatible typeclass, and so on.</p>\n<p dir=\"auto\">With structural types, you can implement the entire interface of an existing type and make all libraries that utilise the exiting type compatible with the new implementation. Without those libraries doing any changes whatsoever.</p>",
        "createdAt": "2016-09-13T16:45:20Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246745592",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NjgwNTk1Nw==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@shelby3 I'm not sure if this thread is the right place for this discussion? You have a suggestion issue open with multiple requests for clarification, that deals with type classes. This thread currently seems to be about whether or not compile-time only nominal types are a good idea, and if so, what they would look like. Type classes seem an orthogonal concept, to me, though there might be some interesting links.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/shelby3/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/shelby3\">@shelby3</a> I'm not sure if this thread is the right place for this discussion? You have a suggestion issue open with multiple requests for clarification, that deals with type classes. This thread currently seems to be about whether or not compile-time only nominal types are a good idea, and if so, what they would look like. Type classes seem an orthogonal concept, to me, though there might be some interesting links.</p>",
        "createdAt": "2016-09-13T20:03:15Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-246805957",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NzEwNDgwMA==",
        "author": {
          "login": "shelby3"
        },
        "authorAssociation": "NONE",
        "body": "@spion wrote:\n\n> I don't deny that typeclasses are better and more flexible than subclassing-based interfaces. But the problem doesn't just apply to subclassing.\n> \n> Here is an instance of the problem in Haskell where despite having typeclasses, the community still haven't been able to fix the fragmentation that resulted from `String`, `ByteString`, `ByteString.Lazy`, `Text`and `Text.Lazy`. Libraries simply aren't adopting one common nominal interface: most still just use `Text`/`String`/`ByteString` directly, others implement their own personal and incompatible typeclass, and so on.\n> \n> With structural types, you can implement the entire interface of an existing type and make all libraries that utilise the exiting type compatible with the new implementation. Without those libraries doing any changes whatsoever.\n\nPer @SimonMeskens's suggestion, please continue this discussion in the issue thread I started for discussing typeclasses. I copied this reply [over there](https://github.com/Microsoft/TypeScript/issues/10844#issuecomment-247105684). Thanks.\n\nThe problem you refer to (as well as Haskell's inability to do first-class unions) is [because Haskell has global type inference](https://users.rust-lang.org/t/high-order-function-with-type-parameter/3112/52). So this means that if we [implement a data type more than one way](https://existentialtype.wordpress.com/2011/04/16/modules-matter-most/) on the same typeclass target, then the inference engine can't decide which one to apply. That problem is not with typeclasses, but with Haskell's choice of a globally coherent inference. Haskell's global inference [has some benefits](https://www.reddit.com/r/haskell/comments/2i4slj/what_is_haskells_answer_to_robert_harpers/ckzxqza), but also has those drawbacks.\n\nTo enable multiple implementations (each for a specific typeclass) of the same data type on the same typeclass, we can support declaring typeclasses that extend other typeclasses. TypeScript's existing interfaces can serve this dual role I think. Then at the use site, we can provide a mechanism for selecting which implementation (i.e. sub-interface) is to be used. We can get more into the details in the future.\n\nSuffice it to say that they are just as flexible as structural typing in terms of extensibility. The differences are they provide the ability to group structure nominal at any granularity we choose as an API designer. And to distinguish between equivalent structure that has a different name (nominal type).\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/spion/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/spion\">@spion</a> wrote:</p>\n<blockquote>\n<p dir=\"auto\">I don't deny that typeclasses are better and more flexible than subclassing-based interfaces. But the problem doesn't just apply to subclassing.</p>\n<p dir=\"auto\">Here is an instance of the problem in Haskell where despite having typeclasses, the community still haven't been able to fix the fragmentation that resulted from <code class=\"notranslate\">String</code>, <code class=\"notranslate\">ByteString</code>, <code class=\"notranslate\">ByteString.Lazy</code>, <code class=\"notranslate\">Text</code>and <code class=\"notranslate\">Text.Lazy</code>. Libraries simply aren't adopting one common nominal interface: most still just use <code class=\"notranslate\">Text</code>/<code class=\"notranslate\">String</code>/<code class=\"notranslate\">ByteString</code> directly, others implement their own personal and incompatible typeclass, and so on.</p>\n<p dir=\"auto\">With structural types, you can implement the entire interface of an existing type and make all libraries that utilise the exiting type compatible with the new implementation. Without those libraries doing any changes whatsoever.</p>\n</blockquote>\n<p dir=\"auto\">Per <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a>'s suggestion, please continue this discussion in the issue thread I started for discussing typeclasses. I copied this reply <a href=\"https://github.com/Microsoft/TypeScript/issues/10844#issuecomment-247105684\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/10844/hovercard\">over there</a>. Thanks.</p>\n<p dir=\"auto\">The problem you refer to (as well as Haskell's inability to do first-class unions) is <a href=\"https://users.rust-lang.org/t/high-order-function-with-type-parameter/3112/52\" rel=\"nofollow\">because Haskell has global type inference</a>. So this means that if we <a href=\"https://existentialtype.wordpress.com/2011/04/16/modules-matter-most/\" rel=\"nofollow\">implement a data type more than one way</a> on the same typeclass target, then the inference engine can't decide which one to apply. That problem is not with typeclasses, but with Haskell's choice of a globally coherent inference. Haskell's global inference <a href=\"https://www.reddit.com/r/haskell/comments/2i4slj/what_is_haskells_answer_to_robert_harpers/ckzxqza\" rel=\"nofollow\">has some benefits</a>, but also has those drawbacks.</p>\n<p dir=\"auto\">To enable multiple implementations (each for a specific typeclass) of the same data type on the same typeclass, we can support declaring typeclasses that extend other typeclasses. TypeScript's existing interfaces can serve this dual role I think. Then at the use site, we can provide a mechanism for selecting which implementation (i.e. sub-interface) is to be used. We can get more into the details in the future.</p>\n<p dir=\"auto\">Suffice it to say that they are just as flexible as structural typing in terms of extensibility. The differences are they provide the ability to group structure nominal at any granularity we choose as an API designer. And to distinguish between equivalent structure that has a different name (nominal type).</p>",
        "createdAt": "2016-09-14T18:10:04Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-247104800",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI0NzQ4MDA3MQ==",
        "author": {
          "login": "shelby3"
        },
        "authorAssociation": "NONE",
        "body": "@SimonMeskens wrote:\n\n> I'm opposed to solutions that create a construction that works purely compile-time. Typescript should attempt to type existing javascript as precisely and concisely as possible. The problem with nominal types is that they are not nominal at run-time, unless they are tagged objects. Typescript can already type tagged objects, though obviously, we are waiting for symbol support in computed properties to really leverage this feature.\n> \n> Can anyone explain to me something that nominal types can do, that tagged objects don't do?\n\nAs I think you alluded to upthread discussion, the `instanceof` operator [will use](https://github.com/Microsoft/TypeScript/issues/1007#issuecomment-246553334) `[Symbol.hasInstance]` instead of the `prototype` chain, so we can simply tag objects with `Symbols` metadata to indicate which nominal types the instance should be.\n\nThe point of typeclasses is to give us [extensibility in two directions](https://github.com/Microsoft/TypeScript/issues/10844#issuecomment-247376361) of Wadler's Expression Problem, which is orthogonal to tagging the runtime objects.\n\nTagging runtime objects is reification (i.e. not erasure) so that the runtime can interopt with the static typing and so the runtime can interopt with nominal types and not just structural types.\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a> wrote:</p>\n<blockquote>\n<p dir=\"auto\">I'm opposed to solutions that create a construction that works purely compile-time. Typescript should attempt to type existing javascript as precisely and concisely as possible. The problem with nominal types is that they are not nominal at run-time, unless they are tagged objects. Typescript can already type tagged objects, though obviously, we are waiting for symbol support in computed properties to really leverage this feature.</p>\n<p dir=\"auto\">Can anyone explain to me something that nominal types can do, that tagged objects don't do?</p>\n</blockquote>\n<p dir=\"auto\">As I think you alluded to upthread discussion, the <code class=\"notranslate\">instanceof</code> operator <a href=\"https://github.com/Microsoft/TypeScript/issues/1007#issuecomment-246553334\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/1007/hovercard\">will use</a> <code class=\"notranslate\">[Symbol.hasInstance]</code> instead of the <code class=\"notranslate\">prototype</code> chain, so we can simply tag objects with <code class=\"notranslate\">Symbols</code> metadata to indicate which nominal types the instance should be.</p>\n<p dir=\"auto\">The point of typeclasses is to give us <a href=\"https://github.com/Microsoft/TypeScript/issues/10844#issuecomment-247376361\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/10844/hovercard\">extensibility in two directions</a> of Wadler's Expression Problem, which is orthogonal to tagging the runtime objects.</p>\n<p dir=\"auto\">Tagging runtime objects is reification (i.e. not erasure) so that the runtime can interopt with the static typing and so the runtime can interopt with nominal types and not just structural types.</p>",
        "createdAt": "2016-09-15T23:09:35Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-247480071",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI2MzAyMDU4Nw==",
        "author": {
          "login": "nahuel"
        },
        "authorAssociation": "NONE",
        "body": "@RyanCavanaugh just a note, the pattern you proposed:\r\n\r\n```ts\r\ntype UserId = string & { \"is user id\": void }\r\n```\r\n\r\ncan't be used as an specialized `string`. For example, this doesn't works:\r\n\r\n```ts\r\ntype MyUsers = { [userId : UserId] : {/*...*/}}    // compiles\r\nlet mu: MyUsers\r\nlet u = mu[<UserId>'sdf']  // TS7017: Element implicitly has an 'any' type because type 'MyUsers' has no index signature.\r\n```\r\n\r\n\r\n\r\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/RyanCavanaugh/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/RyanCavanaugh\">@RyanCavanaugh</a> just a note, the pattern you proposed:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type UserId = string &amp; { &quot;is user id&quot;: void }\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">UserId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">string</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-s\">\"is user id\"</span>: <span class=\"pl-smi\"><span class=\"pl-k\">void</span></span> <span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">can't be used as an specialized <code class=\"notranslate\">string</code>. For example, this doesn't works:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type MyUsers = { [userId : UserId] : {/*...*/}}    // compiles\nlet mu: MyUsers\nlet u = mu[&lt;UserId&gt;'sdf']  // TS7017: Element implicitly has an 'any' type because type 'MyUsers' has no index signature.\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">MyUsers</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">[</span><span class=\"pl-s1\">userId</span> : <span class=\"pl-smi\">UserId</span><span class=\"pl-kos\">]</span> : <span class=\"pl-kos\">{</span><span class=\"pl-c\">/*...*/</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span>    <span class=\"pl-c\">// compiles</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">mu</span>: <span class=\"pl-smi\">MyUsers</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">u</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">mu</span><span class=\"pl-kos\">[</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">UserId</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-s\">'sdf'</span><span class=\"pl-kos\">]</span>  <span class=\"pl-c\">// TS7017: Element implicitly has an 'any' type because type 'MyUsers' has no index signature.</span></pre></div>",
        "createdAt": "2016-11-25T20:43:58Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-263020587",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI2MzEyMTU3Nw==",
        "author": {
          "login": "falsandtru"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I want TypeScript to support phantom types when supporting nominal types.",
        "bodyHTML": "<p dir=\"auto\">I want TypeScript to support phantom types when supporting nominal types.</p>",
        "createdAt": "2016-11-27T13:13:52Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-263121577",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI2MzEzMTk2NQ==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@falsandtru: Nominal types are supported already, as tagged types are supported. We just haven't really decided on a good default way as a community.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/falsandtru/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/falsandtru\">@falsandtru</a>: Nominal types are supported already, as tagged types are supported. We just haven't really decided on a good default way as a community.</p>",
        "createdAt": "2016-11-27T16:35:58Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-263131965",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI2MzEzMzA2Mw==",
        "author": {
          "login": "MartinJohns"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@SimonMeskens \r\n\r\n> Nominal types are supported already\r\n\r\nReally? How can I define a nominal type based on `string` that I can use in an indexer?",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a></p>\n<blockquote>\n<p dir=\"auto\">Nominal types are supported already</p>\n</blockquote>\n<p dir=\"auto\">Really? How can I define a nominal type based on <code class=\"notranslate\">string</code> that I can use in an indexer?</p>",
        "createdAt": "2016-11-27T16:54:10Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-263133063",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI2MzEzMzU3Ng==",
        "author": {
          "login": "falsandtru"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "no, still investigating: https://github.com/Microsoft/TypeScript/wiki/Roadmap",
        "bodyHTML": "<p dir=\"auto\">no, still investigating: <a href=\"https://github.com/Microsoft/TypeScript/wiki/Roadmap\">https://github.com/Microsoft/TypeScript/wiki/Roadmap</a></p>",
        "createdAt": "2016-11-27T17:02:50Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-263133576",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI2MzEzMzY5NQ==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "I'm not at a dev computer right now, but almost all use cases have some way to implement them, using tagged types. ",
        "bodyHTML": "<p dir=\"auto\">I'm not at a dev computer right now, but almost all use cases have some way to implement them, using tagged types.</p>",
        "createdAt": "2016-11-27T17:04:39Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-263133695",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI2MzEzNjA3NQ==",
        "author": {
          "login": "MartinJohns"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@SimonMeskens You should scroll up to Sep. 13 - we both had this very discussion already. I got a bit carried away with my last question, thinking I might have missed a development in this regard, without realizing what you refer to.\r\n\r\nWhile tagged types can be used to achieve the same goals as one usually want to achieve with nominal types, they're not a solution for them. My prime example is again having a nominal type for `string` that can be used as an indexer type. Having a fake interface with a brand is not allowed to be used. Actually expanding an object with a brand value is a no-go and would completely falsify what nominal types try to achieve.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a> You should scroll up to Sep. 13 - we both had this very discussion already. I got a bit carried away with my last question, thinking I might have missed a development in this regard, without realizing what you refer to.</p>\n<p dir=\"auto\">While tagged types can be used to achieve the same goals as one usually want to achieve with nominal types, they're not a solution for them. My prime example is again having a nominal type for <code class=\"notranslate\">string</code> that can be used as an indexer type. Having a fake interface with a brand is not allowed to be used. Actually expanding an object with a brand value is a no-go and would completely falsify what nominal types try to achieve.</p>",
        "createdAt": "2016-11-27T17:49:51Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-263136075",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI2MzE0Mzg4Nw==",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "@MartinJohns How about implementing a dictionary type that allows indexing with tagged values:\r\n\r\n```\r\ninterface Dictionary<Key, Val> {\r\n  get(k:Key): Val;\r\n  set(k:Key, v: Val);\r\n}\r\n```\r\n\r\nit would internally use `this._dict[key.toString()]`\r\n\r\nIf thats not viable, why not fix this in TypeScript by allowing any subtypes of string/number to be specified as indexes?",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/MartinJohns/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/MartinJohns\">@MartinJohns</a> How about implementing a dictionary type that allows indexing with tagged values:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"interface Dictionary&lt;Key, Val&gt; {\n  get(k:Key): Val;\n  set(k:Key, v: Val);\n}\"><pre class=\"notranslate\"><code class=\"notranslate\">interface Dictionary&lt;Key, Val&gt; {\n  get(k:Key): Val;\n  set(k:Key, v: Val);\n}\n</code></pre></div>\n<p dir=\"auto\">it would internally use <code class=\"notranslate\">this._dict[key.toString()]</code></p>\n<p dir=\"auto\">If thats not viable, why not fix this in TypeScript by allowing any subtypes of string/number to be specified as indexes?</p>",
        "createdAt": "2016-11-27T20:04:33Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-263143887",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI2MzI0ODEyMA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "What about a property with an enum member as its type? That is IIRC a way of doing this in a nominal, type-safe way (they're Number subtypes, and there's only one of them).\r\n\r\n```ts\r\nenum StatusTypes {Resolved, Pending, Rejected}\r\ntype Status<T> =\r\n    {type: StatusTypes.Resolved, value: T} |\r\n    {type: StatusTypes.Rejected, value: Error} |\r\n    {type: StatusTypes.Pending}\r\n```",
        "bodyHTML": "<p dir=\"auto\">What about a property with an enum member as its type? That is IIRC a way of doing this in a nominal, type-safe way (they're Number subtypes, and there's only one of them).</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"enum StatusTypes {Resolved, Pending, Rejected}\ntype Status&lt;T&gt; =\n    {type: StatusTypes.Resolved, value: T} |\n    {type: StatusTypes.Rejected, value: Error} |\n    {type: StatusTypes.Pending}\"><pre class=\"notranslate\"><span class=\"pl-k\">enum</span> <span class=\"pl-smi\">StatusTypes</span> <span class=\"pl-kos\">{</span><span class=\"pl-c1\">Resolved</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">Pending</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">Rejected</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Status</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span>\n    <span class=\"pl-kos\">{</span><span class=\"pl-c1\">type</span>: <span class=\"pl-smi\">StatusTypes</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Resolved</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">value</span>: <span class=\"pl-smi\">T</span><span class=\"pl-kos\">}</span> <span class=\"pl-c1\">|</span>\n    <span class=\"pl-kos\">{</span><span class=\"pl-c1\">type</span>: <span class=\"pl-smi\">StatusTypes</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Rejected</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">value</span>: <span class=\"pl-smi\">Error</span><span class=\"pl-kos\">}</span> <span class=\"pl-c1\">|</span>\n    <span class=\"pl-kos\">{</span><span class=\"pl-c1\">type</span>: <span class=\"pl-smi\">StatusTypes</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Pending</span><span class=\"pl-kos\">}</span></pre></div>",
        "createdAt": "2016-11-28T11:28:17Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-263248120",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI2NDE4NzI5MA==",
        "author": {
          "login": "KiaraGrouwstra"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Use-case: implement functional programming constructs like the interfaces from [`fantasy-land`](https://github.com/fantasyland/fantasy-land/issues/140#issuecomment-263762353); many of them cannot be implemented using structural typing, [e.g. `Chain`](https://github.com/fantasyland/fantasy-land/issues/140#issuecomment-263879504).",
        "bodyHTML": "<p dir=\"auto\">Use-case: implement functional programming constructs like the interfaces from <a href=\"https://github.com/fantasyland/fantasy-land/issues/140#issuecomment-263762353\" data-hovercard-type=\"issue\" data-hovercard-url=\"/fantasyland/fantasy-land/issues/140/hovercard\"><code class=\"notranslate\">fantasy-land</code></a>; many of them cannot be implemented using structural typing, <a href=\"https://github.com/fantasyland/fantasy-land/issues/140#issuecomment-263879504\" data-hovercard-type=\"issue\" data-hovercard-url=\"/fantasyland/fantasy-land/issues/140/hovercard\">e.g. <code class=\"notranslate\">Chain</code></a>.</p>",
        "createdAt": "2016-12-01T14:31:46Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-264187290",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI2NDIyNDk4OA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "That's an issue with the lack of higher kinded types, not lack of nominal\ntypes.\n\nOn Thu, Dec 1, 2016, 09:32 Tycho Grouwstra <notifications@github.com> wrote:\n\n> Use-case: implement functional programming constructs like the interfaces\n> from fantasy-land\n> <https://github.com/fantasyland/fantasy-land/issues/140#issuecomment-263762353>;\n> many of them cannot be implemented using structural typing, e.g. Chain\n> <https://github.com/fantasyland/fantasy-land/issues/140#issuecomment-263879504>\n> .\n>\n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/Microsoft/TypeScript/issues/202#issuecomment-264187290>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AERrBPmVd67GZ-EAcKiLa71pCFZAS8R9ks5rDtpngaJpZM4CPxZP>\n> .\n>\n",
        "bodyHTML": "<div class=\"email-fragment\">That's an issue with the lack of higher kinded types, not lack of nominal\ntypes.</div>\n<span class=\"email-hidden-toggle\"><a href=\"#\">…</a></span><div class=\"email-hidden-reply\">\n<div class=\"email-quoted-reply\">On Thu, Dec 1, 2016, 09:32 Tycho Grouwstra ***@***.***&gt; wrote:\n Use-case: implement functional programming constructs like the interfaces\n from fantasy-land\n &lt;<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"154292067\" data-permission-text=\"Title is private\" data-url=\"https://github.com/fantasyland/fantasy-land/issues/140\" href=\"https://github.com/fantasyland/fantasy-land/issues/140#issuecomment-263762353\">fantasyland/fantasy-land#140 (comment)</a>&gt;;\n many of them cannot be implemented using structural typing, e.g. Chain\n &lt;<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"154292067\" data-permission-text=\"Title is private\" data-url=\"https://github.com/fantasyland/fantasy-land/issues/140\" href=\"https://github.com/fantasyland/fantasy-land/issues/140#issuecomment-263879504\">fantasyland/fantasy-land#140 (comment)</a>&gt;\n .\n\n —\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n &lt;<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-264187290\">#202 (comment)</a>&gt;,\n or mute the thread\n &lt;<a href=\"https://github.com/notifications/unsubscribe-auth/AERrBPmVd67GZ-EAcKiLa71pCFZAS8R9ks5rDtpngaJpZM4CPxZP\">https://github.com/notifications/unsubscribe-auth/AERrBPmVd67GZ-EAcKiLa71pCFZAS8R9ks5rDtpngaJpZM4CPxZP</a>&gt;\n .\n</div>\n<div class=\"email-fragment\"></div>\n</div>",
        "createdAt": "2016-12-01T16:43:38Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-264224988",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI2NDIyNTI3NQ==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "I forget the precise issue, but it should be easily found by searching the\nissues. Nominal types won't fix that, BTW.\n\nOn Thu, Dec 1, 2016, 11:43 Isiah Meadows <impinball@gmail.com> wrote:\n\n> That's an issue with the lack of higher kinded types, not lack of nominal\n> types.\n>\n> On Thu, Dec 1, 2016, 09:32 Tycho Grouwstra <notifications@github.com>\n> wrote:\n>\n> Use-case: implement functional programming constructs like the interfaces\n> from fantasy-land\n> <https://github.com/fantasyland/fantasy-land/issues/140#issuecomment-263762353>;\n> many of them cannot be implemented using structural typing, e.g. Chain\n> <https://github.com/fantasyland/fantasy-land/issues/140#issuecomment-263879504>\n> .\n>\n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/Microsoft/TypeScript/issues/202#issuecomment-264187290>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AERrBPmVd67GZ-EAcKiLa71pCFZAS8R9ks5rDtpngaJpZM4CPxZP>\n> .\n>\n>\n",
        "bodyHTML": "<div class=\"email-fragment\">I forget the precise issue, but it should be easily found by searching the\nissues. Nominal types won't fix that, BTW.</div>\n<span class=\"email-hidden-toggle\"><a href=\"#\">…</a></span><div class=\"email-hidden-reply\">\n<div class=\"email-quoted-reply\">On Thu, Dec 1, 2016, 11:43 Isiah Meadows ***@***.***&gt; wrote:\n That's an issue with the lack of higher kinded types, not lack of nominal\n types.\n\n On Thu, Dec 1, 2016, 09:32 Tycho Grouwstra ***@***.***&gt;\n wrote:\n\n Use-case: implement functional programming constructs like the interfaces\n from fantasy-land\n &lt;<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"154292067\" data-permission-text=\"Title is private\" data-url=\"https://github.com/fantasyland/fantasy-land/issues/140\" href=\"https://github.com/fantasyland/fantasy-land/issues/140#issuecomment-263762353\">fantasyland/fantasy-land#140 (comment)</a>&gt;;\n many of them cannot be implemented using structural typing, e.g. Chain\n &lt;<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"154292067\" data-permission-text=\"Title is private\" data-url=\"https://github.com/fantasyland/fantasy-land/issues/140\" href=\"https://github.com/fantasyland/fantasy-land/issues/140#issuecomment-263879504\">fantasyland/fantasy-land#140 (comment)</a>&gt;\n .\n\n —\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n &lt;<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-264187290\">#202 (comment)</a>&gt;,\n or mute the thread\n &lt;<a href=\"https://github.com/notifications/unsubscribe-auth/AERrBPmVd67GZ-EAcKiLa71pCFZAS8R9ks5rDtpngaJpZM4CPxZP\">https://github.com/notifications/unsubscribe-auth/AERrBPmVd67GZ-EAcKiLa71pCFZAS8R9ks5rDtpngaJpZM4CPxZP</a>&gt;\n .\n\n</div>\n<div class=\"email-fragment\"></div>\n</div>",
        "createdAt": "2016-12-01T16:44:42Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-264225275",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI2NDM3NjA0Mw==",
        "author": {
          "login": "KiaraGrouwstra"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@isiahmeadows: thank you for correcting me; guess I'll be following [#1213](https://github.com/Microsoft/TypeScript/issues/1213).",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows: thank you for correcting me; guess I'll be following <a href=\"https://github.com/Microsoft/TypeScript/issues/1213\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/1213/hovercard\">#1213</a>.</p>",
        "createdAt": "2016-12-02T05:21:40Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-264376043",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI3ODIwOTgyOA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "Just as a reminder, WebGL typings need this. #5855",
        "bodyHTML": "<p dir=\"auto\">Just as a reminder, WebGL typings need this. <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"119711370\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/5855\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/5855/hovercard\" href=\"https://github.com/microsoft/TypeScript/issues/5855\">#5855</a></p>",
        "createdAt": "2017-02-08T02:22:03Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-278209828",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI4OTQ4MjI0MA==",
        "author": {
          "login": "PanayotCankov"
        },
        "authorAssociation": "NONE",
        "body": "This would be very handy for us too. (Or probably the linked #364) We are working on Android and iOS where one of the layout systems work in device independent pixels, while the other in real device pixels, in JavaScript we prefer to use device pixels but conversions do occur a lot and having a way to distinguish dip numbers from px numbers would be great!",
        "bodyHTML": "<p dir=\"auto\">This would be very handy for us too. (Or probably the linked <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"39567277\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/364\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/364/hovercard\" href=\"https://github.com/microsoft/TypeScript/issues/364\">#364</a>) We are working on Android and iOS where one of the layout systems work in device independent pixels, while the other in real device pixels, in JavaScript we prefer to use device pixels but conversions do occur a lot and having a way to distinguish dip numbers from px numbers would be great!</p>",
        "createdAt": "2017-03-27T15:05:37Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-289482240",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDI5NzkyMDY3OQ==",
        "author": {
          "login": "jonaskello"
        },
        "authorAssociation": "NONE",
        "body": "I have found another use-case for nominal typing in #15408. The idea is to have abstract types like in [Ocaml](http://ocaml.org/)/[reason](https://facebook.github.io/reason/) or opaque types as they are called in [Elm](http://elm-lang.org/).",
        "bodyHTML": "<p dir=\"auto\">I have found another use-case for nominal typing in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"224730560\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/15408\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/15408/hovercard\" href=\"https://github.com/microsoft/TypeScript/issues/15408\">#15408</a>. The idea is to have abstract types like in <a href=\"http://ocaml.org/\" rel=\"nofollow\">Ocaml</a>/<a href=\"https://facebook.github.io/reason/\" rel=\"nofollow\">reason</a> or opaque types as they are called in <a href=\"http://elm-lang.org/\" rel=\"nofollow\">Elm</a>.</p>",
        "createdAt": "2017-04-28T06:43:04Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-297920679",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMwMjA5NTE5Mg==",
        "author": {
          "login": "mrpmorris"
        },
        "authorAssociation": "NONE",
        "body": "I use a command/query/response pattern in C# that doesn't work well in TypeScript\r\n\r\n```\r\npublic interface IQuery<T> {}\r\npublic class MyRequest : IQuery<MyResponse>\r\n{\r\n  int Id { get; set; }\r\n}\r\npublic class MyResponse \r\n{\r\n  string Error { get; set; }\r\n}\r\n\r\npublic interface IRequestHandler<TRequest, TResponse>\r\n  where TRequest: IQuery<TResponse>\r\n{\r\n  TResponse Query(TRequest request);\r\n}\r\n\r\npublic class MyRequestHandler: IRequestHandler<MyRequest, MyResponse>\r\n{\r\n  public MyResponse Query(MyRequest request)\r\n  {\r\n    //Do some stuff\r\n    //Return response\r\n  }\r\n}\r\n```\r\n\r\nIn C# I can only pass specific combinations for Request/Response - but in TypeScript I can pass in just about any type and expect just about any type. \r\n\r\n```\r\nconst request = new CountPeopleWithAncestorName('Smith', 5);\r\nconst response: CountPeopleWithName = this.apiHandler.query(request);\r\n\r\n```\r\nIn the above example I have passed in the wrong request type, but it works because the request has a \"name\" member as does the proper request CountPeopleWithName. At runtime I would detect the combination is incorrect, but I want to see it is incorrect at compile time.\r\n\r\nAt the moment I am having to add members to my request/response classes like this\r\n\r\n```\r\nclass countPeopleWithNameQuery {\r\n 'Query:CountPeopleWithName'() : {}\r\n}\r\n\r\nclass countPeopleWithNameResponse {\r\n 'Response:CountPeopleWithName'() {}\r\n}\r\n```\r\nand it's very ugly.\r\n\r\n**Would be nice if I could turn on some kind of nominal checking flag in the compiler options. Or if the compiler did nominal checking by default and the only place you can duck-type is when typecasting.**\r\n\r\n``this.callSomeMethod( <SomeClass> { 'a': true, 'b': 42 } );``\r\n",
        "bodyHTML": "<p dir=\"auto\">I use a command/query/response pattern in C# that doesn't work well in TypeScript</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"public interface IQuery&lt;T&gt; {}\npublic class MyRequest : IQuery&lt;MyResponse&gt;\n{\n  int Id { get; set; }\n}\npublic class MyResponse \n{\n  string Error { get; set; }\n}\n\npublic interface IRequestHandler&lt;TRequest, TResponse&gt;\n  where TRequest: IQuery&lt;TResponse&gt;\n{\n  TResponse Query(TRequest request);\n}\n\npublic class MyRequestHandler: IRequestHandler&lt;MyRequest, MyResponse&gt;\n{\n  public MyResponse Query(MyRequest request)\n  {\n    //Do some stuff\n    //Return response\n  }\n}\"><pre class=\"notranslate\"><code class=\"notranslate\">public interface IQuery&lt;T&gt; {}\npublic class MyRequest : IQuery&lt;MyResponse&gt;\n{\n  int Id { get; set; }\n}\npublic class MyResponse \n{\n  string Error { get; set; }\n}\n\npublic interface IRequestHandler&lt;TRequest, TResponse&gt;\n  where TRequest: IQuery&lt;TResponse&gt;\n{\n  TResponse Query(TRequest request);\n}\n\npublic class MyRequestHandler: IRequestHandler&lt;MyRequest, MyResponse&gt;\n{\n  public MyResponse Query(MyRequest request)\n  {\n    //Do some stuff\n    //Return response\n  }\n}\n</code></pre></div>\n<p dir=\"auto\">In C# I can only pass specific combinations for Request/Response - but in TypeScript I can pass in just about any type and expect just about any type.</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const request = new CountPeopleWithAncestorName('Smith', 5);\nconst response: CountPeopleWithName = this.apiHandler.query(request);\n\"><pre class=\"notranslate\"><code class=\"notranslate\">const request = new CountPeopleWithAncestorName('Smith', 5);\nconst response: CountPeopleWithName = this.apiHandler.query(request);\n\n</code></pre></div>\n<p dir=\"auto\">In the above example I have passed in the wrong request type, but it works because the request has a \"name\" member as does the proper request CountPeopleWithName. At runtime I would detect the combination is incorrect, but I want to see it is incorrect at compile time.</p>\n<p dir=\"auto\">At the moment I am having to add members to my request/response classes like this</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"class countPeopleWithNameQuery {\n 'Query:CountPeopleWithName'() : {}\n}\n\nclass countPeopleWithNameResponse {\n 'Response:CountPeopleWithName'() {}\n}\"><pre class=\"notranslate\"><code class=\"notranslate\">class countPeopleWithNameQuery {\n 'Query:CountPeopleWithName'() : {}\n}\n\nclass countPeopleWithNameResponse {\n 'Response:CountPeopleWithName'() {}\n}\n</code></pre></div>\n<p dir=\"auto\">and it's very ugly.</p>\n<p dir=\"auto\"><strong>Would be nice if I could turn on some kind of nominal checking flag in the compiler options. Or if the compiler did nominal checking by default and the only place you can duck-type is when typecasting.</strong></p>\n<p dir=\"auto\"><code class=\"notranslate\">this.callSomeMethod( &lt;SomeClass&gt; { 'a': true, 'b': 42 } );</code></p>",
        "createdAt": "2017-05-17T13:46:59Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-302095192",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMwMjEwMzkyMQ==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@mrpmorris You're trying to write C# in TypeScript, you should instead learn TypeScript. Your use case is not a valid reason to ask for nominal types imo, it's just code written in the wrong language.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/mrpmorris/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/mrpmorris\">@mrpmorris</a> You're trying to write C# in TypeScript, you should instead learn TypeScript. Your use case is not a valid reason to ask for nominal types imo, it's just code written in the wrong language.</p>",
        "createdAt": "2017-05-17T14:16:18Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-302103921",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMwMjEwNjc0Nw==",
        "author": {
          "login": "AJamesPhillips"
        },
        "authorAssociation": "NONE",
        "body": "@SimonMeskens I would be very grateful to know how to implement mrpmorris C# code in Typescript.  Would you be so kind to share any possible solutions.  Many thanks.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a> I would be very grateful to know how to implement mrpmorris C# code in Typescript.  Would you be so kind to share any possible solutions.  Many thanks.</p>",
        "createdAt": "2017-05-17T14:25:04Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-302106747",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMwMjIwMTQ2Mg==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@AJamesPhillips The whole example provided reeks of object-oriented nonsense that only makes sense in a language without the power of expression that JavaScript has. I'd need to see a full example, not some snippets. My suspicion is that you don't need identity at all and it's just an artifact of trying to write OO code in a more expressive language. If you do really need object identity, I don't see any reason why you can't just use a string ID like every other JavaScript library does. TypeScript can type those just fine (unlike C# I might add).",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/AJamesPhillips/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/AJamesPhillips\">@AJamesPhillips</a> The whole example provided reeks of object-oriented nonsense that only makes sense in a language without the power of expression that JavaScript has. I'd need to see a full example, not some snippets. My suspicion is that you don't need identity at all and it's just an artifact of trying to write OO code in a more expressive language. If you do really need object identity, I don't see any reason why you can't just use a string ID like every other JavaScript library does. TypeScript can type those just fine (unlike C# I might add).</p>",
        "createdAt": "2017-05-17T19:18:23Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-302201462",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMwMjI2MDY2NQ==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@AJamesPhillips \r\n\r\nIn the JS world, we just use string/numeric IDs to track type identity rather than types, since when deserializing, we don't have runtime assistance to match type -> ID. Unlike C#, TypeScript supports typing based on arbitrary literal values, such as strings, numbers, symbols, booleans, or even enum constants. And for most use cases that people think they need nominal typing in TS, it's almost always solved by literal types.\r\n\r\n-----\r\n\r\nMy need for it is different, though: I need to properly type a plain object-based data structure whose members are discriminated by only part of a bit mask (space optimization), and making it nominal would be far easier than using some magical bit mask types with embedded enum support (both for me and the feature implementor).",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/AJamesPhillips/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/AJamesPhillips\">@AJamesPhillips</a></p>\n<p dir=\"auto\">In the JS world, we just use string/numeric IDs to track type identity rather than types, since when deserializing, we don't have runtime assistance to match type -&gt; ID. Unlike C#, TypeScript supports typing based on arbitrary literal values, such as strings, numbers, symbols, booleans, or even enum constants. And for most use cases that people think they need nominal typing in TS, it's almost always solved by literal types.</p>\n<hr>\n<p dir=\"auto\">My need for it is different, though: I need to properly type a plain object-based data structure whose members are discriminated by only part of a bit mask (space optimization), and making it nominal would be far easier than using some magical bit mask types with embedded enum support (both for me and the feature implementor).</p>",
        "createdAt": "2017-05-17T23:39:48Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-302260665",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMwMjI2MzkyNA==",
        "author": {
          "login": "aluanhaddad"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@SimonMeskens \r\n> The whole example provided reeks of object-oriented nonsense that only makes sense in a language without the power of expression that JavaScript has. I'd need to see a full example, not some snippets. My suspicion is that you don't need identity at all and it's just an artifact of trying to write OO code in a more expressive language. If you do really need object identity, I don't see any reason why you can't just use a string ID like every other JavaScript library does. TypeScript can type those just fine (unlike C# I might add).\r\n\r\nWhile I am _not_ sympathetic to the idea of introducing nominal typing in TypeScript, and while I certainly agree that the approach is wrong, as transliterating code from one language into another almost always is, I do not think it is a question of language superiority or inferiority.\r\n\r\nI think it comes down to what you said earlier: learn the language. Once one does that, it becomes natural to play to its strengths intuitively and avoid its weaknesses.\r\n\r\nIn languages like C#, one can design and even implement a program from the types down, depending on their reification, performing both static and dynamic dispatch over them and use types both as a means of specifying behavior and enforcing contracts.\r\n\r\nIn TypeScript, it is important to start with values and let the types flow from the natural structure of those values. As those structures coalesce it may or may not make sense to codify them more rigidly but the values themselves must come first.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a></p>\n<blockquote>\n<p dir=\"auto\">The whole example provided reeks of object-oriented nonsense that only makes sense in a language without the power of expression that JavaScript has. I'd need to see a full example, not some snippets. My suspicion is that you don't need identity at all and it's just an artifact of trying to write OO code in a more expressive language. If you do really need object identity, I don't see any reason why you can't just use a string ID like every other JavaScript library does. TypeScript can type those just fine (unlike C# I might add).</p>\n</blockquote>\n<p dir=\"auto\">While I am <em>not</em> sympathetic to the idea of introducing nominal typing in TypeScript, and while I certainly agree that the approach is wrong, as transliterating code from one language into another almost always is, I do not think it is a question of language superiority or inferiority.</p>\n<p dir=\"auto\">I think it comes down to what you said earlier: learn the language. Once one does that, it becomes natural to play to its strengths intuitively and avoid its weaknesses.</p>\n<p dir=\"auto\">In languages like C#, one can design and even implement a program from the types down, depending on their reification, performing both static and dynamic dispatch over them and use types both as a means of specifying behavior and enforcing contracts.</p>\n<p dir=\"auto\">In TypeScript, it is important to start with values and let the types flow from the natural structure of those values. As those structures coalesce it may or may not make sense to codify them more rigidly but the values themselves must come first.</p>",
        "createdAt": "2017-05-18T00:03:17Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-302263924",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMwMjI3MTc3OQ==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@aluanhaddad Don't get me wrong, I LOVE C#, but prototypal inheritance is strictly a superset of object-orientation, meaning everything you can express in OO, you can in prototypal, but not the other way round. This means that on a provably, mathematical ground, JavaScript is just superior in expressiveness and it shows in day to day code. Experts that have been writing top-level JavaScript for years, like, say, Eric Elliott, constantly show code that just wouldn't be expressible in C# without bloat. TypeScript manages to type a lot of this expressiveness.\r\n\r\nThe end result is that it's easy to write C# style code in JavaScript, but you shouldn't and doing so is a clear way to shoot yourself in the foot, as demonstrated with the above code. For example, it has a class with just one function and it's trying to type the class. In TypeScript, you just have that function itself as an object and just type that. Even more important is that JavaScript doesn't even have classes in the sense that C# does, so what are we even trying to type if you just straight port it over to TypeScript?\r\n\r\nI can think of several ways to rewrite the above code leveraging JavaScript going from storing the appropriate query with the request, to functional reactive styles and higher abstractions using pipes.\r\n\r\nThe biggest thing is though: that code is not a reason to implement nominal types in TypeScript.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/aluanhaddad/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/aluanhaddad\">@aluanhaddad</a> Don't get me wrong, I LOVE C#, but prototypal inheritance is strictly a superset of object-orientation, meaning everything you can express in OO, you can in prototypal, but not the other way round. This means that on a provably, mathematical ground, JavaScript is just superior in expressiveness and it shows in day to day code. Experts that have been writing top-level JavaScript for years, like, say, Eric Elliott, constantly show code that just wouldn't be expressible in C# without bloat. TypeScript manages to type a lot of this expressiveness.</p>\n<p dir=\"auto\">The end result is that it's easy to write C# style code in JavaScript, but you shouldn't and doing so is a clear way to shoot yourself in the foot, as demonstrated with the above code. For example, it has a class with just one function and it's trying to type the class. In TypeScript, you just have that function itself as an object and just type that. Even more important is that JavaScript doesn't even have classes in the sense that C# does, so what are we even trying to type if you just straight port it over to TypeScript?</p>\n<p dir=\"auto\">I can think of several ways to rewrite the above code leveraging JavaScript going from storing the appropriate query with the request, to functional reactive styles and higher abstractions using pipes.</p>\n<p dir=\"auto\">The biggest thing is though: that code is not a reason to implement nominal types in TypeScript.</p>",
        "createdAt": "2017-05-18T01:01:58Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-302271779",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMwMjI3OTQ1MQ==",
        "author": {
          "login": "aluanhaddad"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@SimonMeskens For the most part, I heartily agree.\r\n\r\nInterestingly, even in C#, single method classes are often unnecessary, although not uncommon, thanks to delegates which offer something conceptually closer to structural typing. Nothing compared to what we have in TypeScript of course, but it is interesting to think about.\r\n\r\nSAM types were proposed for C# last year and the proposal was rejected because it simply doesn't make sense. Delegates have long allowed for higher levels of abstraction in C# compared to say Java circa 2014.\r\n\r\nYou are indeed correct that JavaScript is flexible enough to fully implement, in terms of composition, inheritance, and everything in between, all common Object Oriented Programming patterns. From straight vertical inheritance, to facades, mixins, interceptors, and delegates (design pattern), JavaScript is uniquely expressive.\r\n\r\nPersonally, however, I try to avoid inheritance where possible, not just because I've been told it is a good practice, but because I just find it amazing what can be done with simple objects and higher order functions. I don't often need it.\r\n\r\nSometimes I use inheritance to be sure, but ESNext features like Object Rest/Spread, something I admit I was initially skeptical of but have fallen in love with, make composition truly effortless.\r\n\r\nThat said, all of these patterns tend to feel brittle to me without the tooling that TypeScript provides. Type inference for Object Rest/Spread is really an amazing thing in this language, and I'm really glad the TypeScript team held off on implementing it until they got the type level transformations for this unique feature precisely defined and implemented.\r\n\r\nThe other day I was writing a unit test for an abstraction that wraps `window.localStorage || window.sessionStorage` and provides automatic conversion to and from JSON. I realized I needed a spy for my test to ensure that values were being passed to the underlying provider in the correct format. Being able to write `{...storage, set(key, value) {...})}`, and have it all typecheck, with no fancy mocking framework (just TypeScript, tape, and jspm) was a great feeling.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a> For the most part, I heartily agree.</p>\n<p dir=\"auto\">Interestingly, even in C#, single method classes are often unnecessary, although not uncommon, thanks to delegates which offer something conceptually closer to structural typing. Nothing compared to what we have in TypeScript of course, but it is interesting to think about.</p>\n<p dir=\"auto\">SAM types were proposed for C# last year and the proposal was rejected because it simply doesn't make sense. Delegates have long allowed for higher levels of abstraction in C# compared to say Java circa 2014.</p>\n<p dir=\"auto\">You are indeed correct that JavaScript is flexible enough to fully implement, in terms of composition, inheritance, and everything in between, all common Object Oriented Programming patterns. From straight vertical inheritance, to facades, mixins, interceptors, and delegates (design pattern), JavaScript is uniquely expressive.</p>\n<p dir=\"auto\">Personally, however, I try to avoid inheritance where possible, not just because I've been told it is a good practice, but because I just find it amazing what can be done with simple objects and higher order functions. I don't often need it.</p>\n<p dir=\"auto\">Sometimes I use inheritance to be sure, but ESNext features like Object Rest/Spread, something I admit I was initially skeptical of but have fallen in love with, make composition truly effortless.</p>\n<p dir=\"auto\">That said, all of these patterns tend to feel brittle to me without the tooling that TypeScript provides. Type inference for Object Rest/Spread is really an amazing thing in this language, and I'm really glad the TypeScript team held off on implementing it until they got the type level transformations for this unique feature precisely defined and implemented.</p>\n<p dir=\"auto\">The other day I was writing a unit test for an abstraction that wraps <code class=\"notranslate\">window.localStorage || window.sessionStorage</code> and provides automatic conversion to and from JSON. I realized I needed a spy for my test to ensure that values were being passed to the underlying provider in the correct format. Being able to write <code class=\"notranslate\">{...storage, set(key, value) {...})}</code>, and have it all typecheck, with no fancy mocking framework (just TypeScript, tape, and jspm) was a great feeling.</p>",
        "createdAt": "2017-05-18T01:58:52Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-302279451",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMwMjI4NTc3OQ==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@aluanhaddad That's exactly what I was trying to convey, but you expressed it more clearly and beautifully than I could.\r\n\r\nI look at the above example and I see: no higher order functions, SAM types, an empty interface to signify identity due to lack of literal types (identity types aka literal symbol types would be even better though), over-reliance on generic types due to lack of higher and combined types. TypeScript has most (not all) of these things down, why use stunted concepts from an OO language? \r\n\r\nI'd go as far as to say that in JavaScript, you should not favor composition, you should ONLY do composition. Differential inheritance through prototypes is wider than just vertical inheritance, so I'm not saying you shouldn't do any stuff with the prototype, but I'd probably advise against any class-type inheritance.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/aluanhaddad/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/aluanhaddad\">@aluanhaddad</a> That's exactly what I was trying to convey, but you expressed it more clearly and beautifully than I could.</p>\n<p dir=\"auto\">I look at the above example and I see: no higher order functions, SAM types, an empty interface to signify identity due to lack of literal types (identity types aka literal symbol types would be even better though), over-reliance on generic types due to lack of higher and combined types. TypeScript has most (not all) of these things down, why use stunted concepts from an OO language?</p>\n<p dir=\"auto\">I'd go as far as to say that in JavaScript, you should not favor composition, you should ONLY do composition. Differential inheritance through prototypes is wider than just vertical inheritance, so I'm not saying you shouldn't do any stuff with the prototype, but I'd probably advise against any class-type inheritance.</p>",
        "createdAt": "2017-05-18T02:47:56Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-302285779",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMwMjQwMDY4NA==",
        "author": {
          "login": "PAStheLoD"
        },
        "authorAssociation": "NONE",
        "body": "Even though this thread is very long, I'd like to recommend looking at mypy's \"unique types\", it's used as [NewType](https://docs.python.org/3/library/typing.html#newtype) (also called distinct types).\r\n\r\nFor the discussion see https://github.com/python/mypy/issues/1284\r\n\r\n\r\nI did not know about \"[branded types](https://github.com/Microsoft/TypeScript/issues/202#issuecomment-246586720)\", but they seem sorta okay-ish. (They are even mentioned in this [Deep Dive book](https://basarat.gitbooks.io/typescript/docs/tips/nominalTyping.html).) But as others have mentioned, they are not universally useful. (For example they don't work as index types. But they work well for serious business things like differentiating between principal and rate for money related stuff.\r\n\r\n```typescript\r\nenum _C { }\r\n\r\ntype Credit = _C & number;\r\n\r\nlet c: Credit;\r\nlet user_id: number;\r\n\r\nc = 2;\r\nuser_id = 3;\r\n\r\nfunction a(cr: Credit) {\r\n    console.log(cr);\r\n}\r\n\r\na(user_id); // no compiler alert, bad :/\r\nconsole.log(c + d); // no compiler alert, bad :/\r\n\r\ninterface Mooneyz extends Number {\r\n    _MoonezyBrand: string;\r\n}\r\nlet m1: Mooneyz = 2 as any;\r\n\r\nfunction b(dough: Mooneyz) {\r\n    console.log(dough);\r\n}\r\n\r\nb(m1);\r\nb(d);  // compiler alert, good!\r\n```\r\n\r\n)\r\n\r\nAlso, for the very simple case of differentiating between numbers and other variables/values that have the same structural type, Scala uses [Value Classes](http://docs.scala-lang.org/overviews/core/value-classes.html).",
        "bodyHTML": "<p dir=\"auto\">Even though this thread is very long, I'd like to recommend looking at mypy's \"unique types\", it's used as <a href=\"https://docs.python.org/3/library/typing.html#newtype\" rel=\"nofollow\">NewType</a> (also called distinct types).</p>\n<p dir=\"auto\">For the discussion see <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"139991532\" data-permission-text=\"Title is private\" data-url=\"https://github.com/python/mypy/issues/1284\" data-hovercard-type=\"issue\" data-hovercard-url=\"/python/mypy/issues/1284/hovercard\" href=\"https://github.com/python/mypy/issues/1284\">python/mypy#1284</a></p>\n<p dir=\"auto\">I did not know about \"<a href=\"https://github.com/Microsoft/TypeScript/issues/202#issuecomment-246586720\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">branded types</a>\", but they seem sorta okay-ish. (They are even mentioned in this <a href=\"https://basarat.gitbooks.io/typescript/docs/tips/nominalTyping.html\" rel=\"nofollow\">Deep Dive book</a>.) But as others have mentioned, they are not universally useful. (For example they don't work as index types. But they work well for serious business things like differentiating between principal and rate for money related stuff.</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"enum _C { }\n\ntype Credit = _C &amp; number;\n\nlet c: Credit;\nlet user_id: number;\n\nc = 2;\nuser_id = 3;\n\nfunction a(cr: Credit) {\n    console.log(cr);\n}\n\na(user_id); // no compiler alert, bad :/\nconsole.log(c + d); // no compiler alert, bad :/\n\ninterface Mooneyz extends Number {\n    _MoonezyBrand: string;\n}\nlet m1: Mooneyz = 2 as any;\n\nfunction b(dough: Mooneyz) {\n    console.log(dough);\n}\n\nb(m1);\nb(d);  // compiler alert, good!\"><pre class=\"notranslate\"><span class=\"pl-k\">enum</span> <span class=\"pl-c1\">_C</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Credit</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">_C</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">c</span>: <span class=\"pl-smi\">Credit</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">user_id</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-s1\">c</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">2</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">user_id</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">3</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">a</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">cr</span>: <span class=\"pl-smi\">Credit</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-smi\">console</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">cr</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-en\">a</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">user_id</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// no compiler alert, bad :/</span>\n<span class=\"pl-smi\">console</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">c</span> <span class=\"pl-c1\">+</span> <span class=\"pl-s1\">d</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// no compiler alert, bad :/</span>\n\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">Mooneyz</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Number</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">_MoonezyBrand</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">m1</span>: <span class=\"pl-smi\">Mooneyz</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">2</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">any</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">b</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">dough</span>: <span class=\"pl-smi\">Mooneyz</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-smi\">console</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">dough</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-en\">b</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">m1</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-en\">b</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">d</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>  <span class=\"pl-c\">// compiler alert, good!</span></pre></div>\n<p dir=\"auto\">)</p>\n<p dir=\"auto\">Also, for the very simple case of differentiating between numbers and other variables/values that have the same structural type, Scala uses <a href=\"http://docs.scala-lang.org/overviews/core/value-classes.html\" rel=\"nofollow\">Value Classes</a>.</p>",
        "createdAt": "2017-05-18T13:17:50Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-302400684",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMwMjQwMjY3MQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "this is the latest and most problem free candidate for being a tag-type\r\n```typescript\r\ndeclare class As<S extends string> {\r\n   private as: S;\r\n}\r\n\r\ntype Email = string & As<'email'>;\r\ntype CustomerId = number & As<'customer-id'>;\r\n```",
        "bodyHTML": "<p dir=\"auto\">this is the latest and most problem free candidate for being a tag-type</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"declare class As&lt;S extends string&gt; {\n   private as: S;\n}\n\ntype Email = string &amp; As&lt;'email'&gt;;\ntype CustomerId = number &amp; As&lt;'customer-id'&gt;;\"><pre class=\"notranslate\"><span class=\"pl-k\">declare</span> <span class=\"pl-k\">class</span> <span class=\"pl-smi\">As</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">S</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">string</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-kos\">{</span>\n   <span class=\"pl-k\">private</span> <span class=\"pl-c1\">as</span>: <span class=\"pl-smi\">S</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Email</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">string</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">As</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'email'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">CustomerId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">As</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'customer-id'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span></pre></div>",
        "createdAt": "2017-05-18T13:25:29Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-302402671",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 11
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMwODM4NzAwOQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "const basket = {} as Basket;\n\nOn Jun 14, 2017 5:18 AM, \"devdoomari\" <notifications@github.com> wrote:\n\n> @aleksey-bykov <https://github.com/aleksey-bykov> but that doesn't work\n> for interfaces / etc:\n>\n> declare class As<S extends string> {\n>    private as: S;\n> }type Basket = {\n>    a?: number\n> } & As<'basket'>\n> const testBasket: Basket = {} // error: no 'as' in {}\n>\n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/Microsoft/TypeScript/issues/202#issuecomment-308373939>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AA5PzZ698L2V9bnzMaKFCKXZ36TY5P4Qks5sD6VmgaJpZM4CPxZP>\n> .\n>\n",
        "bodyHTML": "<div class=\"email-fragment\">const basket = {} as Basket;</div>\n<span class=\"email-hidden-toggle\"><a href=\"#\">…</a></span><div class=\"email-hidden-reply\">\n<div class=\"email-quoted-reply\">On Jun 14, 2017 5:18 AM, \"devdoomari\" ***@***.***&gt; wrote:\n <a class=\"user-mention\" href=\"https://github.com/Aleksey-Bykov\">@Aleksey-Bykov</a> &lt;<a href=\"https://github.com/aleksey-bykov\">https://github.com/aleksey-bykov</a>&gt; but that doesn't work\n for interfaces / etc:\n\n declare class As&lt;S extends string&gt; {\n    private as: S;\n }type Basket = {\n    a?: number\n } &amp; As&lt;'basket'&gt;\n const testBasket: Basket = {} // error: no 'as' in {}\n\n —\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n &lt;<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-308373939\">#202 (comment)</a>&gt;,\n or mute the thread\n &lt;<a href=\"https://github.com/notifications/unsubscribe-auth/AA5PzZ698L2V9bnzMaKFCKXZ36TY5P4Qks5sD6VmgaJpZM4CPxZP\">https://github.com/notifications/unsubscribe-auth/AA5PzZ698L2V9bnzMaKFCKXZ36TY5P4Qks5sD6VmgaJpZM4CPxZP</a>&gt;\n .\n</div>\n<div class=\"email-fragment\"></div>\n</div>",
        "createdAt": "2017-06-14T10:09:45Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-308387009",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMxMDc4OTA1MA==",
        "author": {
          "login": "SMotaal"
        },
        "authorAssociation": "NONE",
        "body": "@aleksey-bykov I like the way you went about it... I've been experimenting with similar (but not quite as elegant) fake-property/forced-assertion patterns for added granularity, but when I took your example [into the playground](https://www.typescriptlang.org/play/index.html#src=declare%20class%20As%3CS%20extends%20string%3E%20%7B%0D%0A%20%20%20private%20as%3A%20S%3B%0D%0A%7D%0D%0A%0D%0Atype%20Email%20%3D%20string%20%26%20As%3C'email'%3E%3B%0D%0Atype%20CustomerId%20%3D%20string%20%26%20As%3C'customer-id'%3E%3B%0D%0A%0D%0Alet%20x1%20%3D%20%3CEmail%3E'abc.com'%3B%0D%0Alet%20y1%20%3D%20%3CCustomerId%3E'abc.com'%3B%0D%0A%0D%0Ax1%20%3D%20y1%3B%0D%0A%0D%0Alet%20x%20%3D%20%3C'email'%3E'abc.com'%3B%0D%0Alet%20y%20%3D%20%3C'customer-id'%3E'abc.com'%3B%0D%0A%0D%0Ax%20%3D%20y%3B%0D%0A) I eventually found my self here:\r\n\r\n```ts\r\nlet x = <'email'>'abc.com'; // or … as Email\r\nlet y = <'customerID'>'abc.com'; // or … as CustomerID\r\n\r\nx = y; // typescript is equally unhappy\r\n```\r\n\r\nMy realization at this point was that no matter how elaborate or simple the approach used to introduce type distinction... all those guards are basically breaking the same rules that help make them feasible in the first place. So unless Typescript provides a true Symbol like concept to explicitly and irrevocably declare structurally compatible types as functionally distinct and incompatible, the only thing we can hope to achieve is clever ways to opt-out of type-checking in order to achieve a false sense of what we assume is a more granular type checking.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Aleksey-Bykov/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Aleksey-Bykov\">@Aleksey-Bykov</a> I like the way you went about it... I've been experimenting with similar (but not quite as elegant) fake-property/forced-assertion patterns for added granularity, but when I took your example <a href=\"https://www.typescriptlang.org/play/index.html#src=declare%20class%20As%3CS%20extends%20string%3E%20%7B%0D%0A%20%20%20private%20as%3A%20S%3B%0D%0A%7D%0D%0A%0D%0Atype%20Email%20%3D%20string%20%26%20As%3C'email'%3E%3B%0D%0Atype%20CustomerId%20%3D%20string%20%26%20As%3C'customer-id'%3E%3B%0D%0A%0D%0Alet%20x1%20%3D%20%3CEmail%3E'abc.com'%3B%0D%0Alet%20y1%20%3D%20%3CCustomerId%3E'abc.com'%3B%0D%0A%0D%0Ax1%20%3D%20y1%3B%0D%0A%0D%0Alet%20x%20%3D%20%3C'email'%3E'abc.com'%3B%0D%0Alet%20y%20%3D%20%3C'customer-id'%3E'abc.com'%3B%0D%0A%0D%0Ax%20%3D%20y%3B%0D%0A\" rel=\"nofollow\">into the playground</a> I eventually found my self here:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"let x = &lt;'email'&gt;'abc.com'; // or … as Email\nlet y = &lt;'customerID'&gt;'abc.com'; // or … as CustomerID\n\nx = y; // typescript is equally unhappy\"><pre class=\"notranslate\"><span class=\"pl-k\">let</span> <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'email'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-s\">'abc.com'</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// or … as Email</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">y</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'customerID'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-s\">'abc.com'</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// or … as CustomerID</span>\n\n<span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">y</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// typescript is equally unhappy</span></pre></div>\n<p dir=\"auto\">My realization at this point was that no matter how elaborate or simple the approach used to introduce type distinction... all those guards are basically breaking the same rules that help make them feasible in the first place. So unless Typescript provides a true Symbol like concept to explicitly and irrevocably declare structurally compatible types as functionally distinct and incompatible, the only thing we can hope to achieve is clever ways to opt-out of type-checking in order to achieve a false sense of what we assume is a more granular type checking.</p>",
        "createdAt": "2017-06-23T22:46:04Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-310789050",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMxMDc5MTU0MQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "type assertions via `<>` or ` as ` is a hammer that can make things look as you want them to bypassing typechecks, it's a powerful tool that needs to be used with caution, in right hands it can do wonders, so can it shoot you in your foot ",
        "bodyHTML": "<p dir=\"auto\">type assertions via <code class=\"notranslate\">&lt;&gt;</code> or <code class=\"notranslate\">as</code> is a hammer that can make things look as you want them to bypassing typechecks, it's a powerful tool that needs to be used with caution, in right hands it can do wonders, so can it shoot you in your foot</p>",
        "createdAt": "2017-06-23T23:05:25Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-310791541",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMxMDgzNjIzNA==",
        "author": {
          "login": "SMotaal"
        },
        "authorAssociation": "NONE",
        "body": "Exactly... well put!\n\nSaleh Abdel Motaal\n\n> On Jun 23, 2017, at 7:05 PM, Aleksey Bykov <notifications@github.com> wrote:\n> \n> type assertions via <> or as is a hammer that can make things look as you want them to bypassing typechecks, it's a powerful tool that needs to be used with caution, in right hands it can do wonders, so can it shoot you in your foot\n> \n> —\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n> \n",
        "bodyHTML": "<div class=\"email-fragment\">Exactly... well put!\n\nSaleh Abdel Motaal</div>\n<span class=\"email-hidden-toggle\"><a href=\"#\">…</a></span><div class=\"email-hidden-reply\">\n<div class=\"email-quoted-reply\"> On Jun 23, 2017, at 7:05 PM, Aleksey Bykov ***@***.***&gt; wrote:\n\n type assertions via &lt;&gt; or as is a hammer that can make things look as you want them to bypassing typechecks, it's a powerful tool that needs to be used with caution, in right hands it can do wonders, so can it shoot you in your foot\n\n —\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub, or mute the thread.\n</div>\n<div class=\"email-fragment\"></div>\n</div>",
        "createdAt": "2017-06-24T12:38:57Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-310836234",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMxMDg0Njk2MQ==",
        "author": {
          "login": "masaeedu"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@aleksey-bykov Have you managed to write a function that can pattern match on this `As` type? Been having a lot of trouble trying to come up with a `match` function in which inference works myself.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Aleksey-Bykov/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Aleksey-Bykov\">@Aleksey-Bykov</a> Have you managed to write a function that can pattern match on this <code class=\"notranslate\">As</code> type? Been having a lot of trouble trying to come up with a <code class=\"notranslate\">match</code> function in which inference works myself.</p>",
        "createdAt": "2017-06-24T15:55:30Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-310846961",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMxMDg4Mjc1MA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "Here's my idea for nominal types:\r\n\r\n**Syntax:**\r\n\r\n```ts\r\nnew type Type<T> = Foo<T> | Bar<T>;\r\nnew interface Foo<T> extends Bar<T> {\r\n    // ...\r\n}\r\n```\r\n\r\n- As simple as adding an extra `new` before the type declaration\r\n- No equivalent for classes/enums exist, but they can be implicitly elevated via a new compiler option\r\n- No conflict with existing syntax, single token lookahead required\r\n    - `new class` *would* conflict, but it is unnecessary with the recommended new compiler option\r\n\r\n**Semantics:**\r\n\r\n- It would elevate the type to be nominal rather than structural\r\n- Nominal types are considered subtypes of their matching structural type\r\n- `new` interfaces cannot merge with any other interface, with two exceptions:\r\n    - Within the same file, `new` and non-`new` interfaces may freely merge, resulting in a nominal interface\r\n    - Imported `new` interfaces may only be extended with non-`new` interfaces\r\n\r\n**Potental FAQ:**\r\n\r\n- Why `new`? *I drew inspiration from Haskell's (and derivatives') `newtype` declarations, but I didn't want to re-invent yet another mess.*\r\n- Why is it kind of decorator-ish? *I wanted to ensure it was easy and obvious to create and learn, but without making it the default.*\r\n- How do I set a variable to a literal of a nominal type? How do I pass a literal in a matching nominal argument? How do I return a literal as a nominal type? *Cast it. It's no different than any other form of downcasting.*\r\n- How could you make existing classes nominal without setting the compiler option? *Just create a matching nominal, zero-member interface.*\r\n- Why not enable it by default for classes or enums? *That could break a lot of existing code, especially for classes. Also, in particular, enums are currently equivalent to their unions, and breaking that could break some larger code bases.*\r\n- Why ban `new` interface merging across files? *It's to decouple interface extension from the type of interface it is. It also makes it easier to update the standard library and existing definition files to leverage this without fear of mass breakage.*\r\n- Why allow such liberal `new` interface merging within a single file? *It's to aid those who generate source code and/or definition files, so they don't have to do as much.*\r\n\r\n-----\r\n\r\nThought it's about time someone comes up with a more detailed proposal.",
        "bodyHTML": "<p dir=\"auto\">Here's my idea for nominal types:</p>\n<p dir=\"auto\"><strong>Syntax:</strong></p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"new type Type&lt;T&gt; = Foo&lt;T&gt; | Bar&lt;T&gt;;\nnew interface Foo&lt;T&gt; extends Bar&lt;T&gt; {\n    // ...\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">new</span> <span class=\"pl-s1\">type</span> <span class=\"pl-smi\">Type</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-c1\"></span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Foo</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">Bar</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">new</span> <span class=\"pl-s1\">interface</span><span class=\"pl-kos\"></span> <span class=\"pl-smi\">Foo</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-s1\">extends</span> <span class=\"pl-smi\">Bar</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c\">// ...</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<ul dir=\"auto\">\n<li>As simple as adding an extra <code class=\"notranslate\">new</code> before the type declaration</li>\n<li>No equivalent for classes/enums exist, but they can be implicitly elevated via a new compiler option</li>\n<li>No conflict with existing syntax, single token lookahead required\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">new class</code> <em>would</em> conflict, but it is unnecessary with the recommended new compiler option</li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\"><strong>Semantics:</strong></p>\n<ul dir=\"auto\">\n<li>It would elevate the type to be nominal rather than structural</li>\n<li>Nominal types are considered subtypes of their matching structural type</li>\n<li><code class=\"notranslate\">new</code> interfaces cannot merge with any other interface, with two exceptions:\n<ul dir=\"auto\">\n<li>Within the same file, <code class=\"notranslate\">new</code> and non-<code class=\"notranslate\">new</code> interfaces may freely merge, resulting in a nominal interface</li>\n<li>Imported <code class=\"notranslate\">new</code> interfaces may only be extended with non-<code class=\"notranslate\">new</code> interfaces</li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\"><strong>Potental FAQ:</strong></p>\n<ul dir=\"auto\">\n<li>Why <code class=\"notranslate\">new</code>? <em>I drew inspiration from Haskell's (and derivatives') <code class=\"notranslate\">newtype</code> declarations, but I didn't want to re-invent yet another mess.</em></li>\n<li>Why is it kind of decorator-ish? <em>I wanted to ensure it was easy and obvious to create and learn, but without making it the default.</em></li>\n<li>How do I set a variable to a literal of a nominal type? How do I pass a literal in a matching nominal argument? How do I return a literal as a nominal type? <em>Cast it. It's no different than any other form of downcasting.</em></li>\n<li>How could you make existing classes nominal without setting the compiler option? <em>Just create a matching nominal, zero-member interface.</em></li>\n<li>Why not enable it by default for classes or enums? <em>That could break a lot of existing code, especially for classes. Also, in particular, enums are currently equivalent to their unions, and breaking that could break some larger code bases.</em></li>\n<li>Why ban <code class=\"notranslate\">new</code> interface merging across files? <em>It's to decouple interface extension from the type of interface it is. It also makes it easier to update the standard library and existing definition files to leverage this without fear of mass breakage.</em></li>\n<li>Why allow such liberal <code class=\"notranslate\">new</code> interface merging within a single file? <em>It's to aid those who generate source code and/or definition files, so they don't have to do as much.</em></li>\n</ul>\n<hr>\n<p dir=\"auto\">Thought it's about time someone comes up with a more detailed proposal.</p>",
        "createdAt": "2017-06-25T05:02:30Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-310882750",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMxMDg5OTE4OA==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "you should look at the function/method overloads, its the only way to \"pattern match\" types at compile time (which is where `as` makes any sense before it gets erased)\r\n\r\n```typescript\r\ngetById(id: number & As<'one-entity'>): OneEntity;\r\ngetById(id: number & As<'another-entity'>): AnotherEntity;\r\ngetById(id: number): Entity {\r\n    // your code here\r\n}\r\n```",
        "bodyHTML": "<p dir=\"auto\">you should look at the function/method overloads, its the only way to \"pattern match\" types at compile time (which is where <code class=\"notranslate\">as</code> makes any sense before it gets erased)</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"getById(id: number &amp; As&lt;'one-entity'&gt;): OneEntity;\ngetById(id: number &amp; As&lt;'another-entity'&gt;): AnotherEntity;\ngetById(id: number): Entity {\n    // your code here\n}\"><pre class=\"notranslate\"><span class=\"pl-s1\">getById</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">id</span>: <span class=\"pl-s1\">number</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">As</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'one-entity'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">OneEntity</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">getById</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">id</span>: <span class=\"pl-s1\">number</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">As</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'another-entity'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">AnotherEntity</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">getById</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">id</span>: <span class=\"pl-s1\">number</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">Entity</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c\">// your code here</span>\n<span class=\"pl-kos\">}</span></pre></div>",
        "createdAt": "2017-06-25T12:12:31Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-310899188",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMxNzA2MzU1MQ==",
        "author": {
          "login": "kube"
        },
        "authorAssociation": "NONE",
        "body": "Just an example of false type assertion by TypeScript:\r\n\r\n```ts\r\nclass Animal {\r\n  run() { }\r\n}\r\n\r\n// Create a nominally-typed animal\r\nconst a = new Animal()\r\n\r\n// Create a structurally-typed animal\r\nconst b: Animal = {\r\n  run() { }\r\n}\r\n\r\nfunction makeAnimalRun(animal: Animal | string) {\r\n  if (animal instanceof Animal) {\r\n    // Here animal is inferred as an Animal, which is true\r\n    animal.run()\r\n  }\r\n  else {\r\n    // Here animal is inferred as a string, but still COULD BE of structural type Animal\r\n    console.log(`${animal.toUpperCase()}!!!!`)\r\n  }\r\n}\r\n\r\nmakeAnimalRun(a)\r\nmakeAnimalRun(b)\r\n```\r\n\r\nMaybe until TypeScript supports Nominal Types, the behaviour of `instanceof` in the type inference should redefined.",
        "bodyHTML": "<p dir=\"auto\">Just an example of false type assertion by TypeScript:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"class Animal {\n  run() { }\n}\n\n// Create a nominally-typed animal\nconst a = new Animal()\n\n// Create a structurally-typed animal\nconst b: Animal = {\n  run() { }\n}\n\nfunction makeAnimalRun(animal: Animal | string) {\n  if (animal instanceof Animal) {\n    // Here animal is inferred as an Animal, which is true\n    animal.run()\n  }\n  else {\n    // Here animal is inferred as a string, but still COULD BE of structural type Animal\n    console.log(`${animal.toUpperCase()}!!!!`)\n  }\n}\n\nmakeAnimalRun(a)\nmakeAnimalRun(b)\"><pre class=\"notranslate\"><span class=\"pl-k\">class</span> <span class=\"pl-smi\">Animal</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-en\">run</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-c\">// Create a nominally-typed animal</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">a</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Animal</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>\n\n<span class=\"pl-c\">// Create a structurally-typed animal</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">b</span>: <span class=\"pl-smi\">Animal</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-en\">run</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">makeAnimalRun</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">animal</span>: <span class=\"pl-smi\">Animal</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">string</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">animal</span> <span class=\"pl-k\">instanceof</span> <span class=\"pl-smi\">Animal</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c\">// Here animal is inferred as an Animal, which is true</span>\n    <span class=\"pl-s1\">animal</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">run</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>\n  <span class=\"pl-kos\">}</span>\n  <span class=\"pl-k\">else</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c\">// Here animal is inferred as a string, but still COULD BE of structural type Animal</span>\n    <span class=\"pl-smi\">console</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">`<span class=\"pl-s1\"><span class=\"pl-kos\">${</span><span class=\"pl-s1\">animal</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">toUpperCase</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">}</span></span>!!!!`</span><span class=\"pl-kos\">)</span>\n  <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-en\">makeAnimalRun</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">a</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-en\">makeAnimalRun</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">b</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">Maybe until TypeScript supports Nominal Types, the behaviour of <code class=\"notranslate\">instanceof</code> in the type inference should redefined.</p>",
        "createdAt": "2017-07-21T17:31:56Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-317063551",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMxNzA2NDgwMw==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "That's indeed a bug, the type of animal inside of the else should still be `Animal | string`\r\n\r\nYou should make a separate issue with just this bug.",
        "bodyHTML": "<p dir=\"auto\">That's indeed a bug, the type of animal inside of the else should still be <code class=\"notranslate\">Animal | string</code></p>\n<p dir=\"auto\">You should make a separate issue with just this bug.</p>",
        "createdAt": "2017-07-21T17:37:05Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-317064803",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMxNzA3MDczMA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "**Edit:** be more exact in what values are eligible.\r\n\r\nHere's a proposal for dealing with nominal typing on a smaller scale (what JS actually does, and similar to what Flow does):\r\n\r\nAny interface that shares an identifier reference with a value that is an object/function with a `Symbol.hasInstance` callable property should be considered a nominal interface. Additionally, that property should be specified as appropriate in the various built-ins, including for constructible types by default. Some of the effects:\r\n\r\n- Most classes will be newly considered nominal.\r\n- Most built-ins will now be considered nominal types.\r\n- Nominal primitive \"subtypes\" can use a `Symbol.hasInstance` to set certain constraints to check.\r\n- Most everything else won't be affected.",
        "bodyHTML": "<p dir=\"auto\"><strong>Edit:</strong> be more exact in what values are eligible.</p>\n<p dir=\"auto\">Here's a proposal for dealing with nominal typing on a smaller scale (what JS actually does, and similar to what Flow does):</p>\n<p dir=\"auto\">Any interface that shares an identifier reference with a value that is an object/function with a <code class=\"notranslate\">Symbol.hasInstance</code> callable property should be considered a nominal interface. Additionally, that property should be specified as appropriate in the various built-ins, including for constructible types by default. Some of the effects:</p>\n<ul dir=\"auto\">\n<li>Most classes will be newly considered nominal.</li>\n<li>Most built-ins will now be considered nominal types.</li>\n<li>Nominal primitive \"subtypes\" can use a <code class=\"notranslate\">Symbol.hasInstance</code> to set certain constraints to check.</li>\n<li>Most everything else won't be affected.</li>\n</ul>",
        "createdAt": "2017-07-21T17:59:27Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-317070730",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMxNzA3MzE4Mg==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows Can you elaborate? It sounds like a really bad idea with lots of edge cases, but I want to see some code samples.\r\n\r\nI like the general idea of incorporating Symbol.hasInstance into the fold",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows Can you elaborate? It sounds like a really bad idea with lots of edge cases, but I want to see some code samples.</p>\n<p dir=\"auto\">I like the general idea of incorporating Symbol.hasInstance into the fold</p>",
        "createdAt": "2017-07-21T18:09:48Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-317073182",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMxNzEyNjUwMQ==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@simonbuchan Here's an idea of how you could create a nominal subtype of `number`:\r\n\r\n```ts\r\n// Positive.ts\r\nexport {Positive};\r\ninterface Positive extends number {}\r\nconst Positive = {\r\n    [Symbol.hasInstance]: x => typeof x === \"number\" && x > 0,\r\n};\r\n\r\ninterface NotNegativeOrZero extends number {}\r\nconst NotNegativeOrZero = {\r\n    [Symbol.hasInstance]: x => typeof x === \"number\" && x > 0,\r\n};\r\n\r\n// main.ts\r\nimport {Positive, NotNegativeOrZero} from \"./Positive\";\r\n\r\nconst x = 0;\r\n\r\nif (x instanceof Positive) {\r\n    let pos: Positive = x;\r\n    let num: number = x; // Error\r\n    let nnz: NotNegativeOrZero = x; // Error, even though technically equivalent.\r\n}\r\n```\r\n\r\nIn general, it shares mostly the same number of edge cases JS has - `instanceof` requires the RHS to be an object (`Function` or `Object`) with a `Symbol.hasInstance`, or failing that, a callable object (`Function`). Technically, there are a few edge cases in the ES spec itself that engines do have to follow, like this one that's pure ES5:\r\n\r\n```js\r\n// Create callable object with no `prototype` property\r\nfunction F() {}\r\n// Define the property without respect to inherited descriptors\r\nObject.defineProperty(F, Symbol.hasInstance, {value: void 0});\r\n// Set the prototype property to something that doesn't require\r\n// referencing the constructor\r\nF.prototype = Object.prototype;\r\n\r\n// Do an `instanceof` check. This should evaluate to `true` even\r\n// in ES6, since it uses the fallback ES5 behavior, which checks\r\n// against `F.prototype === Object.prototype`\r\nassert.strictEqual({} instanceof F, true);\r\n```\r\n\r\nThere is one key edge case unique to my proposal: you *could* add a `Symbol.hasInstance` to the corresponding value's type via interface merging, and then it could be structural in one place, nominal in another. In practice, there's a few ways to handle this effectively, each with pros and cons:\r\n\r\n1. Ignore `Symbol.hasInstance` extensions outside of the file the value is first defined in\r\n    - Avoids most of the confusion with an interface being both nominal and structural\r\n    - Creates an odd edge case that those unfamiliar with the design rationale wouldn't get\r\n2. Propagate `Symbol.hasInstance` extensions non-locally to the modules that don't import it\r\n    - Avoids the nominal/structural confusion\r\n    - Opens up to some [seriously bad behavior](https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming))\r\n3. If multiple identifiers within a scope reference the same interface, with at least one seeing it as nominal (due to an extension in that file or an imported file), make them all nominal in that scope\r\n    - Technically, nominal subtypes are *always* subtypes of their structural variants (like how enums are now), so the latter is observably sound\r\n    - Users could choose to opt in to nominal types incrementally\r\n    - With enough indirection when importing, you could import a type nominally when you thought it'd be structural.\r\n4. Don't\r\n    - Makes resolution simpler and easier to explain in full\r\n    - These kinds of issues are likely to be rare in practice, and when it does occur, it's already going to be a code smell\r\n    - You could define two modules, one exposing the interface structurally, the other nominally\r\n\r\n----\r\n\r\nOne issue with defining it for ~~native builtins~~ **Edit: constructors** is that you'd have to make it a compiler flag for it, since it could break *a lot* of code.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/simonbuchan/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/simonbuchan\">@simonbuchan</a> Here's an idea of how you could create a nominal subtype of <code class=\"notranslate\">number</code>:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// Positive.ts\nexport {Positive};\ninterface Positive extends number {}\nconst Positive = {\n    [Symbol.hasInstance]: x =&gt; typeof x === &quot;number&quot; &amp;&amp; x &gt; 0,\n};\n\ninterface NotNegativeOrZero extends number {}\nconst NotNegativeOrZero = {\n    [Symbol.hasInstance]: x =&gt; typeof x === &quot;number&quot; &amp;&amp; x &gt; 0,\n};\n\n// main.ts\nimport {Positive, NotNegativeOrZero} from &quot;./Positive&quot;;\n\nconst x = 0;\n\nif (x instanceof Positive) {\n    let pos: Positive = x;\n    let num: number = x; // Error\n    let nnz: NotNegativeOrZero = x; // Error, even though technically equivalent.\n}\"><pre class=\"notranslate\"><span class=\"pl-c\">// Positive.ts</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-kos\">{</span><span class=\"pl-smi\">Positive</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">Positive</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">number</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-smi\">Positive</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-kos\">[</span><span class=\"pl-smi\">Symbol</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">hasInstance</span><span class=\"pl-kos\">]</span>: <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">===</span> <span class=\"pl-s\">\"number\"</span> <span class=\"pl-c1\">&amp;&amp;</span> <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">0</span><span class=\"pl-kos\">,</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">NotNegativeOrZero</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">number</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-smi\">NotNegativeOrZero</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-kos\">[</span><span class=\"pl-smi\">Symbol</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">hasInstance</span><span class=\"pl-kos\">]</span>: <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">===</span> <span class=\"pl-s\">\"number\"</span> <span class=\"pl-c1\">&amp;&amp;</span> <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">0</span><span class=\"pl-kos\">,</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// main.ts</span>\n<span class=\"pl-k\">import</span> <span class=\"pl-kos\">{</span><span class=\"pl-smi\">Positive</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">NotNegativeOrZero</span><span class=\"pl-kos\">}</span> <span class=\"pl-k\">from</span> <span class=\"pl-s\">\"./Positive\"</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">0</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span> <span class=\"pl-k\">instanceof</span> <span class=\"pl-smi\">Positive</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">let</span> <span class=\"pl-s1\">pos</span>: <span class=\"pl-smi\">Positive</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">x</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-k\">let</span> <span class=\"pl-s1\">num</span>: <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">x</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// Error</span>\n    <span class=\"pl-k\">let</span> <span class=\"pl-s1\">nnz</span>: <span class=\"pl-smi\">NotNegativeOrZero</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">x</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// Error, even though technically equivalent.</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">In general, it shares mostly the same number of edge cases JS has - <code class=\"notranslate\">instanceof</code> requires the RHS to be an object (<code class=\"notranslate\">Function</code> or <code class=\"notranslate\">Object</code>) with a <code class=\"notranslate\">Symbol.hasInstance</code>, or failing that, a callable object (<code class=\"notranslate\">Function</code>). Technically, there are a few edge cases in the ES spec itself that engines do have to follow, like this one that's pure ES5:</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// Create callable object with no `prototype` property\nfunction F() {}\n// Define the property without respect to inherited descriptors\nObject.defineProperty(F, Symbol.hasInstance, {value: void 0});\n// Set the prototype property to something that doesn't require\n// referencing the constructor\nF.prototype = Object.prototype;\n\n// Do an `instanceof` check. This should evaluate to `true` even\n// in ES6, since it uses the fallback ES5 behavior, which checks\n// against `F.prototype === Object.prototype`\nassert.strictEqual({} instanceof F, true);\"><pre class=\"notranslate\"><span class=\"pl-c\">// Create callable object with no `prototype` property</span>\n<span class=\"pl-k\">function</span> <span class=\"pl-v\">F</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-c\">// Define the property without respect to inherited descriptors</span>\n<span class=\"pl-v\">Object</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">defineProperty</span><span class=\"pl-kos\">(</span><span class=\"pl-v\">F</span><span class=\"pl-kos\">,</span> <span class=\"pl-v\">Symbol</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">hasInstance</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span><span class=\"pl-c1\">value</span>: <span class=\"pl-k\">void</span> <span class=\"pl-c1\">0</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-c\">// Set the prototype property to something that doesn't require</span>\n<span class=\"pl-c\">// referencing the constructor</span>\n<span class=\"pl-v\">F</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">prototype</span> <span class=\"pl-c1\">=</span> <span class=\"pl-v\">Object</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">prototype</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// Do an `instanceof` check. This should evaluate to `true` even</span>\n<span class=\"pl-c\">// in ES6, since it uses the fallback ES5 behavior, which checks</span>\n<span class=\"pl-c\">// against `F.prototype === Object.prototype`</span>\n<span class=\"pl-s1\">assert</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">strictEqual</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span> <span class=\"pl-k\">instanceof</span> <span class=\"pl-v\">F</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">true</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">There is one key edge case unique to my proposal: you <em>could</em> add a <code class=\"notranslate\">Symbol.hasInstance</code> to the corresponding value's type via interface merging, and then it could be structural in one place, nominal in another. In practice, there's a few ways to handle this effectively, each with pros and cons:</p>\n<ol dir=\"auto\">\n<li>Ignore <code class=\"notranslate\">Symbol.hasInstance</code> extensions outside of the file the value is first defined in\n<ul dir=\"auto\">\n<li>Avoids most of the confusion with an interface being both nominal and structural</li>\n<li>Creates an odd edge case that those unfamiliar with the design rationale wouldn't get</li>\n</ul>\n</li>\n<li>Propagate <code class=\"notranslate\">Symbol.hasInstance</code> extensions non-locally to the modules that don't import it\n<ul dir=\"auto\">\n<li>Avoids the nominal/structural confusion</li>\n<li>Opens up to some <a href=\"https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)\" rel=\"nofollow\">seriously bad behavior</a></li>\n</ul>\n</li>\n<li>If multiple identifiers within a scope reference the same interface, with at least one seeing it as nominal (due to an extension in that file or an imported file), make them all nominal in that scope\n<ul dir=\"auto\">\n<li>Technically, nominal subtypes are <em>always</em> subtypes of their structural variants (like how enums are now), so the latter is observably sound</li>\n<li>Users could choose to opt in to nominal types incrementally</li>\n<li>With enough indirection when importing, you could import a type nominally when you thought it'd be structural.</li>\n</ul>\n</li>\n<li>Don't\n<ul dir=\"auto\">\n<li>Makes resolution simpler and easier to explain in full</li>\n<li>These kinds of issues are likely to be rare in practice, and when it does occur, it's already going to be a code smell</li>\n<li>You could define two modules, one exposing the interface structurally, the other nominally</li>\n</ul>\n</li>\n</ol>\n<hr>\n<p dir=\"auto\">One issue with defining it for <del>native builtins</del> <strong>Edit: constructors</strong> is that you'd have to make it a compiler flag for it, since it could break <em>a lot</em> of code.</p>",
        "createdAt": "2017-07-21T22:24:03Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-317126501",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMxNzEyOTA5Ng==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows the problem is that that's really unintuitive with the interface checking for a similarly named variable. Looking through my code, that would break some of the projects I'm currently working on too.\r\n\r\nI like the general idea though, why not just add a keyword to the interface to reference which Symbol.hasInstance carrying variable it refers to?",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows the problem is that that's really unintuitive with the interface checking for a similarly named variable. Looking through my code, that would break some of the projects I'm currently working on too.</p>\n<p dir=\"auto\">I like the general idea though, why not just add a keyword to the interface to reference which Symbol.hasInstance carrying variable it refers to?</p>",
        "createdAt": "2017-07-21T22:42:55Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-317129096",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMxNzEzNjExNQ==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@SimonMeskens \r\n\r\n> Looking through my code, that would break some of the projects I'm currently working on too.\r\n\r\nIf you're referring to existing usage of `Symbol.hasInstance`, I did propose a flag at the end to enable the type addition and edited that part to say \"constructors\" (by default), which should hopefully avert the issue with existing code.\r\n\r\n> the problem is that that's really unintuitive with the interface checking for a similarly named variable.\r\n\r\nI was explaining it in technical, fairly exacting terms, but short summary:\r\n\r\n- If a compiler flag is set, any interface that shares a name with a constructor is considered nominal.\r\n    - This includes classes.\r\n- Nominal subtypes can be manually constructed by:\r\n    1. Creating an interface and value with matching names.\r\n    2. Add a `[Symbol.hasInstance]` method to the value.\r\n\r\n> I like the general idea though, why not just add a keyword to the interface to reference which Symbol.hasInstance carrying variable it refers to?\r\n\r\n1. If necessary, you *can* define a value alias, and [it *does* still narrow correctly, even when checking it](http://www.typescriptlang.org/play/index.html#src=class%20Foo%20%7B%20%7D%0D%0Avar%20Bar%20%3D%20Foo%0D%0Atype%20Bar%20%3D%20Foo%3B%0D%0A%0D%0Avar%20foo%3A%20any%20%3D%20new%20Foo()%0D%0A%0D%0Aif%20(foo%20instanceof%20Bar)%20%7B%0D%0A%20%20%20%20type%20T%20%3D%20typeof%20foo%20%2F%2F%20Hover%20over%20the%20%60T%60%0D%0A%7D).\r\n2. It seems really odd to check one variable to test a differently-named type - I'd find it far less intuitive. Out of curiosity, what would be a use case for that, where defining a local alias wouldn't work?",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a></p>\n<blockquote>\n<p dir=\"auto\">Looking through my code, that would break some of the projects I'm currently working on too.</p>\n</blockquote>\n<p dir=\"auto\">If you're referring to existing usage of <code class=\"notranslate\">Symbol.hasInstance</code>, I did propose a flag at the end to enable the type addition and edited that part to say \"constructors\" (by default), which should hopefully avert the issue with existing code.</p>\n<blockquote>\n<p dir=\"auto\">the problem is that that's really unintuitive with the interface checking for a similarly named variable.</p>\n</blockquote>\n<p dir=\"auto\">I was explaining it in technical, fairly exacting terms, but short summary:</p>\n<ul dir=\"auto\">\n<li>If a compiler flag is set, any interface that shares a name with a constructor is considered nominal.\n<ul dir=\"auto\">\n<li>This includes classes.</li>\n</ul>\n</li>\n<li>Nominal subtypes can be manually constructed by:\n<ol dir=\"auto\">\n<li>Creating an interface and value with matching names.</li>\n<li>Add a <code class=\"notranslate\">[Symbol.hasInstance]</code> method to the value.</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p dir=\"auto\">I like the general idea though, why not just add a keyword to the interface to reference which Symbol.hasInstance carrying variable it refers to?</p>\n</blockquote>\n<ol dir=\"auto\">\n<li>If necessary, you <em>can</em> define a value alias, and <a href=\"http://www.typescriptlang.org/play/index.html#src=class%20Foo%20%7B%20%7D%0D%0Avar%20Bar%20%3D%20Foo%0D%0Atype%20Bar%20%3D%20Foo%3B%0D%0A%0D%0Avar%20foo%3A%20any%20%3D%20new%20Foo()%0D%0A%0D%0Aif%20(foo%20instanceof%20Bar)%20%7B%0D%0A%20%20%20%20type%20T%20%3D%20typeof%20foo%20%2F%2F%20Hover%20over%20the%20%60T%60%0D%0A%7D\" rel=\"nofollow\">it <em>does</em> still narrow correctly, even when checking it</a>.</li>\n<li>It seems really odd to check one variable to test a differently-named type - I'd find it far less intuitive. Out of curiosity, what would be a use case for that, where defining a local alias wouldn't work?</li>\n</ol>",
        "createdAt": "2017-07-21T23:43:37Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-317136115",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMxNzE5MzY5MA==",
        "author": {
          "login": "kube"
        },
        "authorAssociation": "NONE",
        "body": "@SimonMeskens \r\n\r\nIn fact I created a dedicated issue, but it was closed as a duplicate:\r\n\r\nhttps://github.com/Microsoft/TypeScript/issues/17344",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a></p>\n<p dir=\"auto\">In fact I created a dedicated issue, but it was closed as a duplicate:</p>\n<p dir=\"auto\"><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"244722197\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/17344\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/17344/hovercard\" href=\"https://github.com/microsoft/TypeScript/issues/17344\">#17344</a></p>",
        "createdAt": "2017-07-22T16:16:16Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-317193690",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDMyOTkxNDE2Nw==",
        "author": {
          "login": "RyanCavanaugh"
        },
        "authorAssociation": "MEMBER",
        "body": "Collecting use cases from this thread\r\n\r\n* Functions with special behavior (e.g. functions with / without side effects)\r\n* Types with identical fields but different semantics (e.g. `Customer` vs `Client` but both are `People`, our own brands on various `Node` kinds)\r\n* Poor man's units-of-measure\r\n* Identifying \"kinds\" of primitive data (normalized paths, URL-encoded strings, etc)\r\n  * IDs - `CustomerID` and `OrderID` are both `number` but should never interchange\r\n  * Keys (e.g. strings that are only valid for indexing into a certain sort of object)\r\n  * Pointers (e.g. keys for an object map)\r\n* Unscrewing empty types (opaque handles)\r\n",
        "bodyHTML": "<p dir=\"auto\">Collecting use cases from this thread</p>\n<ul dir=\"auto\">\n<li>Functions with special behavior (e.g. functions with / without side effects)</li>\n<li>Types with identical fields but different semantics (e.g. <code class=\"notranslate\">Customer</code> vs <code class=\"notranslate\">Client</code> but both are <code class=\"notranslate\">People</code>, our own brands on various <code class=\"notranslate\">Node</code> kinds)</li>\n<li>Poor man's units-of-measure</li>\n<li>Identifying \"kinds\" of primitive data (normalized paths, URL-encoded strings, etc)\n<ul dir=\"auto\">\n<li>IDs - <code class=\"notranslate\">CustomerID</code> and <code class=\"notranslate\">OrderID</code> are both <code class=\"notranslate\">number</code> but should never interchange</li>\n<li>Keys (e.g. strings that are only valid for indexing into a certain sort of object)</li>\n<li>Pointers (e.g. keys for an object map)</li>\n</ul>\n</li>\n<li>Unscrewing empty types (opaque handles)</li>\n</ul>",
        "createdAt": "2017-09-15T21:59:40Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-329914167",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 74
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 11
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 18
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM0OTk0NDkyNg==",
        "author": {
          "login": "phiresky"
        },
        "authorAssociation": "NONE",
        "body": "It seems like since https://github.com/Microsoft/TypeScript/pull/15473 was merged, another solution to this would be to use\r\n\r\n```ts\r\ntype MyNominalType = unique symbol & { memberA: string, memberB: number }\r\n```\r\n\r\nBut this fails with `[ts] \"unique symbol\"-types are not allowed here`. ",
        "bodyHTML": "<p dir=\"auto\">It seems like since <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"225283033\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/15473\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/microsoft/TypeScript/pull/15473/hovercard\" href=\"https://github.com/microsoft/TypeScript/pull/15473\">#15473</a> was merged, another solution to this would be to use</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type MyNominalType = unique symbol &amp; { memberA: string, memberB: number }\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">MyNominalType</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">symbol</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">memberA</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">memberB</span>: <span class=\"pl-smi\">number</span> <span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">But this fails with <code class=\"notranslate\">[ts] \"unique symbol\"-types are not allowed here</code>.</p>",
        "createdAt": "2017-12-07T11:48:55Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-349944926",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM1MDA1NjgwNQ==",
        "author": {
          "login": "aluanhaddad"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@phiresky `unique symbol` types are associated with constant values. The following will work\r\n```ts\r\ndeclare const A: unique symbol;\r\ndeclare const B: unique symbol;\r\n\r\ntype MyNominalType1 = typeof A & { memberA: string, memberB: number };\r\ntype MyNominalType2 = typeof B & { memberA: string, memberB: number };\r\n\r\ndeclare let x: MyNominalType1;\r\ndeclare let y: MyNominalType2;\r\n\r\nx = y; // assignability error\r\ny = x; // assignability error\r\n```\r\nThe above is essentially the equivalent to the `--declaration` emitted for\r\n```ts\r\nconst A = Symbol();\r\nconst B = Symbol();\r\ntype MyNominalType1 = typeof A & { memberA: string, memberB: number };\r\ntype MyNominalType2 = typeof B & { memberA: string, memberB: number };\r\n```",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/phiresky/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/phiresky\">@phiresky</a> <code class=\"notranslate\">unique symbol</code> types are associated with constant values. The following will work</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"declare const A: unique symbol;\ndeclare const B: unique symbol;\n\ntype MyNominalType1 = typeof A &amp; { memberA: string, memberB: number };\ntype MyNominalType2 = typeof B &amp; { memberA: string, memberB: number };\n\ndeclare let x: MyNominalType1;\ndeclare let y: MyNominalType2;\n\nx = y; // assignability error\ny = x; // assignability error\"><pre class=\"notranslate\"><span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">A</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">B</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">MyNominalType1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">A</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">memberA</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">memberB</span>: <span class=\"pl-smi\">number</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">MyNominalType2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">B</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">memberA</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">memberB</span>: <span class=\"pl-smi\">number</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">let</span> <span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">MyNominalType1</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">let</span> <span class=\"pl-s1\">y</span>: <span class=\"pl-smi\">MyNominalType2</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">y</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// assignability error</span>\n<span class=\"pl-s1\">y</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">x</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// assignability error</span></pre></div>\n<p dir=\"auto\">The above is essentially the equivalent to the <code class=\"notranslate\">--declaration</code> emitted for</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const A = Symbol();\nconst B = Symbol();\ntype MyNominalType1 = typeof A &amp; { memberA: string, memberB: number };\ntype MyNominalType2 = typeof B &amp; { memberA: string, memberB: number };\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-smi\">A</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Symbol</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-smi\">B</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Symbol</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">MyNominalType1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">A</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">memberA</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">memberB</span>: <span class=\"pl-smi\">number</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">MyNominalType2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">B</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">memberA</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">memberB</span>: <span class=\"pl-smi\">number</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span></pre></div>",
        "createdAt": "2017-12-07T18:40:16Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-350056805",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 11
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM1MDMyNjMyNw==",
        "author": null,
        "authorAssociation": "NONE",
        "body": "@phiresky @aluanhaddad \r\nI like this solution better than type brands. :+1:",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/phiresky/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/phiresky\">@phiresky</a> <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/aluanhaddad/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/aluanhaddad\">@aluanhaddad</a><br>\nI like this solution better than type brands. 👍</p>",
        "createdAt": "2017-12-08T17:45:35Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-350326327",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM1MDMzMjQ1Mw==",
        "author": {
          "login": "mmiszy"
        },
        "authorAssociation": "NONE",
        "body": "Is there any chance we could make it work? This looks like a legitemate usecase:\r\n\r\n```typescript\r\ntype A = unique symbol // currently error TS1335: 'unique symbol' types are not allowed here.\r\n```\r\n\r\nor\r\n\r\n```typescript\r\ntype MyNominalType1 = (unique symbol) & { memberA: string, memberB: number };\r\n```",
        "bodyHTML": "<p dir=\"auto\">Is there any chance we could make it work? This looks like a legitemate usecase:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type A = unique symbol // currently error TS1335: 'unique symbol' types are not allowed here.\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">A</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">symbol</span> <span class=\"pl-c\">// currently error TS1335: 'unique symbol' types are not allowed here.</span></pre></div>\n<p dir=\"auto\">or</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type MyNominalType1 = (unique symbol) &amp; { memberA: string, memberB: number };\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">MyNominalType1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span><span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">memberA</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">memberB</span>: <span class=\"pl-smi\">number</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span></pre></div>",
        "createdAt": "2017-12-08T18:10:21Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-350332453",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 8
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM1MjE4NTkxNg==",
        "author": {
          "login": "Ciantic"
        },
        "authorAssociation": "NONE",
        "body": "I noticed this article: https://codemix.com/opaque-types-in-javascript it mentions the flow syntax for opaque types:\r\n\r\n```\r\n// @flow\r\nexport opaque type PaymentAmount = number;\r\n```\r\n\r\nIs there a chance similar syntax is feasible in TypeScript?",
        "bodyHTML": "<p dir=\"auto\">I noticed this article: <a href=\"https://codemix.com/opaque-types-in-javascript\" rel=\"nofollow\">https://codemix.com/opaque-types-in-javascript</a> it mentions the flow syntax for opaque types:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"// @flow\nexport opaque type PaymentAmount = number;\"><pre class=\"notranslate\"><code class=\"notranslate\">// @flow\nexport opaque type PaymentAmount = number;\n</code></pre></div>\n<p dir=\"auto\">Is there a chance similar syntax is feasible in TypeScript?</p>",
        "createdAt": "2017-12-16T14:13:28Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-352185916",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 23
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM2MjA1NTgzMg==",
        "author": {
          "login": "aaronjensen"
        },
        "authorAssociation": "NONE",
        "body": "Building on this a little more...\r\n\r\n```typescript\r\ndeclare class OpaqueTag<S extends string> {\r\n    private tag: S;\r\n}\r\n\r\ntype Opaque<T, S extends string> = T & OpaqueTag<S>\r\n\r\ntype Email = Opaque<string, 'email'>\r\ntype CustomerId = Opaque<string, 'customerId'>\r\ntype Money = Opaque<number, 'money'>\r\ntype Id = Opaque<number, 'id'>\r\n\r\nlet email = <Email>'abc.com';\r\nlet customerId = <CustomerId>'asdfasdfasdf';\r\n\r\n// fails\r\nemail = customerId\r\n\r\nlet Money = <Money>35.45;\r\nlet id = <Id>7;\r\n\r\n// fails\r\nmoney = id\r\n```\r\n\r\n[try](https://www.typescriptlang.org/play/index.html#src=declare%20class%20OpaqueTag%3CS%20extends%20string%3E%20%7B%0D%0A%20%20%20%20private%20tag%3A%20S%3B%0D%0A%7D%0D%0A%0D%0Atype%20Opaque%3CT%2C%20S%20extends%20string%3E%20%3D%20T%20%26%20OpaqueTag%3CS%3E%0D%0A%0D%0Atype%20Email%20%3D%20Opaque%3Cstring%2C%20'email'%3E%0D%0Atype%20CustomerId%20%3D%20Opaque%3Cstring%2C%20'customerId'%3E%0D%0Atype%20Money%20%3D%20Opaque%3Cnumber%2C%20'money'%3E%0D%0Atype%20Id%20%3D%20Opaque%3Cnumber%2C%20'id'%3E%0D%0A%0D%0Alet%20email%20%3D%20%3CEmail%3E'abc.com'%3B%0D%0Alet%20customerId%20%3D%20%3CCustomerId%3E'asdfasdfasdf'%3B%0D%0A%0D%0Aemail%20%3D%20customerId%0D%0A%0D%0Alet%20Money%20%3D%20%3CMoney%3E35.45%3B%0D%0Alet%20id%20%3D%20%3CId%3E7%3B%0D%0A%0D%0Amoney%20%3D%20id%0D%0A)",
        "bodyHTML": "<p dir=\"auto\">Building on this a little more...</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"declare class OpaqueTag&lt;S extends string&gt; {\n    private tag: S;\n}\n\ntype Opaque&lt;T, S extends string&gt; = T &amp; OpaqueTag&lt;S&gt;\n\ntype Email = Opaque&lt;string, 'email'&gt;\ntype CustomerId = Opaque&lt;string, 'customerId'&gt;\ntype Money = Opaque&lt;number, 'money'&gt;\ntype Id = Opaque&lt;number, 'id'&gt;\n\nlet email = &lt;Email&gt;'abc.com';\nlet customerId = &lt;CustomerId&gt;'asdfasdfasdf';\n\n// fails\nemail = customerId\n\nlet Money = &lt;Money&gt;35.45;\nlet id = &lt;Id&gt;7;\n\n// fails\nmoney = id\"><pre class=\"notranslate\"><span class=\"pl-k\">declare</span> <span class=\"pl-k\">class</span> <span class=\"pl-smi\">OpaqueTag</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">S</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">string</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">private</span> <span class=\"pl-c1\">tag</span>: <span class=\"pl-smi\">S</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Opaque</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">S</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">string</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">OpaqueTag</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">S</span><span class=\"pl-kos\">&gt;</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Email</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Opaque</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'email'</span><span class=\"pl-kos\">&gt;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">CustomerId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Opaque</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'customerId'</span><span class=\"pl-kos\">&gt;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Money</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Opaque</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'money'</span><span class=\"pl-kos\">&gt;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Id</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Opaque</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'id'</span><span class=\"pl-kos\">&gt;</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">email</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Email</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-s\">'abc.com'</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">customerId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">CustomerId</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-s\">'asdfasdfasdf'</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// fails</span>\n<span class=\"pl-s1\">email</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">customerId</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-smi\">Money</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Money</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-c1\">35.45</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">id</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Id</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-c1\">7</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// fails</span>\n<span class=\"pl-s1\">money</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">id</span></pre></div>\n<p dir=\"auto\"><a href=\"https://www.typescriptlang.org/play/index.html#src=declare%20class%20OpaqueTag%3CS%20extends%20string%3E%20%7B%0D%0A%20%20%20%20private%20tag%3A%20S%3B%0D%0A%7D%0D%0A%0D%0Atype%20Opaque%3CT%2C%20S%20extends%20string%3E%20%3D%20T%20%26%20OpaqueTag%3CS%3E%0D%0A%0D%0Atype%20Email%20%3D%20Opaque%3Cstring%2C%20'email'%3E%0D%0Atype%20CustomerId%20%3D%20Opaque%3Cstring%2C%20'customerId'%3E%0D%0Atype%20Money%20%3D%20Opaque%3Cnumber%2C%20'money'%3E%0D%0Atype%20Id%20%3D%20Opaque%3Cnumber%2C%20'id'%3E%0D%0A%0D%0Alet%20email%20%3D%20%3CEmail%3E'abc.com'%3B%0D%0Alet%20customerId%20%3D%20%3CCustomerId%3E'asdfasdfasdf'%3B%0D%0A%0D%0Aemail%20%3D%20customerId%0D%0A%0D%0Alet%20Money%20%3D%20%3CMoney%3E35.45%3B%0D%0Alet%20id%20%3D%20%3CId%3E7%3B%0D%0A%0D%0Amoney%20%3D%20id%0D%0A\" rel=\"nofollow\">try</a></p>",
        "createdAt": "2018-01-31T20:10:40Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-362055832",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 14
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM2MjA2ODg2Mg==",
        "author": {
          "login": "demurgos"
        },
        "authorAssociation": "NONE",
        "body": "@aaronjensen \r\nI really like this idea: works great.\r\nMy main issue is that if this code is duplicated in different modules, it creates a new incompatible `OpaqueTag`. It may be what you want if you can ensure uniqueness of the modules. When publishing my libraries to npm, I still want them to work with duplication but require an explicit key.\r\n\r\nFor this use case, you can simply use:\r\n```typescript\r\ntype Named<T, S extends string> = T & {__tsTag?: S}; // Use (string | symbol) to eventually allow symbol names\r\n```\r\n\r\n```typescript\r\nimport { Named as Named1 } from \"lib1\";\r\nimport { Named as Named2 } from \"lib2\";\r\n\r\ntype Lib1Email = Named1<string, \"email\">;\r\ntype Lib2Email = Named2<string, \"email\">;\r\ntype Lib1CustomerId = Named1<string, \"customerId\">;\r\n\r\nlet email1 = \"foo@bar\" as Lib1Email;\r\nlet email2 = \"foo@baz\" as Lib2Email;\r\nlet customer1 = \"111\" as Lib1CustomerId;\r\n\r\nemail1 = email2; // OK\r\nemail1 = customer1; // Fail\r\n```",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/aaronjensen/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/aaronjensen\">@aaronjensen</a><br>\nI really like this idea: works great.<br>\nMy main issue is that if this code is duplicated in different modules, it creates a new incompatible <code class=\"notranslate\">OpaqueTag</code>. It may be what you want if you can ensure uniqueness of the modules. When publishing my libraries to npm, I still want them to work with duplication but require an explicit key.</p>\n<p dir=\"auto\">For this use case, you can simply use:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type Named&lt;T, S extends string&gt; = T &amp; {__tsTag?: S}; // Use (string | symbol) to eventually allow symbol names\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">Named</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">S</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">string</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span><span class=\"pl-c1\">__tsTag</span>?: <span class=\"pl-smi\">S</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// Use (string | symbol) to eventually allow symbol names</span></pre></div>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"import { Named as Named1 } from &quot;lib1&quot;;\nimport { Named as Named2 } from &quot;lib2&quot;;\n\ntype Lib1Email = Named1&lt;string, &quot;email&quot;&gt;;\ntype Lib2Email = Named2&lt;string, &quot;email&quot;&gt;;\ntype Lib1CustomerId = Named1&lt;string, &quot;customerId&quot;&gt;;\n\nlet email1 = &quot;foo@bar&quot; as Lib1Email;\nlet email2 = &quot;foo@baz&quot; as Lib2Email;\nlet customer1 = &quot;111&quot; as Lib1CustomerId;\n\nemail1 = email2; // OK\nemail1 = customer1; // Fail\"><pre class=\"notranslate\"><span class=\"pl-k\">import</span> <span class=\"pl-kos\">{</span> <span class=\"pl-smi\">Named</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Named1</span> <span class=\"pl-kos\">}</span> <span class=\"pl-k\">from</span> <span class=\"pl-s\">\"lib1\"</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">import</span> <span class=\"pl-kos\">{</span> <span class=\"pl-smi\">Named</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Named2</span> <span class=\"pl-kos\">}</span> <span class=\"pl-k\">from</span> <span class=\"pl-s\">\"lib2\"</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Lib1Email</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Named1</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">\"email\"</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Lib2Email</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Named2</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">\"email\"</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Lib1CustomerId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Named1</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">\"customerId\"</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">email1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">\"foo@bar\"</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Lib1Email</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">email2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">\"foo@baz\"</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Lib2Email</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">customer1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">\"111\"</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Lib1CustomerId</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-s1\">email1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">email2</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// OK</span>\n<span class=\"pl-s1\">email1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">customer1</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// Fail</span></pre></div>",
        "createdAt": "2018-01-31T21:00:31Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-362068862",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM2MjA5NjIwNA==",
        "author": {
          "login": "aaronjensen"
        },
        "authorAssociation": "NONE",
        "body": "@demurgos You may want to drop the `?` on `__tsTag` unless you want to be able to do `let email: Lib1Email = \"foo@bar\"` w/o the cast. Also, because it's not private, `email1.__tsTag` typechecks. Trade offs...\r\n\r\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/demurgos/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/demurgos\">@demurgos</a> You may want to drop the <code class=\"notranslate\">?</code> on <code class=\"notranslate\">__tsTag</code> unless you want to be able to do <code class=\"notranslate\">let email: Lib1Email = \"foo@bar\"</code> w/o the cast. Also, because it's not private, <code class=\"notranslate\">email1.__tsTag</code> typechecks. Trade offs...</p>",
        "createdAt": "2018-01-31T22:43:08Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-362096204",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM2MjA5NzAwOA==",
        "author": {
          "login": "aaronjensen"
        },
        "authorAssociation": "NONE",
        "body": "And yeah, I'd say that usually when you have opaque types you want them to be opaque to other modules. That's how flow does it. If two modules both declare an `Email` string type you may not actually want them to be compatible because they  may not be. If they are, then they could share a common module that defines the opaque type once.",
        "bodyHTML": "<p dir=\"auto\">And yeah, I'd say that usually when you have opaque types you want them to be opaque to other modules. That's how flow does it. If two modules both declare an <code class=\"notranslate\">Email</code> string type you may not actually want them to be compatible because they  may not be. If they are, then they could share a common module that defines the opaque type once.</p>",
        "createdAt": "2018-01-31T22:46:37Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-362097008",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM2MjEwMjQ2Ng==",
        "author": {
          "login": "demurgos"
        },
        "authorAssociation": "NONE",
        "body": "@aaronjensen \r\nThank you, you are right that the `?` makes two of my named strings incompatible if they don't have the same tag but not with the base type. I wanted to avoid unneeded constraints but in this case you need it.\r\n\r\nYou are right that opaque types should be unique, but I don't think it is the best solution for Node's ecosystem because relying on uniqueness across multiple packages is not reliable (that's probably one of the reasons why TS is structural first). Again, it is fine if you can guarantee uniqueness but it depends on the use case.\r\n\r\nThe main problem I want to solve is to prevent assigning a string with `CustomerId` semantics to a string with `Email` semantics, but I prefer the uniqueness of `Email` to not depend on the uniqueness of the module defining it (even if it guarantees that there is no accidental confusion).\r\nWith my solution, my idea was to let the developer handle the uniqueness: if he creates two types with the same tag, assume they have the same semantics. Of course this has the trade-off that there may be two types `Named<string, \"id\">` for example with different semantics that are now still conflicting. I'd still say that it improves the situation if you use meaningful names by reducing accidents (there's less `Named<string, \"id\">` with different semantics than `string` with different semantics). You can still namespace the tags such as `Named<string, \"demurgos/email\">` if you want. On the other hand, it does work well with duplication and npm.\r\n\r\nHere is a more concrete example. The `pg` package is a lib to use Postgres from Node, the `squel` library is a library to build SQL queries. Currently `pg` has a Client interface with `.query(sqlText: string, values: any[]): Promise<QueryResult>` and `squel` returns `string` values. If they wanted it, they could both use `type Sql = Named<string, \"sql\">;` instead of `string`. You'd have to manually tag a string with `as Sql` but both of them would happily inter-operate.\r\n\r\nI never really tried to implement this kind of tagging across multiple packages before. I think that now that you gave me the idea, I'll try and see if it's worth it or not.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/aaronjensen/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/aaronjensen\">@aaronjensen</a><br>\nThank you, you are right that the <code class=\"notranslate\">?</code> makes two of my named strings incompatible if they don't have the same tag but not with the base type. I wanted to avoid unneeded constraints but in this case you need it.</p>\n<p dir=\"auto\">You are right that opaque types should be unique, but I don't think it is the best solution for Node's ecosystem because relying on uniqueness across multiple packages is not reliable (that's probably one of the reasons why TS is structural first). Again, it is fine if you can guarantee uniqueness but it depends on the use case.</p>\n<p dir=\"auto\">The main problem I want to solve is to prevent assigning a string with <code class=\"notranslate\">CustomerId</code> semantics to a string with <code class=\"notranslate\">Email</code> semantics, but I prefer the uniqueness of <code class=\"notranslate\">Email</code> to not depend on the uniqueness of the module defining it (even if it guarantees that there is no accidental confusion).<br>\nWith my solution, my idea was to let the developer handle the uniqueness: if he creates two types with the same tag, assume they have the same semantics. Of course this has the trade-off that there may be two types <code class=\"notranslate\">Named&lt;string, \"id\"&gt;</code> for example with different semantics that are now still conflicting. I'd still say that it improves the situation if you use meaningful names by reducing accidents (there's less <code class=\"notranslate\">Named&lt;string, \"id\"&gt;</code> with different semantics than <code class=\"notranslate\">string</code> with different semantics). You can still namespace the tags such as <code class=\"notranslate\">Named&lt;string, \"demurgos/email\"&gt;</code> if you want. On the other hand, it does work well with duplication and npm.</p>\n<p dir=\"auto\">Here is a more concrete example. The <code class=\"notranslate\">pg</code> package is a lib to use Postgres from Node, the <code class=\"notranslate\">squel</code> library is a library to build SQL queries. Currently <code class=\"notranslate\">pg</code> has a Client interface with <code class=\"notranslate\">.query(sqlText: string, values: any[]): Promise&lt;QueryResult&gt;</code> and <code class=\"notranslate\">squel</code> returns <code class=\"notranslate\">string</code> values. If they wanted it, they could both use <code class=\"notranslate\">type Sql = Named&lt;string, \"sql\"&gt;;</code> instead of <code class=\"notranslate\">string</code>. You'd have to manually tag a string with <code class=\"notranslate\">as Sql</code> but both of them would happily inter-operate.</p>\n<p dir=\"auto\">I never really tried to implement this kind of tagging across multiple packages before. I think that now that you gave me the idea, I'll try and see if it's worth it or not.</p>",
        "createdAt": "2018-01-31T23:11:35Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-362102466",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM2MjEwMzUwMQ==",
        "author": {
          "login": "aaronjensen"
        },
        "authorAssociation": "NONE",
        "body": "@demurgos Sounds good. Both opaque types and named types as you've described I'm sure have their uses, but they're two different things. Good luck!",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/demurgos/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/demurgos\">@demurgos</a> Sounds good. Both opaque types and named types as you've described I'm sure have their uses, but they're two different things. Good luck!</p>",
        "createdAt": "2018-01-31T23:16:46Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-362103501",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM4MTQxNTM0OA==",
        "author": {
          "login": "mindplay-dk"
        },
        "authorAssociation": "NONE",
        "body": "Is this happening? I'm getting [desperate](https://github.com/Microsoft/TypeScript/issues/4895#issuecomment-381414874).",
        "bodyHTML": "<p dir=\"auto\">Is this happening? I'm getting <a href=\"https://github.com/Microsoft/TypeScript/issues/4895#issuecomment-381414874\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/4895/hovercard\">desperate</a>.</p>",
        "createdAt": "2018-04-15T15:35:07Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-381415348",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM4MTQzNzYyOA==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@mindplay-dk You want something like this. Doesn't create any ghost properties, doesn't create any run-time properties:\r\n\r\n```TypeScript\r\nconst InputConnectorIdentity = Symbol(\"InputConnector\");\r\nconst OutputConnectorIdentity = Symbol(\"OutputConnector\");\r\n\r\ntype GraphNode = {\r\n    inputs: InputConnector[]\r\n    outputs: OutputConnector[]\r\n}\r\n\r\nconst createNode = (): GraphNode => ({\r\n    inputs: [],\r\n    outputs: []\r\n});\r\n\r\ntype Connector = {\r\n    node: GraphNode\r\n};\r\n\r\ntype InputConnector = typeof InputConnectorIdentity & Connector;\r\ntype OutputConnector = typeof OutputConnectorIdentity & Connector;\r\n\r\nconst createConnector = (node: GraphNode) => ({\r\n    node: node\r\n});\r\n\r\nconst createInputConnector:\r\n    (node: GraphNode) => InputConnector =\r\n    <any>createConnector;\r\n\r\nconst createOutputConnector:\r\n    (node: GraphNode) => OutputConnector =\r\n    <any>createConnector;\r\n\r\nlet node1 = createNode();\r\nlet node2 = createNode();\r\n\r\nlet input = createInputConnector(node2);\r\nlet output = createOutputConnector(node2);\r\n\r\nnode1.inputs.push(input); // works\r\nnode1.inputs.push(output); // error: Argument of type 'OutputConnector' is not assignable to parameter of type 'InputConnector'\r\n```",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/mindplay-dk/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/mindplay-dk\">@mindplay-dk</a> You want something like this. Doesn't create any ghost properties, doesn't create any run-time properties:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const InputConnectorIdentity = Symbol(&quot;InputConnector&quot;);\nconst OutputConnectorIdentity = Symbol(&quot;OutputConnector&quot;);\n\ntype GraphNode = {\n    inputs: InputConnector[]\n    outputs: OutputConnector[]\n}\n\nconst createNode = (): GraphNode =&gt; ({\n    inputs: [],\n    outputs: []\n});\n\ntype Connector = {\n    node: GraphNode\n};\n\ntype InputConnector = typeof InputConnectorIdentity &amp; Connector;\ntype OutputConnector = typeof OutputConnectorIdentity &amp; Connector;\n\nconst createConnector = (node: GraphNode) =&gt; ({\n    node: node\n});\n\nconst createInputConnector:\n    (node: GraphNode) =&gt; InputConnector =\n    &lt;any&gt;createConnector;\n\nconst createOutputConnector:\n    (node: GraphNode) =&gt; OutputConnector =\n    &lt;any&gt;createConnector;\n\nlet node1 = createNode();\nlet node2 = createNode();\n\nlet input = createInputConnector(node2);\nlet output = createOutputConnector(node2);\n\nnode1.inputs.push(input); // works\nnode1.inputs.push(output); // error: Argument of type 'OutputConnector' is not assignable to parameter of type 'InputConnector'\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-smi\">InputConnectorIdentity</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Symbol</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"InputConnector\"</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-smi\">OutputConnectorIdentity</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Symbol</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"OutputConnector\"</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">GraphNode</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">inputs</span>: <span class=\"pl-smi\">InputConnector</span><span class=\"pl-kos\">[</span><span class=\"pl-kos\">]</span>\n    <span class=\"pl-c1\">outputs</span>: <span class=\"pl-smi\">OutputConnector</span><span class=\"pl-kos\">[</span><span class=\"pl-kos\">]</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-en\">createNode</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">GraphNode</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">(</span><span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">inputs</span>: <span class=\"pl-kos\">[</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">,</span>\n    <span class=\"pl-c1\">outputs</span>: <span class=\"pl-kos\">[</span><span class=\"pl-kos\">]</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Connector</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">node</span>: <span class=\"pl-smi\">GraphNode</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">InputConnector</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">InputConnectorIdentity</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">Connector</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">OutputConnector</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">OutputConnectorIdentity</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">Connector</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-en\">createConnector</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">node</span>: <span class=\"pl-smi\">GraphNode</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">(</span><span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">node</span>: <span class=\"pl-s1\">node</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">createInputConnector</span>:\n    <span class=\"pl-kos\">(</span><span class=\"pl-s1\">node</span>: <span class=\"pl-smi\">GraphNode</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-smi\">InputConnector</span> <span class=\"pl-c1\">=</span>\n    <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">any</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-s1\">createConnector</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">createOutputConnector</span>:\n    <span class=\"pl-kos\">(</span><span class=\"pl-s1\">node</span>: <span class=\"pl-smi\">GraphNode</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-smi\">OutputConnector</span> <span class=\"pl-c1\">=</span>\n    <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">any</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-s1\">createConnector</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">node1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">createNode</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">node2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">createNode</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">input</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">createInputConnector</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">node2</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">output</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">createOutputConnector</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">node2</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-s1\">node1</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">inputs</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">push</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">input</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// works</span>\n<span class=\"pl-s1\">node1</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">inputs</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">push</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">output</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error: Argument of type 'OutputConnector' is not assignable to parameter of type 'InputConnector'</span></pre></div>",
        "createdAt": "2018-04-15T21:00:29Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-381437628",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 8
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM4MTQ1MDY1OA==",
        "author": {
          "login": "aaronjensen"
        },
        "authorAssociation": "NONE",
        "body": "That's great @SimonMeskens, thanks for posting.\r\n\r\nUnless I'm mistaken, the `Symbol` creations will not get dead code eliminated by UglifyJS unless `pure_funcs=Symbol` is included, or if those symbols are created in a file that only exports types. In that case, typescript would probably strip them out, but I haven't tested it.",
        "bodyHTML": "<p dir=\"auto\">That's great <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a>, thanks for posting.</p>\n<p dir=\"auto\">Unless I'm mistaken, the <code class=\"notranslate\">Symbol</code> creations will not get dead code eliminated by UglifyJS unless <code class=\"notranslate\">pure_funcs=Symbol</code> is included, or if those symbols are created in a file that only exports types. In that case, typescript would probably strip them out, but I haven't tested it.</p>",
        "createdAt": "2018-04-16T00:31:19Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-381450658",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM4MTYwMzczOA==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "If you want to strip them out, this should work. It's basically equivalent, but with `declare` it's compile-time only.\r\n\r\n```TypeScript\r\ndeclare const InputConnectorIdentity: unique symbol\r\ndeclare const OutputConnectorIdentity: unique symbol\r\n```",
        "bodyHTML": "<p dir=\"auto\">If you want to strip them out, this should work. It's basically equivalent, but with <code class=\"notranslate\">declare</code> it's compile-time only.</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"declare const InputConnectorIdentity: unique symbol\ndeclare const OutputConnectorIdentity: unique symbol\"><pre class=\"notranslate\"><span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">InputConnectorIdentity</span>: <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">symbol</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">OutputConnectorIdentity</span>: <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">symbol</span></pre></div>",
        "createdAt": "2018-04-16T13:43:09Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-381603738",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 7
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM4MTY0NjkxNw==",
        "author": {
          "login": "aaronjensen"
        },
        "authorAssociation": "NONE",
        "body": "Ah, that's even nicer, thanks.",
        "bodyHTML": "<p dir=\"auto\">Ah, that's even nicer, thanks.</p>",
        "createdAt": "2018-04-16T15:32:02Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-381646917",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM5MzQ1NTc5Nw==",
        "author": {
          "login": "wesleyolis"
        },
        "authorAssociation": "NONE",
        "body": "How about introduction a new type checking modifier operator, that is implemented for type checking only. Which would allow the best of both worlds, nominal an structural typing paradigms.\r\n\r\nAs far as I know '$' is not used for specially many yet, so how about allowing $ donate use nominal type checking for the following use cases.\r\n\r\nI would prefer to have everything swapped around, but that could break alot of backwards compatibility, mabye it could be debated to have a global compiler and localised ts file setting\r\n\r\n## Use Cases\r\n\r\n### nominal variants \r\n#### assignment:\r\n$=\r\n#### call signature only:\r\n(index :$ {index :number} => void \r\n#### call signature and return:\r\n(index :$ {index :number} $=> void \r\n#### return: \r\n(index : {index :number} $=> void \r\n#### type, implies nominal should also be used were , unless explicitly cast away..\r\ntype test $= testing;\r\n#### variable, implies nominal should also be used were , unless explicitly cast away..\r\nconst var1 $= 'test'; \r\nlet var1 $= 'test'; \r\nreadonly var1 $= 'test'; \r\n\r\n### structural\r\n#### assignment:\r\n=\r\n#### call signature only:\r\n(index : {index :number} => void \r\n#### call signature and return:\r\n(index : {index :number} => void \r\n#### return: \r\n(index : {index :number} => void \r\n#### type \r\ntest = testing;\r\n#### variable\r\nconst var1 = 'test'; \r\nlet var1 = 'test'; \r\nreadonly var1 = 'test'; \r\n\r\n### Casting away nominal type checking\r\nFor each nominal declare type their is an additional generated structure type name. The same behaviour as for classes, were their is a generated interface..\r\nThe $ identify must always be used in a type definition and assignments, so that it is explicitly obvious as to how type checking is being performed.\r\n\r\n\r\ntype nTypeA $= {a : string};\r\ntype nTypeB $= {a : string};\r\ntype TypeA = $<NTypeNA> or $typeof NTypeNA\r\n\r\nconst varNa :$ nTypeStringA = {a:'test'}\r\nconst varNb :$ nTypeStringB = {a:'test'}\r\n\r\nconst varNa : typeof nTypeA = varNa; //OK allow casting\r\nconst varNb : typeof nTypeA = VarNb; //OK\r\n\r\nconst varNa : nTypeB = varNa; //OK allow casting\r\nconst varNb : nTypeA = VarNb; //OK\r\n\r\nconst varA :$ nTypeB = Na; // Error nominal type checking\r\nconst varB :$ nTypeA = Nb; // Error nominal type checking\r\n\r\nconst varNa : TypeA = varNb; //OK\r\nconst varNb : TypeA = VarNa; //OK\r\n",
        "bodyHTML": "<p dir=\"auto\">How about introduction a new type checking modifier operator, that is implemented for type checking only. Which would allow the best of both worlds, nominal an structural typing paradigms.</p>\n<p dir=\"auto\">As far as I know '$' is not used for specially many yet, so how about allowing $ donate use nominal type checking for the following use cases.</p>\n<p dir=\"auto\">I would prefer to have everything swapped around, but that could break alot of backwards compatibility, mabye it could be debated to have a global compiler and localised ts file setting</p>\n<h2 dir=\"auto\">Use Cases</h2>\n<h3 dir=\"auto\">nominal variants</h3>\n<h4 dir=\"auto\">assignment:</h4>\n<p dir=\"auto\">$=</p>\n<h4 dir=\"auto\">call signature only:</h4>\n<p dir=\"auto\">(index :$ {index :number} =&gt; void</p>\n<h4 dir=\"auto\">call signature and return:</h4>\n<p dir=\"auto\">(index :$ {index :number} $=&gt; void</p>\n<h4 dir=\"auto\">return:</h4>\n<p dir=\"auto\">(index : {index :number} $=&gt; void</p>\n<h4 dir=\"auto\">type, implies nominal should also be used were , unless explicitly cast away..</h4>\n<p dir=\"auto\">type test $= testing;</p>\n<h4 dir=\"auto\">variable, implies nominal should also be used were , unless explicitly cast away..</h4>\n<p dir=\"auto\">const var1 $= 'test';<br>\nlet var1 $= 'test';<br>\nreadonly var1 $= 'test';</p>\n<h3 dir=\"auto\">structural</h3>\n<h4 dir=\"auto\">assignment:</h4>\n<p dir=\"auto\">=</p>\n<h4 dir=\"auto\">call signature only:</h4>\n<p dir=\"auto\">(index : {index :number} =&gt; void</p>\n<h4 dir=\"auto\">call signature and return:</h4>\n<p dir=\"auto\">(index : {index :number} =&gt; void</p>\n<h4 dir=\"auto\">return:</h4>\n<p dir=\"auto\">(index : {index :number} =&gt; void</p>\n<h4 dir=\"auto\">type</h4>\n<p dir=\"auto\">test = testing;</p>\n<h4 dir=\"auto\">variable</h4>\n<p dir=\"auto\">const var1 = 'test';<br>\nlet var1 = 'test';<br>\nreadonly var1 = 'test';</p>\n<h3 dir=\"auto\">Casting away nominal type checking</h3>\n<p dir=\"auto\">For each nominal declare type their is an additional generated structure type name. The same behaviour as for classes, were their is a generated interface..<br>\nThe $ identify must always be used in a type definition and assignments, so that it is explicitly obvious as to how type checking is being performed.</p>\n<p dir=\"auto\">type nTypeA $= {a : string};<br>\ntype nTypeB $= {a : string};<br>\ntype TypeA = $ or $typeof NTypeNA</p>\n<p dir=\"auto\">const varNa :$ nTypeStringA = {a:'test'}<br>\nconst varNb :$ nTypeStringB = {a:'test'}</p>\n<p dir=\"auto\">const varNa : typeof nTypeA = varNa; //OK allow casting<br>\nconst varNb : typeof nTypeA = VarNb; //OK</p>\n<p dir=\"auto\">const varNa : nTypeB = varNa; //OK allow casting<br>\nconst varNb : nTypeA = VarNb; //OK</p>\n<p dir=\"auto\">const varA :$ nTypeB = Na; // Error nominal type checking<br>\nconst varB :$ nTypeA = Nb; // Error nominal type checking</p>\n<p dir=\"auto\">const varNa : TypeA = varNb; //OK<br>\nconst varNb : TypeA = VarNa; //OK</p>",
        "createdAt": "2018-05-31T08:31:42Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-393455797",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM5NTE5MDY4Mg==",
        "author": {
          "login": "fenduru"
        },
        "authorAssociation": "NONE",
        "body": "I tried experimenting with modifying the TS compiler a couple months ago, but I got stuck due to a lack compiler domain knowledge. However I feel like the `unique` keyword gives us exactly what is needed for nominal typing. Today it is restricted to Symbols, however from my (admittedly naive) understanding of the code, it seems like this limitation is not a fundamental one (there are simply checks to ensure you're only using the keyword before a symbol).\r\n\r\nAre there actual limitations from allowing users to write:\r\n\r\n```ts\r\ntype NominalNumber = unique number;\r\n```",
        "bodyHTML": "<p dir=\"auto\">I tried experimenting with modifying the TS compiler a couple months ago, but I got stuck due to a lack compiler domain knowledge. However I feel like the <code class=\"notranslate\">unique</code> keyword gives us exactly what is needed for nominal typing. Today it is restricted to Symbols, however from my (admittedly naive) understanding of the code, it seems like this limitation is not a fundamental one (there are simply checks to ensure you're only using the keyword before a symbol).</p>\n<p dir=\"auto\">Are there actual limitations from allowing users to write:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type NominalNumber = unique number;\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">NominalNumber</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">number</span><span class=\"pl-kos\">;</span></pre></div>",
        "createdAt": "2018-06-06T19:45:28Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-395190682",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM5NTIyNzkxNg==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "The fact that it doesn't make that much sense at runtime, if I had to guess. Symbols are special in that you get a new one every time (unless you're using `.for()`), and the use of `unique symbol` is restricted to those locations where the compiler can assume the runtime value won't change. I suppose you could make a case for id generators retuning unique number or string? But that meaning isn't really related to this issue.\r\n\r\nIn any case, being able to declare a type as being unique (ie nominal) isn't really the problem, it's that it's not clear how you should be able to use such a type, and what benefit does it give?",
        "bodyHTML": "<p dir=\"auto\">The fact that it doesn't make that much sense at runtime, if I had to guess. Symbols are special in that you get a new one every time (unless you're using <code class=\"notranslate\">.for()</code>), and the use of <code class=\"notranslate\">unique symbol</code> is restricted to those locations where the compiler can assume the runtime value won't change. I suppose you could make a case for id generators retuning unique number or string? But that meaning isn't really related to this issue.</p>\n<p dir=\"auto\">In any case, being able to declare a type as being unique (ie nominal) isn't really the problem, it's that it's not clear how you should be able to use such a type, and what benefit does it give?</p>",
        "createdAt": "2018-06-06T22:00:03Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-395227916",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM5NTIzMjkzMA==",
        "author": {
          "login": "fenduru"
        },
        "authorAssociation": "NONE",
        "body": "@simonbuchan ID generators are one of the most common uses, and the one I'm particularly interested, so I'm not sure what you mean by\r\n\r\n> it's not clear how you should be able to use such a type, and what benefit does it give?\r\n\r\nConstruction of the nominal type would need to either special case variable definitions (`const foo: NominalString = 'string'`) or users would need to explicitly cast (though that has the unfortunate downside of being unsafe). I'd personally be happy to take the downside of explicit casting, as it would allow me to \"be careful\" in one place, rather than all callsites.\r\n\r\nI currently accomplish this with code along the lines of:\r\n\r\n```ts\r\ntype NominalStringA = string & { __nominal?: unique symbol };\r\ntype NominalStringB = string & { __nominal?: unique symbol };\r\n\r\nlet a: NominalStringA = 'a';\r\nlet b: NominalStringB = 'b';\r\na = b; // error\r\n```\r\n\r\nThis *kind of* works, as it at least prevents me from passing one nominal type where another is expected. It would let you pass a `string` to a `function(x: NominalStringA)` which is why assignment works, but it is at least better than nothing. All of my nominal types also need to use the same `__nominal` key as having that key's type conflict is how the approach works. (In practice I actually use another `unique symbol` as the key so `__nominal` doesn't show up in my editor completion)",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/simonbuchan/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/simonbuchan\">@simonbuchan</a> ID generators are one of the most common uses, and the one I'm particularly interested, so I'm not sure what you mean by</p>\n<blockquote>\n<p dir=\"auto\">it's not clear how you should be able to use such a type, and what benefit does it give?</p>\n</blockquote>\n<p dir=\"auto\">Construction of the nominal type would need to either special case variable definitions (<code class=\"notranslate\">const foo: NominalString = 'string'</code>) or users would need to explicitly cast (though that has the unfortunate downside of being unsafe). I'd personally be happy to take the downside of explicit casting, as it would allow me to \"be careful\" in one place, rather than all callsites.</p>\n<p dir=\"auto\">I currently accomplish this with code along the lines of:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type NominalStringA = string &amp; { __nominal?: unique symbol };\ntype NominalStringB = string &amp; { __nominal?: unique symbol };\n\nlet a: NominalStringA = 'a';\nlet b: NominalStringB = 'b';\na = b; // error\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">NominalStringA</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">string</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">__nominal</span>?: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">NominalStringB</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">string</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">__nominal</span>?: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">a</span>: <span class=\"pl-smi\">NominalStringA</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'a'</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">b</span>: <span class=\"pl-smi\">NominalStringB</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'b'</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">a</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">b</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error</span></pre></div>\n<p dir=\"auto\">This <em>kind of</em> works, as it at least prevents me from passing one nominal type where another is expected. It would let you pass a <code class=\"notranslate\">string</code> to a <code class=\"notranslate\">function(x: NominalStringA)</code> which is why assignment works, but it is at least better than nothing. All of my nominal types also need to use the same <code class=\"notranslate\">__nominal</code> key as having that key's type conflict is how the approach works. (In practice I actually use another <code class=\"notranslate\">unique symbol</code> as the key so <code class=\"notranslate\">__nominal</code> doesn't show up in my editor completion)</p>",
        "createdAt": "2018-06-06T22:22:37Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-395232930",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM5NTIzNTY3Ng==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "I mean what operations should be permitted by such a type? Can you do `a + a`? `a.trim()`? Is that still `NominalStringA`, or is it `string`? `console.log(a)`? Can you `a.concat(a)`? `a.concat('foo')`? Can you assign a non-literal `string` to a nominal string?\r\n\r\nMore importantly by far, is your answer to each of these questions going to be something generally useful, or only the specific case of ID generators? Will adding this block adding a more general solution later? In which situations does it prevent bugs? Where does it *hide* bugs? (e.g. casting) And so on...\r\n\r\nThis is just for the most simple case of nominal primitive types - when you get nominal object types (nominal function types?) things can get much weirder, since you have questions of how subtyping works, including variance.",
        "bodyHTML": "<p dir=\"auto\">I mean what operations should be permitted by such a type? Can you do <code class=\"notranslate\">a + a</code>? <code class=\"notranslate\">a.trim()</code>? Is that still <code class=\"notranslate\">NominalStringA</code>, or is it <code class=\"notranslate\">string</code>? <code class=\"notranslate\">console.log(a)</code>? Can you <code class=\"notranslate\">a.concat(a)</code>? <code class=\"notranslate\">a.concat('foo')</code>? Can you assign a non-literal <code class=\"notranslate\">string</code> to a nominal string?</p>\n<p dir=\"auto\">More importantly by far, is your answer to each of these questions going to be something generally useful, or only the specific case of ID generators? Will adding this block adding a more general solution later? In which situations does it prevent bugs? Where does it <em>hide</em> bugs? (e.g. casting) And so on...</p>\n<p dir=\"auto\">This is just for the most simple case of nominal primitive types - when you get nominal object types (nominal function types?) things can get much weirder, since you have questions of how subtyping works, including variance.</p>",
        "createdAt": "2018-06-06T22:36:38Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-395235676",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM5NTI0OTA4OA==",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "FYI since nominal types would be a bit of a problem with node_module style scoped lookups, I settled with branded types\r\n\r\nhttps://goo.gl/3Jjtp4\r\n\r\n```typescript\r\nfunction branded<T, Brand>() {\r\n    return class Type {\r\n        private value: Type;\r\n        private '__ kind': Brand;\r\n        static toBranded(t: T) { return t as any as Type; }\r\n        static unbrand(b: Type) { return b as any as T }\r\n        static Type: Type;\r\n    }\r\n}\r\n\r\n\r\nlet OrderId = branded<string, 'OrderId'>()\r\ntype OrderId = typeof OrderId.Type;\r\n\r\nlet x = OrderId.toBranded('someUuid')\r\nlet y = 'someString';\r\nlet b1 = y == x; // generates error\r\nlet b2 = y == OrderId.unbrand(x)\r\n\r\nlet m: Map<OrderId, string> = new Map;\r\n\r\nm.set(y, '1')\r\nm.set(x, '2')\r\n```",
        "bodyHTML": "<p dir=\"auto\">FYI since nominal types would be a bit of a problem with node_module style scoped lookups, I settled with branded types</p>\n<p dir=\"auto\"><a href=\"https://goo.gl/3Jjtp4\" rel=\"nofollow\">https://goo.gl/3Jjtp4</a></p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"function branded&lt;T, Brand&gt;() {\n    return class Type {\n        private value: Type;\n        private '__ kind': Brand;\n        static toBranded(t: T) { return t as any as Type; }\n        static unbrand(b: Type) { return b as any as T }\n        static Type: Type;\n    }\n}\n\n\nlet OrderId = branded&lt;string, 'OrderId'&gt;()\ntype OrderId = typeof OrderId.Type;\n\nlet x = OrderId.toBranded('someUuid')\nlet y = 'someString';\nlet b1 = y == x; // generates error\nlet b2 = y == OrderId.unbrand(x)\n\nlet m: Map&lt;OrderId, string&gt; = new Map;\n\nm.set(y, '1')\nm.set(x, '2')\"><pre class=\"notranslate\"><span class=\"pl-k\">function</span> <span class=\"pl-en\">branded</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-c1\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-k\">class</span> <span class=\"pl-smi\">Type</span> <span class=\"pl-kos\">{</span>\n        <span class=\"pl-k\">private</span> <span class=\"pl-c1\">value</span>: <span class=\"pl-smi\">Type</span><span class=\"pl-kos\">;</span>\n        <span class=\"pl-k\">private</span> <span class=\"pl-s\">'__ kind'</span>: <span class=\"pl-smi\">Brand</span><span class=\"pl-kos\">;</span>\n        <span class=\"pl-k\">static</span> <span class=\"pl-en\">toBranded</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">t</span>: <span class=\"pl-smi\">T</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">return</span> <span class=\"pl-s1\">t</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">any</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Type</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span>\n        <span class=\"pl-k\">static</span> <span class=\"pl-en\">unbrand</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">b</span>: <span class=\"pl-smi\">Type</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">return</span> <span class=\"pl-s1\">b</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">any</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">T</span> <span class=\"pl-kos\">}</span>\n        <span class=\"pl-k\">static</span> <span class=\"pl-c1\">Type</span>: <span class=\"pl-smi\">Type</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span>\n\n\n<span class=\"pl-k\">let</span> <span class=\"pl-smi\">OrderId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">branded</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'OrderId'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">OrderId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">OrderId</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">Type</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">OrderId</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">toBranded</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'someUuid'</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">y</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'someString'</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">b1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">y</span> <span class=\"pl-c1\">==</span> <span class=\"pl-s1\">x</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// generates error</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">b2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">y</span> <span class=\"pl-c1\">==</span> <span class=\"pl-smi\">OrderId</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">unbrand</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span><span class=\"pl-kos\">)</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">m</span>: <span class=\"pl-smi\">Map</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">OrderId</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">string</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Map</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-s1\">m</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">set</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">y</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'1'</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-s1\">m</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">set</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'2'</span><span class=\"pl-kos\">)</span></pre></div>",
        "createdAt": "2018-06-06T23:51:29Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-395249088",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM5NTI1NTYxMg==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "That's a box, not a brand, since it allocates a new object, but sure, you can do that too.",
        "bodyHTML": "<p dir=\"auto\">That's a box, not a brand, since it allocates a new object, but sure, you can do that too.</p>",
        "createdAt": "2018-06-07T00:32:16Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-395255612",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM5NTI4MDgxNg==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "My primary use cases fall into one of two categories:\r\n\r\n1. I have a type whose entire structure, including `typeof`, is opaque and an implementation detail. This comes up a little more frequently for me than for many, since my programs are usually a little more data-driven. For one concrete example, [this module](https://gist.github.com/isiahmeadows/4aa871f66ea0cda585bcb4c7e4cb9540) packs all its data into a single 32-bit integer. I can't possibly type it except as a nominal opaque type that happens to support `>`/`<`/`===`/etc.\r\n\r\n2. I return what's effectively just an ID. I do that *pervasively* in [these](https://github.com/isiahmeadows/invoke-parallel/blob/master/lib/child.js) [two](https://github.com/isiahmeadows/invoke-parallel/blob/master/lib/worker-state.js) modules, with IDs orchestrated via [this module](https://github.com/isiahmeadows/invoke-parallel/blob/master/lib/id-pool.js). I also frequently do it in other scenarios where data handling is critical.",
        "bodyHTML": "<p dir=\"auto\">My primary use cases fall into one of two categories:</p>\n<ol dir=\"auto\">\n<li>\n<p dir=\"auto\">I have a type whose entire structure, including <code class=\"notranslate\">typeof</code>, is opaque and an implementation detail. This comes up a little more frequently for me than for many, since my programs are usually a little more data-driven. For one concrete example, <a href=\"https://gist.github.com/isiahmeadows/4aa871f66ea0cda585bcb4c7e4cb9540\">this module</a> packs all its data into a single 32-bit integer. I can't possibly type it except as a nominal opaque type that happens to support <code class=\"notranslate\">&gt;</code>/<code class=\"notranslate\">&lt;</code>/<code class=\"notranslate\">===</code>/etc.</p>\n</li>\n<li>\n<p dir=\"auto\">I return what's effectively just an ID. I do that <em>pervasively</em> in <a href=\"https://github.com/isiahmeadows/invoke-parallel/blob/master/lib/child.js\">these</a> <a href=\"https://github.com/isiahmeadows/invoke-parallel/blob/master/lib/worker-state.js\">two</a> modules, with IDs orchestrated via <a href=\"https://github.com/isiahmeadows/invoke-parallel/blob/master/lib/id-pool.js\">this module</a>. I also frequently do it in other scenarios where data handling is critical.</p>\n</li>\n</ol>",
        "createdAt": "2018-06-07T03:26:10Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-395280816",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM5NTI4MTAxOA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@simonbuchan Only during type instantiation. The `toBranded` and `unbrand` methods are the important ones here, not the constructor itself.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/simonbuchan/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/simonbuchan\">@simonbuchan</a> Only during type instantiation. The <code class=\"notranslate\">toBranded</code> and <code class=\"notranslate\">unbrand</code> methods are the important ones here, not the constructor itself.</p>",
        "createdAt": "2018-06-07T03:27:55Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-395281018",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM5NTI4MzIyMw==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "Yes, but that's what a box is :) [Java](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html) and [C#](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing) both do autoboxing (slightly differently), but you can box a primitive (or other type) manually too.\r\n\r\nAs [mentioned earlier in this thread](https://github.com/Microsoft/TypeScript/issues/202#issuecomment-352185916), opaque types seem like they would satisfy many of these suggestions, if done TS should probably do that compatible with [the way flow does it](https://flow.org/en/docs/types/opaque-types/), but:\r\n- opaque types might not satisfy some of these other requests? I haven't reviewed the thread recently.\r\n- I don't think TS currently treats any types differently depending on context?",
        "bodyHTML": "<p dir=\"auto\">Yes, but that's what a box is :) <a href=\"https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html\" rel=\"nofollow\">Java</a> and <a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing\" rel=\"nofollow\">C#</a> both do autoboxing (slightly differently), but you can box a primitive (or other type) manually too.</p>\n<p dir=\"auto\">As <a href=\"https://github.com/Microsoft/TypeScript/issues/202#issuecomment-352185916\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">mentioned earlier in this thread</a>, opaque types seem like they would satisfy many of these suggestions, if done TS should probably do that compatible with <a href=\"https://flow.org/en/docs/types/opaque-types/\" rel=\"nofollow\">the way flow does it</a>, but:</p>\n<ul dir=\"auto\">\n<li>opaque types might not satisfy some of these other requests? I haven't reviewed the thread recently.</li>\n<li>I don't think TS currently treats any types differently depending on context?</li>\n</ul>",
        "createdAt": "2018-06-07T03:43:39Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-395283223",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM5NTI4MzQ0NQ==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@spion @simonbuchan [I made it a bit lower-memory](http://www.typescriptlang.org/play/#src=interface%20Branded%3CT%2C%20Type%3E%20%7B%0D%0A%20%20%20%20'__%20to%20brand'(t%3A%20T)%3A%20Type%3B%0D%0A%20%20%20%20'__%20from%20brand'(b%3A%20Type)%3A%20T%3B%0D%0A%20%20%20%20T%3A%20T%3B%0D%0A%20%20%20%20Type%3A%20Type%3B%0D%0A%7D%0D%0A%0D%0Afunction%20toBranded%3CT%2C%20Type%3E(b%3A%20Branded%3CT%2C%20Type%3E%2C%20value%3A%20T)%20%7B%0D%0A%20%20%20%20return%20value%20as%20any%20as%20Type%3B%0D%0A%7D%0D%0A%0D%0Afunction%20fromBranded%3CT%2C%20Type%3E(b%3A%20Branded%3CT%2C%20Type%3E%2C%20branded%3A%20Type)%20%7B%0D%0A%20%20%20%20return%20branded%20as%20any%20as%20T%3B%0D%0A%7D%0D%0A%0D%0Afunction%20branded%3CT%2C%20Brand%3E()%20%7B%0D%0A%20%20%20%20interface%20Type%20%7B%20value%3A%20Type%3B%20'__%20kind'%3A%20Brand%3B%20%7D%0D%0A%20%20%20%20return%20undefined%20as%20Branded%3CT%2C%20Type%3E%3B%0D%0A%7D%0D%0A%0D%0A%0D%0Alet%20OrderId%20%3D%20branded%3Cstring%2C%20'OrderId'%3E()%0D%0Atype%20OrderId%20%3D%20typeof%20OrderId.Type%3B%0D%0A%0D%0Alet%20x%20%3D%20toBranded(OrderId%2C%20'someUuid')%0D%0Alet%20y%20%3D%20'someString'%3B%0D%0Alet%20b1%20%3D%20y%20%3D%3D%20x%3B%0D%0Alet%20b2%20%3D%20y%20%3D%3D%20fromBranded(OrderId%2C%20x)%0D%0A%0D%0Alet%20m%3A%20Map%3COrderId%2C%20string%3E%20%3D%20new%20Map%3B%0D%0A%0D%0Am.set(y%2C%20'1')%0D%0Am.set(x%2C%20'2')%0D%0A), so it doesn't require any runtime allocation at all (it's trivially inlinable).\r\n\r\n**Edit:** muffed up the link.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/spion/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/spion\">@spion</a> <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/simonbuchan/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/simonbuchan\">@simonbuchan</a> <a href=\"http://www.typescriptlang.org/play/#src=interface%20Branded%3CT%2C%20Type%3E%20%7B%0D%0A%20%20%20%20'__%20to%20brand'(t%3A%20T)%3A%20Type%3B%0D%0A%20%20%20%20'__%20from%20brand'(b%3A%20Type)%3A%20T%3B%0D%0A%20%20%20%20T%3A%20T%3B%0D%0A%20%20%20%20Type%3A%20Type%3B%0D%0A%7D%0D%0A%0D%0Afunction%20toBranded%3CT%2C%20Type%3E(b%3A%20Branded%3CT%2C%20Type%3E%2C%20value%3A%20T)%20%7B%0D%0A%20%20%20%20return%20value%20as%20any%20as%20Type%3B%0D%0A%7D%0D%0A%0D%0Afunction%20fromBranded%3CT%2C%20Type%3E(b%3A%20Branded%3CT%2C%20Type%3E%2C%20branded%3A%20Type)%20%7B%0D%0A%20%20%20%20return%20branded%20as%20any%20as%20T%3B%0D%0A%7D%0D%0A%0D%0Afunction%20branded%3CT%2C%20Brand%3E()%20%7B%0D%0A%20%20%20%20interface%20Type%20%7B%20value%3A%20Type%3B%20'__%20kind'%3A%20Brand%3B%20%7D%0D%0A%20%20%20%20return%20undefined%20as%20Branded%3CT%2C%20Type%3E%3B%0D%0A%7D%0D%0A%0D%0A%0D%0Alet%20OrderId%20%3D%20branded%3Cstring%2C%20'OrderId'%3E()%0D%0Atype%20OrderId%20%3D%20typeof%20OrderId.Type%3B%0D%0A%0D%0Alet%20x%20%3D%20toBranded(OrderId%2C%20'someUuid')%0D%0Alet%20y%20%3D%20'someString'%3B%0D%0Alet%20b1%20%3D%20y%20%3D%3D%20x%3B%0D%0Alet%20b2%20%3D%20y%20%3D%3D%20fromBranded(OrderId%2C%20x)%0D%0A%0D%0Alet%20m%3A%20Map%3COrderId%2C%20string%3E%20%3D%20new%20Map%3B%0D%0A%0D%0Am.set(y%2C%20'1')%0D%0Am.set(x%2C%20'2')%0D%0A\" rel=\"nofollow\">I made it a bit lower-memory</a>, so it doesn't require any runtime allocation at all (it's trivially inlinable).</p>\n<p dir=\"auto\"><strong>Edit:</strong> muffed up the link.</p>",
        "createdAt": "2018-06-07T03:45:20Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-395283445",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM5NTI4Mzc0Nw==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@simonbuchan There's no \"autoboxing\" involved. Type instantiation is analogous to class instantiation here, not *value* instantiation.\r\n\r\nI do want something similar to what Flow has, either way. As long as I can unsafely cast it into its component type (or at least safely cast it within the same file), I'm happy.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/simonbuchan/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/simonbuchan\">@simonbuchan</a> There's no \"autoboxing\" involved. Type instantiation is analogous to class instantiation here, not <em>value</em> instantiation.</p>\n<p dir=\"auto\">I do want something similar to what Flow has, either way. As long as I can unsafely cast it into its component type (or at least safely cast it within the same file), I'm happy.</p>",
        "createdAt": "2018-06-07T03:47:15Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-395283747",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM5NTI4NDQyMA==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "Yes, that's now no longer boxing, but your types are a bit messed up, claiming it has a `T` property with the value, which it doesn't. There's many many many many, suggestions for branding types in this thread!",
        "bodyHTML": "<p dir=\"auto\">Yes, that's now no longer boxing, but your types are a bit messed up, claiming it has a <code class=\"notranslate\">T</code> property with the value, which it doesn't. There's many many many many, suggestions for branding types in this thread!</p>",
        "createdAt": "2018-06-07T03:52:17Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-395284420",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM5NTI4NTgyNw==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@simonbuchan I'm not afraid to lie at the type level for better static verification, and I've done plenty of times in TypeScript. I've yet to see a workaround here for adding sufficiently \"opaque\" types that doesn't require lying about types to some extent. This even includes @spion's workaround which fails to implement `static type: Type` correctly.\r\n\r\nAs long as you know not to actually try to use it at the value level, you *should* be good. (I've yet to run into a case where it became a real problem, and it's not especially common to want to store values *with* their brands.)",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/simonbuchan/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/simonbuchan\">@simonbuchan</a> I'm not afraid to lie at the type level for better static verification, and I've done plenty of times in TypeScript. I've yet to see a workaround here for adding sufficiently \"opaque\" types that doesn't require lying about types to some extent. This even includes <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/spion/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/spion\">@spion</a>'s workaround which fails to implement <code class=\"notranslate\">static type: Type</code> correctly.</p>\n<p dir=\"auto\">As long as you know not to actually try to use it at the value level, you <em>should</em> be good. (I've yet to run into a case where it became a real problem, and it's not especially common to want to store values <em>with</em> their brands.)</p>",
        "createdAt": "2018-06-07T04:02:39Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-395285827",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM5NTI4NzgwOA==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "Sure, but since you're casting anyway, you don't need the value property, since it doesn't actually use it.",
        "bodyHTML": "<p dir=\"auto\">Sure, but since you're casting anyway, you don't need the value property, since it doesn't actually use it.</p>",
        "createdAt": "2018-06-07T04:18:17Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-395287808",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM5NTI5NjAzNw==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@simonbuchan [True, for the invariants it checks](http://www.typescriptlang.org/play/#src=interface%20Branded%3CT%2C%20Type%3E%20%7B%0D%0A%20%20%20%20'__%20to%20brand'(t%3A%20T)%3A%20Type%3B%0D%0A%20%20%20%20'__%20from%20brand'(b%3A%20Type)%3A%20T%3B%0D%0A%20%20%20%20T%3A%20T%3B%0D%0A%20%20%20%20Type%3A%20Type%3B%0D%0A%7D%0D%0A%0D%0Afunction%20toBranded%3CT%2C%20Type%3E(b%3A%20Branded%3CT%2C%20Type%3E%2C%20value%3A%20T)%20%7B%0D%0A%20%20%20%20return%20value%20as%20any%20as%20Type%3B%0D%0A%7D%0D%0A%0D%0Afunction%20fromBranded%3CT%2C%20Type%3E(b%3A%20Branded%3CT%2C%20Type%3E%2C%20branded%3A%20Type)%20%7B%0D%0A%20%20%20%20return%20branded%20as%20any%20as%20T%3B%0D%0A%7D%0D%0A%0D%0Afunction%20branded%3CT%2C%20Brand%3E()%20%7B%0D%0A%20%20%20%20interface%20Type%20%7B%20'__%20kind'%3A%20Brand%3B%20%7D%0D%0A%20%20%20%20return%20undefined%20as%20Branded%3CT%2C%20Type%3E%3B%0D%0A%7D%0D%0A%0D%0A%0D%0Alet%20OrderId%20%3D%20branded%3Cstring%2C%20'OrderId'%3E()%0D%0Atype%20OrderId%20%3D%20typeof%20OrderId.Type%3B%0D%0A%0D%0Alet%20x%20%3D%20toBranded(OrderId%2C%20'someUuid')%0D%0Alet%20y%20%3D%20'someString'%3B%0D%0Alet%20b1%20%3D%20y%20%3D%3D%20x%3B%0D%0Alet%20b2%20%3D%20y%20%3D%3D%20fromBranded(OrderId%2C%20x)%0D%0A%0D%0Alet%20m%3A%20Map%3COrderId%2C%20string%3E%20%3D%20new%20Map%3B%0D%0A%0D%0Am.set(y%2C%20'1')%0D%0Am.set(x%2C%20'2')%0D%0A). Neither does the [original version](http://www.typescriptlang.org/play/#src=%0D%0A%0D%0Afunction%20branded%3CT%2C%20Brand%3E()%20%7B%0D%0A%20%20%20%20return%20class%20Type%20%7B%0D%0A%20%20%20%20%20%20%20%20private%20'__%20kind'%3A%20Brand%3B%0D%0A%20%20%20%20%20%20%20%20static%20toBranded(t%3A%20T)%20%7B%20return%20t%20as%20any%20as%20Type%3B%20%7D%0D%0A%20%20%20%20%20%20%20%20static%20fromBranded(b%3A%20Type)%20%7B%20return%20b%20as%20any%20as%20T%20%7D%0D%0A%20%20%20%20%20%20%20%20static%20Type%3A%20Type%3B%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0A%0D%0Alet%20OrderId%20%3D%20branded%3Cstring%2C%20'OrderId'%3E()%0D%0Atype%20OrderId%20%3D%20typeof%20OrderId.Type%3B%0D%0A%0D%0Alet%20x%20%3D%20OrderId.toBranded('someUuid')%0D%0Alet%20y%20%3D%20'someString'%3B%0D%0Alet%20b1%20%3D%20y%20%3D%3D%20x%3B%0D%0Alet%20b2%20%3D%20y%20%3D%3D%20OrderId.fromBranded(x)%0D%0A%0D%0Alet%20m%3A%20Map%3COrderId%2C%20string%3E%20%3D%20new%20Map%3B%0D%0A%0D%0Am.set(y%2C%20'1')%0D%0Am.set(x%2C%20'2')%0D%0A), however.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/simonbuchan/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/simonbuchan\">@simonbuchan</a> <a href=\"http://www.typescriptlang.org/play/#src=interface%20Branded%3CT%2C%20Type%3E%20%7B%0D%0A%20%20%20%20'__%20to%20brand'(t%3A%20T)%3A%20Type%3B%0D%0A%20%20%20%20'__%20from%20brand'(b%3A%20Type)%3A%20T%3B%0D%0A%20%20%20%20T%3A%20T%3B%0D%0A%20%20%20%20Type%3A%20Type%3B%0D%0A%7D%0D%0A%0D%0Afunction%20toBranded%3CT%2C%20Type%3E(b%3A%20Branded%3CT%2C%20Type%3E%2C%20value%3A%20T)%20%7B%0D%0A%20%20%20%20return%20value%20as%20any%20as%20Type%3B%0D%0A%7D%0D%0A%0D%0Afunction%20fromBranded%3CT%2C%20Type%3E(b%3A%20Branded%3CT%2C%20Type%3E%2C%20branded%3A%20Type)%20%7B%0D%0A%20%20%20%20return%20branded%20as%20any%20as%20T%3B%0D%0A%7D%0D%0A%0D%0Afunction%20branded%3CT%2C%20Brand%3E()%20%7B%0D%0A%20%20%20%20interface%20Type%20%7B%20'__%20kind'%3A%20Brand%3B%20%7D%0D%0A%20%20%20%20return%20undefined%20as%20Branded%3CT%2C%20Type%3E%3B%0D%0A%7D%0D%0A%0D%0A%0D%0Alet%20OrderId%20%3D%20branded%3Cstring%2C%20'OrderId'%3E()%0D%0Atype%20OrderId%20%3D%20typeof%20OrderId.Type%3B%0D%0A%0D%0Alet%20x%20%3D%20toBranded(OrderId%2C%20'someUuid')%0D%0Alet%20y%20%3D%20'someString'%3B%0D%0Alet%20b1%20%3D%20y%20%3D%3D%20x%3B%0D%0Alet%20b2%20%3D%20y%20%3D%3D%20fromBranded(OrderId%2C%20x)%0D%0A%0D%0Alet%20m%3A%20Map%3COrderId%2C%20string%3E%20%3D%20new%20Map%3B%0D%0A%0D%0Am.set(y%2C%20'1')%0D%0Am.set(x%2C%20'2')%0D%0A\" rel=\"nofollow\">True, for the invariants it checks</a>. Neither does the <a href=\"http://www.typescriptlang.org/play/#src=%0D%0A%0D%0Afunction%20branded%3CT%2C%20Brand%3E()%20%7B%0D%0A%20%20%20%20return%20class%20Type%20%7B%0D%0A%20%20%20%20%20%20%20%20private%20'__%20kind'%3A%20Brand%3B%0D%0A%20%20%20%20%20%20%20%20static%20toBranded(t%3A%20T)%20%7B%20return%20t%20as%20any%20as%20Type%3B%20%7D%0D%0A%20%20%20%20%20%20%20%20static%20fromBranded(b%3A%20Type)%20%7B%20return%20b%20as%20any%20as%20T%20%7D%0D%0A%20%20%20%20%20%20%20%20static%20Type%3A%20Type%3B%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0A%0D%0Alet%20OrderId%20%3D%20branded%3Cstring%2C%20'OrderId'%3E()%0D%0Atype%20OrderId%20%3D%20typeof%20OrderId.Type%3B%0D%0A%0D%0Alet%20x%20%3D%20OrderId.toBranded('someUuid')%0D%0Alet%20y%20%3D%20'someString'%3B%0D%0Alet%20b1%20%3D%20y%20%3D%3D%20x%3B%0D%0Alet%20b2%20%3D%20y%20%3D%3D%20OrderId.fromBranded(x)%0D%0A%0D%0Alet%20m%3A%20Map%3COrderId%2C%20string%3E%20%3D%20new%20Map%3B%0D%0A%0D%0Am.set(y%2C%20'1')%0D%0Am.set(x%2C%20'2')%0D%0A\" rel=\"nofollow\">original version</a>, however.</p>",
        "createdAt": "2018-06-07T05:18:09Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-395296037",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDM5NTMyMTA1Mw==",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "If you look at it carefully, it is in fact a brand and not a box. The class stuff is there mainly to hide the machinery using `private` (e.g. the type has no visible .value property)",
        "bodyHTML": "<p dir=\"auto\">If you look at it carefully, it is in fact a brand and not a box. The class stuff is there mainly to hide the machinery using <code class=\"notranslate\">private</code> (e.g. the type has no visible .value property)</p>",
        "createdAt": "2018-06-07T07:28:18Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-395321053",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQwNDAxMjY2Nw==",
        "author": {
          "login": "nafg"
        },
        "authorAssociation": "NONE",
        "body": "cf. scala opaque type aliases, I think\r\n\r\nhttps://docs.scala-lang.org/sips/opaque-types.html",
        "bodyHTML": "<p dir=\"auto\">cf. scala opaque type aliases, I think</p>\n<p dir=\"auto\"><a href=\"https://docs.scala-lang.org/sips/opaque-types.html\" rel=\"nofollow\">https://docs.scala-lang.org/sips/opaque-types.html</a></p>",
        "createdAt": "2018-07-11T01:08:20Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-404012667",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQwNDA1NzQ5OQ==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@nafg I like that concept. That's a good idea: internally treat them as aliases, but export them as opaque nominal types.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/nafg/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/nafg\">@nafg</a> I like that concept. That's a good idea: internally treat them as aliases, but export them as opaque nominal types.</p>",
        "createdAt": "2018-07-11T06:17:48Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-404057499",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQwNDU3Mzg0Mg==",
        "author": {
          "login": "mohsen1"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "why instead of marking type declarations nominal you're not considering making type assignment and assertions nominal with a new syntax? \r\n\r\n```ts\r\ntype A = {}\r\ntype B = {}\r\n\r\nvar a := A = {};\r\nvar b := B = {};\r\n\r\na = b; // Error\r\n\r\nvar aa : A = {};\r\nvar bb : B = {};\r\naa = bb // OK\r\n```\r\n\r\nAlternative syntax: \r\n```ts\r\nvar a : nominal A = {}\r\n```",
        "bodyHTML": "<p dir=\"auto\">why instead of marking type declarations nominal you're not considering making type assignment and assertions nominal with a new syntax?</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type A = {}\ntype B = {}\n\nvar a := A = {};\nvar b := B = {};\n\na = b; // Error\n\nvar aa : A = {};\nvar bb : B = {};\naa = bb // OK\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">A</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">B</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">var</span> <span class=\"pl-s1\">a</span> :<span class=\"pl-c1\">=</span> <span class=\"pl-smi\">A</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">var</span> <span class=\"pl-s1\">b</span> :<span class=\"pl-c1\">=</span> <span class=\"pl-smi\">B</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-s1\">a</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">b</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// Error</span>\n\n<span class=\"pl-k\">var</span> <span class=\"pl-s1\">aa</span> : <span class=\"pl-smi\">A</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">var</span> <span class=\"pl-s1\">bb</span> : <span class=\"pl-smi\">B</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">aa</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">bb</span> <span class=\"pl-c\">// OK</span></pre></div>\n<p dir=\"auto\">Alternative syntax:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"var a : nominal A = {}\"><pre class=\"notranslate\"><span class=\"pl-k\">var</span> <span class=\"pl-s1\">a</span> : <span class=\"pl-smi\">nominal</span> <span class=\"pl-smi\">A</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span></pre></div>",
        "createdAt": "2018-07-12T16:37:14Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-404573842",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQwNDYwNjM1Mg==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@mohsen1 The whole point of nominal typing is to *force* users to stray away from relying on implementation details, not to *enable* them to avoid it by convention (which is already possible by just not accessing certain properties).",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/mohsen1/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/mohsen1\">@mohsen1</a> The whole point of nominal typing is to <em>force</em> users to stray away from relying on implementation details, not to <em>enable</em> them to avoid it by convention (which is already possible by just not accessing certain properties).</p>",
        "createdAt": "2018-07-12T18:26:49Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-404606352",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQwNDg2ODE5Nw==",
        "author": {
          "login": "ForbesLindesay"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I recently built https://github.com/ForbesLindesay/opaque-types, which may be of interest to people here. It's a transpiler that generates opaque types (using various hacks involving symbols and declared classes with private properties) from simple type aliases marked with comments/annotations.",
        "bodyHTML": "<p dir=\"auto\">I recently built <a href=\"https://github.com/ForbesLindesay/opaque-types\">https://github.com/ForbesLindesay/opaque-types</a>, which may be of interest to people here. It's a transpiler that generates opaque types (using various hacks involving symbols and declared classes with private properties) from simple type aliases marked with comments/annotations.</p>",
        "createdAt": "2018-07-13T15:30:50Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-404868197",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxNTMzMzM5Nw==",
        "author": {
          "login": "Jamesernator"
        },
        "authorAssociation": "NONE",
        "body": "While nominal `interface`/`type`/etc are quite the can of worms, I don't see why nominal classes (by default) wouldn't be desirable. I can't think of a case where using a class that just happens to be structurally the same as another would ever be acceptable.\r\n\r\ne.g.:\r\n\r\n```js\r\n// The author is obviously only expecting an inline span element\r\n// passing a different element may break styles, etc\r\nfunction addToEnd(text: HTMLSpanElement) {\r\n  someElement.appendChild(text)\r\n}\r\n\r\nconst el = document.createElement('div')\r\nel.textContent = 'Some extra text'\r\n// Probably a mistake, will definitely break styling given it's typically\r\n// a block element rather than inline\r\n// Even though it's structurally identical to HTMLSpanElement why allow it?\r\n// Classes have brands for a reason\r\naddToEnd(el)\r\n```\r\n\r\nAnd sure you can work around it with hacks like the `unique symbol` thing, but I think it would be better if TypeScript captured the existing nominal-ness of classes out of the box rather than depending on hacks to work around TypeScript's inability to understand existing nominal constructs.\r\n\r\n---\r\n\r\nPersonal Note: I'm still torn between using Flow and TypeScript for this reason, unfortunately neither is a complete solution now that TypeScript has variadic types (or at least enough to type `zip(...iterables)` and similar functions).",
        "bodyHTML": "<p dir=\"auto\">While nominal <code class=\"notranslate\">interface</code>/<code class=\"notranslate\">type</code>/etc are quite the can of worms, I don't see why nominal classes (by default) wouldn't be desirable. I can't think of a case where using a class that just happens to be structurally the same as another would ever be acceptable.</p>\n<p dir=\"auto\">e.g.:</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// The author is obviously only expecting an inline span element\n// passing a different element may break styles, etc\nfunction addToEnd(text: HTMLSpanElement) {\n  someElement.appendChild(text)\n}\n\nconst el = document.createElement('div')\nel.textContent = 'Some extra text'\n// Probably a mistake, will definitely break styling given it's typically\n// a block element rather than inline\n// Even though it's structurally identical to HTMLSpanElement why allow it?\n// Classes have brands for a reason\naddToEnd(el)\"><pre class=\"notranslate\"><span class=\"pl-c\">// The author is obviously only expecting an inline span element</span>\n<span class=\"pl-c\">// passing a different element may break styles, etc</span>\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">addToEnd</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">text</span>: <span class=\"pl-v\">HTMLSpanElement</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-s1\">someElement</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">appendChild</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">text</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">el</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">document</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">createElement</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'div'</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-s1\">el</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">textContent</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'Some extra text'</span>\n<span class=\"pl-c\">// Probably a mistake, will definitely break styling given it's typically</span>\n<span class=\"pl-c\">// a block element rather than inline</span>\n<span class=\"pl-c\">// Even though it's structurally identical to HTMLSpanElement why allow it?</span>\n<span class=\"pl-c\">// Classes have brands for a reason</span>\n<span class=\"pl-en\">addToEnd</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">el</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">And sure you can work around it with hacks like the <code class=\"notranslate\">unique symbol</code> thing, but I think it would be better if TypeScript captured the existing nominal-ness of classes out of the box rather than depending on hacks to work around TypeScript's inability to understand existing nominal constructs.</p>\n<hr>\n<p dir=\"auto\">Personal Note: I'm still torn between using Flow and TypeScript for this reason, unfortunately neither is a complete solution now that TypeScript has variadic types (or at least enough to type <code class=\"notranslate\">zip(...iterables)</code> and similar functions).</p>",
        "createdAt": "2018-08-23T08:21:28Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-415333397",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxNTM0NjA4NA==",
        "author": {
          "login": "Jamesernator"
        },
        "authorAssociation": "NONE",
        "body": "Looking into it more, it seems that TypeScript already *does* understand nominal classes (to some extent I haven't investigated in detail).\r\n\r\nTry this example in the playground, TypeScript correctly infers in the `if` branch that `randomElement` is an `HTMLDivElement` so at least some nominal type information is *already* there: https://www.typescriptlang.org/play/#src=%0D%0Aconst%20randomElement%3A%20HTMLSpanElement%20%7C%20HTMLDivElement%0D%0A%20%20%20%20%3D%20Math.random()%20%3E%200.5%0D%0A%20%20%20%20%20%20%20%20%3F%20document.createElement('span')%0D%0A%20%20%20%20%20%20%20%20%3A%20document.createElement('div')%0D%0A%0D%0Aif%20(randomElement%20instanceof%20HTMLDivElement)%20%7B%0D%0A%20%20%20%20%2F%2F%20TypeScript%20has%20already%20inferred%20randomElement%20is%20an%20HTMLDivElement%0D%0A%20%20%20%20%2F%2F%20yet%20we%20can't%20use%20this%20information%20to%20make%20this%20assignment%20invalid%0D%0A%20%20%20%20const%20x%3A%20HTMLSpanElement%20%3D%20randomElement%0D%0A%7D\r\n",
        "bodyHTML": "<p dir=\"auto\">Looking into it more, it seems that TypeScript already <em>does</em> understand nominal classes (to some extent I haven't investigated in detail).</p>\n<p dir=\"auto\">Try this example in the playground, TypeScript correctly infers in the <code class=\"notranslate\">if</code> branch that <code class=\"notranslate\">randomElement</code> is an <code class=\"notranslate\">HTMLDivElement</code> so at least some nominal type information is <em>already</em> there: <a href=\"https://www.typescriptlang.org/play/#src=%0D%0Aconst%20randomElement%3A%20HTMLSpanElement%20%7C%20HTMLDivElement%0D%0A%20%20%20%20%3D%20Math.random()%20%3E%200.5%0D%0A%20%20%20%20%20%20%20%20%3F%20document.createElement('span')%0D%0A%20%20%20%20%20%20%20%20%3A%20document.createElement('div')%0D%0A%0D%0Aif%20(randomElement%20instanceof%20HTMLDivElement)%20%7B%0D%0A%20%20%20%20%2F%2F%20TypeScript%20has%20already%20inferred%20randomElement%20is%20an%20HTMLDivElement%0D%0A%20%20%20%20%2F%2F%20yet%20we%20can't%20use%20this%20information%20to%20make%20this%20assignment%20invalid%0D%0A%20%20%20%20const%20x%3A%20HTMLSpanElement%20%3D%20randomElement%0D%0A%7D\" rel=\"nofollow\">https://www.typescriptlang.org/play/#src=%0D%0Aconst%20randomElement%3A%20HTMLSpanElement%20%7C%20HTMLDivElement%0D%0A%20%20%20%20%3D%20Math.random()%20%3E%200.5%0D%0A%20%20%20%20%20%20%20%20%3F%20document.createElement('span')%0D%0A%20%20%20%20%20%20%20%20%3A%20document.createElement('div')%0D%0A%0D%0Aif%20(randomElement%20instanceof%20HTMLDivElement)%20%7B%0D%0A%20%20%20%20%2F%2F%20TypeScript%20has%20already%20inferred%20randomElement%20is%20an%20HTMLDivElement%0D%0A%20%20%20%20%2F%2F%20yet%20we%20can't%20use%20this%20information%20to%20make%20this%20assignment%20invalid%0D%0A%20%20%20%20const%20x%3A%20HTMLSpanElement%20%3D%20randomElement%0D%0A%7D</a></p>",
        "createdAt": "2018-08-23T09:06:09Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-415346084",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxNTM1Mzg5MA==",
        "author": {
          "login": "agos"
        },
        "authorAssociation": "NONE",
        "body": "@Jamesernator I would say that is not nominal, typing, but the type narrowing effect of having an `instanceof` type guard in an `if` condition - [relevant TS documentation](https://www.typescriptlang.org/docs/handbook/advanced-types.html#instanceof-type-guards)",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Jamesernator/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Jamesernator\">@Jamesernator</a> I would say that is not nominal, typing, but the type narrowing effect of having an <code class=\"notranslate\">instanceof</code> type guard in an <code class=\"notranslate\">if</code> condition - <a href=\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#instanceof-type-guards\" rel=\"nofollow\">relevant TS documentation</a></p>",
        "createdAt": "2018-08-23T09:33:21Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-415353890",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxNzcxNzQzOA==",
        "author": {
          "login": "akomm"
        },
        "authorAssociation": "NONE",
        "body": "It is a bit sad, that unlike in flow you don't have a distinction of class/interface being like common in OOP nominal, and object literals / type being structural.\r\n\r\nIf you had the concept, adding something like \"opaque type\" to \"type\" to make it behave nominal outside the module it is defined in would be a relative small step to do.\r\n\r\n```ts\r\n// opaque-types.ts\r\nexport opaque type FooId = string;\r\nexport opaque type BarId = string;\r\nexport function getUniqueFooId(): FooId {\r\n  return '(not-really)-unique-foo-id'; // inside same module it behaves structural\r\n}\r\n// opaque-types-consumer.ts\r\n// import [...]\r\nconst x: FooId = getUniqueFooId();\r\nconst y: BarId = x; // error, nominal type FooId is not compatible with nominal type BarId\r\n```\r\n",
        "bodyHTML": "<p dir=\"auto\">It is a bit sad, that unlike in flow you don't have a distinction of class/interface being like common in OOP nominal, and object literals / type being structural.</p>\n<p dir=\"auto\">If you had the concept, adding something like \"opaque type\" to \"type\" to make it behave nominal outside the module it is defined in would be a relative small step to do.</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// opaque-types.ts\nexport opaque type FooId = string;\nexport opaque type BarId = string;\nexport function getUniqueFooId(): FooId {\n  return '(not-really)-unique-foo-id'; // inside same module it behaves structural\n}\n// opaque-types-consumer.ts\n// import [...]\nconst x: FooId = getUniqueFooId();\nconst y: BarId = x; // error, nominal type FooId is not compatible with nominal type BarId\"><pre class=\"notranslate\"><span class=\"pl-c\">// opaque-types.ts</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-s1\">opaque</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">FooId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-s1\">opaque</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">BarId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">function</span> <span class=\"pl-en\">getUniqueFooId</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">FooId</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">return</span> <span class=\"pl-s\">'(not-really)-unique-foo-id'</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// inside same module it behaves structural</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-c\">// opaque-types-consumer.ts</span>\n<span class=\"pl-c\">// import [...]</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">FooId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">getUniqueFooId</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">y</span>: <span class=\"pl-smi\">BarId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">x</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error, nominal type FooId is not compatible with nominal type BarId</span></pre></div>",
        "createdAt": "2018-08-31T16:26:43Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-417717438",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxNzgyMzQ1Mw==",
        "author": {
          "login": "damncabbage"
        },
        "authorAssociation": "NONE",
        "body": "Where it might suck is if you have two versions of the same library hanging around in the dependency tree. Say if you have `foo` library v1.1 and v1.2; if you have a `FooId` from one, should you be able to give it to the other and still have it type-check? What about between `foo` v1 and v3?\r\n\r\nAs it is, though, we have `private`-using classes as prior art, and I think in those cases the type would not be able to be passed between them (without a cast). Ditto for `opaque` types with Flow. This can be totally valid as a choice! It just is a consideration and something to be decided on deliberately.\r\n\r\n(I would really like cheap/easy nominal types; I use them alongside structural types day-to-day in other languages, and they're enormously useful.)",
        "bodyHTML": "<p dir=\"auto\">Where it might suck is if you have two versions of the same library hanging around in the dependency tree. Say if you have <code class=\"notranslate\">foo</code> library v1.1 and v1.2; if you have a <code class=\"notranslate\">FooId</code> from one, should you be able to give it to the other and still have it type-check? What about between <code class=\"notranslate\">foo</code> v1 and v3?</p>\n<p dir=\"auto\">As it is, though, we have <code class=\"notranslate\">private</code>-using classes as prior art, and I think in those cases the type would not be able to be passed between them (without a cast). Ditto for <code class=\"notranslate\">opaque</code> types with Flow. This can be totally valid as a choice! It just is a consideration and something to be decided on deliberately.</p>\n<p dir=\"auto\">(I would really like cheap/easy nominal types; I use them alongside structural types day-to-day in other languages, and they're enormously useful.)</p>",
        "createdAt": "2018-09-01T01:30:56Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-417823453",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxNzgyMzk2MA==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "UPDATED:\r\ni will edit it while i can, TLDR: nominal types are not better than structural, they are not a silver bullet that we should pick by default, they have their scope of applicability, so do structural types, a balanced solution would be having them both, just as for any other dilemma that is sought to be solved by one way over another\r\n\r\nORIGINAL RANT:\r\n\r\n@akomm so are you sad because typescript goes a bit beyond OOP that you know and love? structural typing is a blessing sent to us by great gods of computer science, the opaque types you are asking about is merely an inconvenience (promised to be solved) that hasn't been a problem since the time of [July, 2014](https://github.com/Microsoft/TypeScript/issues/202#issuecomment-50199713)\r\n\r\ni remember my days of c# where 2 identical interfaces were incompatible and i had to \"convert\" one into another writing a \"XyzConverter\" and all accompanying bs like \"XyzConverterAbstractFactoryServiceProvider\"\r\n\r\ndon't get me wrong, any design decision is a double edge sword, and that's where my point comes up: it can't be that nominal interfaces by default are \"better\" than structural, neither is \"better\"\r\n\r\n",
        "bodyHTML": "<p dir=\"auto\">UPDATED:<br>\ni will edit it while i can, TLDR: nominal types are not better than structural, they are not a silver bullet that we should pick by default, they have their scope of applicability, so do structural types, a balanced solution would be having them both, just as for any other dilemma that is sought to be solved by one way over another</p>\n<p dir=\"auto\">ORIGINAL RANT:</p>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/akomm/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/akomm\">@akomm</a> so are you sad because typescript goes a bit beyond OOP that you know and love? structural typing is a blessing sent to us by great gods of computer science, the opaque types you are asking about is merely an inconvenience (promised to be solved) that hasn't been a problem since the time of <a href=\"https://github.com/Microsoft/TypeScript/issues/202#issuecomment-50199713\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">July, 2014</a></p>\n<p dir=\"auto\">i remember my days of c# where 2 identical interfaces were incompatible and i had to \"convert\" one into another writing a \"XyzConverter\" and all accompanying bs like \"XyzConverterAbstractFactoryServiceProvider\"</p>\n<p dir=\"auto\">don't get me wrong, any design decision is a double edge sword, and that's where my point comes up: it can't be that nominal interfaces by default are \"better\" than structural, neither is \"better\"</p>",
        "createdAt": "2018-09-01T01:39:36Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-417823960",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxNzg4NTg3MA==",
        "author": {
          "login": "akomm"
        },
        "authorAssociation": "NONE",
        "body": "@damncabbage I am not sure if I understood you correct. But having a dependency tree with same package in two versions sounds very odd. You talk about resolving those via npm/yarn or something you do by hand? Because in case of npm/yarn there is no such thing as version namespacing. You have only one version of a package as far as I know.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/damncabbage/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/damncabbage\">@damncabbage</a> I am not sure if I understood you correct. But having a dependency tree with same package in two versions sounds very odd. You talk about resolving those via npm/yarn or something you do by hand? Because in case of npm/yarn there is no such thing as version namespacing. You have only one version of a package as far as I know.</p>",
        "createdAt": "2018-09-01T20:44:33Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-417885870",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxNzg5MzgyOQ==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "@akomm, he's referring to getting the same package from two different dependency paths, for example using a glmatrix library directly and using a rendering library that happens to use and expose the same library, which is quite plausible.\r\n\r\nThe problem is though, that this is actually something that this glmatrix library might want to avoid you doing: perhaps it has internal flags that change between versions, or it has some sort of allocation pool that would break things if there were multiple instances.\r\n\r\nTo me this is an argument *for* nominal types (to be available for the library to use, not required), not against.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/akomm/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/akomm\">@akomm</a>, he's referring to getting the same package from two different dependency paths, for example using a glmatrix library directly and using a rendering library that happens to use and expose the same library, which is quite plausible.</p>\n<p dir=\"auto\">The problem is though, that this is actually something that this glmatrix library might want to avoid you doing: perhaps it has internal flags that change between versions, or it has some sort of allocation pool that would break things if there were multiple instances.</p>\n<p dir=\"auto\">To me this is an argument <em>for</em> nominal types (to be available for the library to use, not required), not against.</p>",
        "createdAt": "2018-09-01T23:17:54Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-417893829",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxNzg5Njc5MA==",
        "author": {
          "login": "akomm"
        },
        "authorAssociation": "NONE",
        "body": "@simonbuchan I understand that there might be different pathes to same dependency, but as far as I know the version is picked that match both, if no matching for both is found you get error installing packages. IN fact you have almost always have same dependencies over different pathes, by how tiny npm packages are fragmented. There are many generic out there that are used frequently. Still at the end you have 1 package in 1 version. Except someone creates a fork package which you can add as dependency in different version. But then there should be no problem as they have separate namespace.\r\n\r\nThis is why I wanted to clarify what he actually means is a  problem.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/simonbuchan/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/simonbuchan\">@simonbuchan</a> I understand that there might be different pathes to same dependency, but as far as I know the version is picked that match both, if no matching for both is found you get error installing packages. IN fact you have almost always have same dependencies over different pathes, by how tiny npm packages are fragmented. There are many generic out there that are used frequently. Still at the end you have 1 package in 1 version. Except someone creates a fork package which you can add as dependency in different version. But then there should be no problem as they have separate namespace.</p>\n<p dir=\"auto\">This is why I wanted to clarify what he actually means is a  problem.</p>",
        "createdAt": "2018-09-02T00:37:53Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-417896790",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxNzkwMzY0NA==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "Only if the version ranges match and both can be hoisted to a common path, and can even depend on the order they were added. It's not at all unusual for the same package to be duplicated dozens of times.",
        "bodyHTML": "<p dir=\"auto\">Only if the version ranges match and both can be hoisted to a common path, and can even depend on the order they were added. It's not at all unusual for the same package to be duplicated dozens of times.</p>",
        "createdAt": "2018-09-02T04:07:48Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-417903644",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxNzkwNTkyNA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "Please can we try to keep the signal-to-noise ratio a little better? I'm getting emailed once for *every single one* of your all's messages, and [this comment](https://github.com/Microsoft/TypeScript/issues/202#issuecomment-417823453) was the last remotely productive one. I really don't enjoy getting periodically spammed over stuff in this bug (it's one of the worst offenders), and I ***really*** don't want to unsubscribe only to miss something truly significant, like maybe a TS core dev filing a PR implementing something solving this issue.",
        "bodyHTML": "<p dir=\"auto\">Please can we try to keep the signal-to-noise ratio a little better? I'm getting emailed once for <em>every single one</em> of your all's messages, and <a href=\"https://github.com/Microsoft/TypeScript/issues/202#issuecomment-417823453\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">this comment</a> was the last remotely productive one. I really don't enjoy getting periodically spammed over stuff in this bug (it's one of the worst offenders), and I <em><strong>really</strong></em> don't want to unsubscribe only to miss something truly significant, like maybe a TS core dev filing a PR implementing something solving this issue.</p>",
        "createdAt": "2018-09-02T05:20:19Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-417905924",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxNzkwNjUzOQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows wow so much for a bike shed discussion on an internet board isn't, this discussion isn't going anywhere long time and cannot go anywhere, the issue is in the roadmap waiting it's turn to be implemented\r\n\r\nbesides gentlemen have somewhat valid concern about compatibility of nominals (if any if ever) coming from different versions of the same lib",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows wow so much for a bike shed discussion on an internet board isn't, this discussion isn't going anywhere long time and cannot go anywhere, the issue is in the roadmap waiting it's turn to be implemented</p>\n<p dir=\"auto\">besides gentlemen have somewhat valid concern about compatibility of nominals (if any if ever) coming from different versions of the same lib</p>",
        "createdAt": "2018-09-02T05:40:35Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-417906539",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxODA0MjUyMQ==",
        "author": {
          "login": "akomm"
        },
        "authorAssociation": "NONE",
        "body": "@aleksey-bykov going to react to your non-sense once, as you seem to have some kind of weird problem. Please read comments carefully and do not imply statements, which where never done and start discussion and rants about them. Thanks! Also isiahmeadows is right. Not going to react to non-constructive posts anymore.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Aleksey-Bykov/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Aleksey-Bykov\">@Aleksey-Bykov</a> going to react to your non-sense once, as you seem to have some kind of weird problem. Please read comments carefully and do not imply statements, which where never done and start discussion and rants about them. Thanks! Also isiahmeadows is right. Not going to react to non-constructive posts anymore.</p>",
        "createdAt": "2018-09-03T08:35:15Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-418042521",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxODEwMDA1Mw==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "what i mean is this quote of yours:\r\n> distinction of class/interface being like common in OOP nominal and object literals / type being structural\r\n\r\nnamely making interfaces and classes nominal for the sake of matching to how it works in OOP doesn't make sense if you remember semantic differences between them:\r\n\r\n- interfaces can be inherited, types cannot be\r\n- interfaces allow self referencing, types don't\r\n- types can be primitives, products, signatures or unions or intersections, interfaces can be only products or signatures\r\n- i can go on\r\n\r\nnow, according to you, the last piece that is missing is\r\n\r\n- types are structural. interfaces are nominal\r\n\r\nit looks you have a weird problem, if we are still talking about typescript here, not some hypothetical language\r\n\r\n\r\n",
        "bodyHTML": "<p dir=\"auto\">what i mean is this quote of yours:</p>\n<blockquote>\n<p dir=\"auto\">distinction of class/interface being like common in OOP nominal and object literals / type being structural</p>\n</blockquote>\n<p dir=\"auto\">namely making interfaces and classes nominal for the sake of matching to how it works in OOP doesn't make sense if you remember semantic differences between them:</p>\n<ul dir=\"auto\">\n<li>interfaces can be inherited, types cannot be</li>\n<li>interfaces allow self referencing, types don't</li>\n<li>types can be primitives, products, signatures or unions or intersections, interfaces can be only products or signatures</li>\n<li>i can go on</li>\n</ul>\n<p dir=\"auto\">now, according to you, the last piece that is missing is</p>\n<ul dir=\"auto\">\n<li>types are structural. interfaces are nominal</li>\n</ul>\n<p dir=\"auto\">it looks you have a weird problem, if we are still talking about typescript here, not some hypothetical language</p>",
        "createdAt": "2018-09-03T12:23:50Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-418100053",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxODUwNjIxNw==",
        "author": {
          "login": "RyanCavanaugh"
        },
        "authorAssociation": "MEMBER",
        "body": "> Where it might suck is if you have two versions of the same library hanging around in the dependency tree. Say if you have foo library v1.1 and v1.2; if you have a FooId from one, should you be able to give it to the other and still have it type-check? What about between foo v1 and v3?\r\n\r\nThis is a pretty big sticking point. I have a hard enough time convincing people that an instance of a class with a private member from `v1` should not be given to a function in `v3` - that discussion usually ends with \"Please add a flag to ignore that problem\".",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">Where it might suck is if you have two versions of the same library hanging around in the dependency tree. Say if you have foo library v1.1 and v1.2; if you have a FooId from one, should you be able to give it to the other and still have it type-check? What about between foo v1 and v3?</p>\n</blockquote>\n<p dir=\"auto\">This is a pretty big sticking point. I have a hard enough time convincing people that an instance of a class with a private member from <code class=\"notranslate\">v1</code> should not be given to a function in <code class=\"notranslate\">v3</code> - that discussion usually ends with \"Please add a flag to ignore that problem\".</p>",
        "createdAt": "2018-09-04T20:26:10Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-418506217",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxODUyNjE4Ng==",
        "author": {
          "login": "aaronjensen"
        },
        "authorAssociation": "NONE",
        "body": "Does TypeScript currently support multiple type definitions for two different versions of the same library?",
        "bodyHTML": "<p dir=\"auto\">Does TypeScript currently support multiple type definitions for two different versions of the same library?</p>",
        "createdAt": "2018-09-04T21:36:33Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-418526186",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxODUyNzg4Mw==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "@RyanCavanaugh \r\n\r\nbasing nominality on the secret knowledge of private fields looks like a leaking abstraction at best, public interface is all we should care about\r\n\r\nit also raises a bunch of questions:\r\n\r\n- are `class MyClass1 { public x: number; }` and `class MyClass2 { public x: number; }` nominally compatible? if so, how come?\r\n- are `class MyClass1 { private x: number; }` and `class MyClass2 { private x: number; }` nominally compatible?\r\n- how would i make these interfaces nominal without classes `interface MyData1 { x: number; }` and `interface MyData2 { x: number; }` \r\n\r\n\r\n\r\ninstead we should let the developer decide whether or not his interface is nominal by means of modifiers  (which we need a syntax for and which so bar been faking by brand properties)\r\n\r\nthe notion of compatibility of different versions of nominals should also be there, nominality should be composable, something like this:\r\n```ts\r\ndeclare const myData1Brand: unique symbol;\r\ninterface MyData1 {\r\n    nominality: typeof myData1Brand;\r\n}\r\n\r\ndeclare const myData2Brand: unique symbol;\r\ninterface MyData2 {\r\n   nominality: MyData1['brand'] & typeof myData2Brand;\r\n}\r\ndeclare var myData1: MyData1;\r\ndeclare var myData2: MyData2;\r\nmyData1 = myData2; // <-- should not be a problem\r\nmyData2 = myData1; // <-- should be a problem\r\n```\r\n\r\nand frankly it looks like the mechanisms from the sample above is all we need to make it happen, which means that nominality is merely a syntax transform",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/RyanCavanaugh/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/RyanCavanaugh\">@RyanCavanaugh</a></p>\n<p dir=\"auto\">basing nominality on the secret knowledge of private fields looks like a leaking abstraction at best, public interface is all we should care about</p>\n<p dir=\"auto\">it also raises a bunch of questions:</p>\n<ul dir=\"auto\">\n<li>are <code class=\"notranslate\">class MyClass1 { public x: number; }</code> and <code class=\"notranslate\">class MyClass2 { public x: number; }</code> nominally compatible? if so, how come?</li>\n<li>are <code class=\"notranslate\">class MyClass1 { private x: number; }</code> and <code class=\"notranslate\">class MyClass2 { private x: number; }</code> nominally compatible?</li>\n<li>how would i make these interfaces nominal without classes <code class=\"notranslate\">interface MyData1 { x: number; }</code> and <code class=\"notranslate\">interface MyData2 { x: number; }</code></li>\n</ul>\n<p dir=\"auto\">instead we should let the developer decide whether or not his interface is nominal by means of modifiers  (which we need a syntax for and which so bar been faking by brand properties)</p>\n<p dir=\"auto\">the notion of compatibility of different versions of nominals should also be there, nominality should be composable, something like this:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"declare const myData1Brand: unique symbol;\ninterface MyData1 {\n    nominality: typeof myData1Brand;\n}\n\ndeclare const myData2Brand: unique symbol;\ninterface MyData2 {\n   nominality: MyData1['brand'] &amp; typeof myData2Brand;\n}\ndeclare var myData1: MyData1;\ndeclare var myData2: MyData2;\nmyData1 = myData2; // &lt;-- should not be a problem\nmyData2 = myData1; // &lt;-- should be a problem\"><pre class=\"notranslate\"><span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">myData1Brand</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">MyData1</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">nominality</span>: <span class=\"pl-k\">typeof</span> <span class=\"pl-s1\">myData1Brand</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">myData2Brand</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">MyData2</span> <span class=\"pl-kos\">{</span>\n   <span class=\"pl-c1\">nominality</span>: <span class=\"pl-smi\">MyData1</span><span class=\"pl-kos\">[</span><span class=\"pl-s\">'brand'</span><span class=\"pl-kos\">]</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-s1\">myData2Brand</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">var</span> <span class=\"pl-s1\">myData1</span>: <span class=\"pl-smi\">MyData1</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">var</span> <span class=\"pl-s1\">myData2</span>: <span class=\"pl-smi\">MyData2</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">myData1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">myData2</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// &lt;-- should not be a problem</span>\n<span class=\"pl-s1\">myData2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">myData1</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// &lt;-- should be a problem</span></pre></div>\n<p dir=\"auto\">and frankly it looks like the mechanisms from the sample above is all we need to make it happen, which means that nominality is merely a syntax transform</p>",
        "createdAt": "2018-09-04T21:43:16Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-418527883",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxODU0NjAxNQ==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "@aaronjensen yup:\r\n\r\n```\r\nType 'import(\"c:/code/personal/test/node_modules/y/index\").default' is not assignable to type 'import(\"c:/code/personal/test/node_modules/x/node_modules/y/index\").default'.\r\n  Types have separate declarations of a private property 'x'.\r\n```\r\n\r\nBoth `y` modules are just `export default class Y { private x: number }`, and `x` just re-exports it's own `y`.\r\n\r\n---\r\n\r\n@RyanCavanaugh  Are you saying that *any* form of nominal types would have push-back from those weirdos who don't use `--strict`? Is this similar to the problem of if library types writers should use `unknown` or `any`?",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/aaronjensen/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/aaronjensen\">@aaronjensen</a> yup:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Type 'import(&quot;c:/code/personal/test/node_modules/y/index&quot;).default' is not assignable to type 'import(&quot;c:/code/personal/test/node_modules/x/node_modules/y/index&quot;).default'.\n  Types have separate declarations of a private property 'x'.\"><pre class=\"notranslate\"><code class=\"notranslate\">Type 'import(\"c:/code/personal/test/node_modules/y/index\").default' is not assignable to type 'import(\"c:/code/personal/test/node_modules/x/node_modules/y/index\").default'.\n  Types have separate declarations of a private property 'x'.\n</code></pre></div>\n<p dir=\"auto\">Both <code class=\"notranslate\">y</code> modules are just <code class=\"notranslate\">export default class Y { private x: number }</code>, and <code class=\"notranslate\">x</code> just re-exports it's own <code class=\"notranslate\">y</code>.</p>\n<hr>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/RyanCavanaugh/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/RyanCavanaugh\">@RyanCavanaugh</a>  Are you saying that <em>any</em> form of nominal types would have push-back from those weirdos who don't use <code class=\"notranslate\">--strict</code>? Is this similar to the problem of if library types writers should use <code class=\"notranslate\">unknown</code> or <code class=\"notranslate\">any</code>?</p>",
        "createdAt": "2018-09-04T23:07:17Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-418546015",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxODY5NzU0Nw==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@RyanCavanaugh \r\n\r\n> This is a pretty big sticking point. I have a hard enough time convincing people that an instance of a class with a private member from v1 should not be given to a function in v3 - that discussion usually ends with \"Please add a flag to ignore that problem\".\r\n\r\nMost nominally-typed languages (including Java and friends) have this issue, too, but even worse - you can't even cast it to the correct value. Java will throw a runtime error, while Rust won't even let you compile it. You have to instead somehow clone it structurally, which isn't always possible. At least with TypeScript, you could just do `foov1 as any as FooV2` and call it a day if classes were made nominal. (C++ is similar: you can do `reinterpret_cast<FooV2*>(foov1)` for similar effect.)",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/RyanCavanaugh/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/RyanCavanaugh\">@RyanCavanaugh</a></p>\n<blockquote>\n<p dir=\"auto\">This is a pretty big sticking point. I have a hard enough time convincing people that an instance of a class with a private member from v1 should not be given to a function in v3 - that discussion usually ends with \"Please add a flag to ignore that problem\".</p>\n</blockquote>\n<p dir=\"auto\">Most nominally-typed languages (including Java and friends) have this issue, too, but even worse - you can't even cast it to the correct value. Java will throw a runtime error, while Rust won't even let you compile it. You have to instead somehow clone it structurally, which isn't always possible. At least with TypeScript, you could just do <code class=\"notranslate\">foov1 as any as FooV2</code> and call it a day if classes were made nominal. (C++ is similar: you can do <code class=\"notranslate\">reinterpret_cast&lt;FooV2*&gt;(foov1)</code> for similar effect.)</p>",
        "createdAt": "2018-09-05T11:30:58Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-418697547",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxODcxMDU5MA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "So to summarize that last comment, I'm not convinced it's an issue to really be concerned about. Worst case scenario, it just results in a bunch of extra casts.\r\n\r\n**Edit:** Meant to send this an hour ago with my initial comment.",
        "bodyHTML": "<p dir=\"auto\">So to summarize that last comment, I'm not convinced it's an issue to really be concerned about. Worst case scenario, it just results in a bunch of extra casts.</p>\n<p dir=\"auto\"><strong>Edit:</strong> Meant to send this an hour ago with my initial comment.</p>",
        "createdAt": "2018-09-05T12:23:21Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-418710590",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxOTEyMzQ2OQ==",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows node is a little different because it allows you to have several different versions of a library in a single project - and thats very commonplace (just scan your node_modules for duplicates). \r\n\r\nIf that library had any sort of nominally typed object that you pass around, you'll be getting lots of spurious type errors.\r\n\r\nIn this situation IMO branded types (with a non-unique brand, usually a string name) are better. You can decide that the internal behavior of the particular type has changed sufficiently that you need to update the brand name \"glObjv1\" to \"glObjv2\" to make it incompatible. You get to control when the types become incompatible, which is very nice:\r\n\r\ninstead of\r\n\r\n```typescript\r\nnominal UserID extends string {}\r\n```\r\n\r\nhave\r\n\r\n```typescript\r\ntype UserID  = Branded<string, 'userid-v1'>\r\n```",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows node is a little different because it allows you to have several different versions of a library in a single project - and thats very commonplace (just scan your node_modules for duplicates).</p>\n<p dir=\"auto\">If that library had any sort of nominally typed object that you pass around, you'll be getting lots of spurious type errors.</p>\n<p dir=\"auto\">In this situation IMO branded types (with a non-unique brand, usually a string name) are better. You can decide that the internal behavior of the particular type has changed sufficiently that you need to update the brand name \"glObjv1\" to \"glObjv2\" to make it incompatible. You get to control when the types become incompatible, which is very nice:</p>\n<p dir=\"auto\">instead of</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"nominal UserID extends string {}\"><pre class=\"notranslate\"><span class=\"pl-s1\">nominal</span> <span class=\"pl-smi\">UserID</span> <span class=\"pl-k\">extends</span> string <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">have</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type UserID  = Branded&lt;string, 'userid-v1'&gt;\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">UserID</span>  <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Branded</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'userid-v1'</span><span class=\"pl-kos\">&gt;</span></pre></div>",
        "createdAt": "2018-09-06T14:51:29Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-419123469",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxOTY1NTQxMA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@spion So maybe, a way to brand objects without adding phantom properties might be better than nominal types.\r\n\r\nMakes me like [this suggestion of mine](https://github.com/Microsoft/TypeScript/issues/17588) even more...",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/spion/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/spion\">@spion</a> So maybe, a way to brand objects without adding phantom properties might be better than nominal types.</p>\n<p dir=\"auto\">Makes me like <a href=\"https://github.com/Microsoft/TypeScript/issues/17588\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/17588/hovercard\">this suggestion of mine</a> even more...</p>",
        "createdAt": "2018-09-08T16:26:38Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-419655410",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxOTY1NTcxMA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "But here's my issue with that: it'd require some level of namespacing for dealing with keeping branding distinct. Something that instead took into account the `package.json`'s `\"name\"` field might help with addressing that implicitly so it doesn't require so much boilerplate to brand everything. But you still have to manually construct a version identifier for every update.",
        "bodyHTML": "<p dir=\"auto\">But here's my issue with that: it'd require some level of namespacing for dealing with keeping branding distinct. Something that instead took into account the <code class=\"notranslate\">package.json</code>'s <code class=\"notranslate\">\"name\"</code> field might help with addressing that implicitly so it doesn't require so much boilerplate to brand everything. But you still have to manually construct a version identifier for every update.</p>",
        "createdAt": "2018-09-08T16:31:01Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-419655710",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxOTY1NTk5OQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows so we need npm for typescript to work?",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows so we need npm for typescript to work?</p>",
        "createdAt": "2018-09-08T16:35:22Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-419655999",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxOTY1NjY0NQ==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@aleksey-bykov No, and that's not the implication. Besides, TypeScript already uses the `\"types\"` (alias: `\"typings\"`) field to resolve declarations within `node_modules`, and Node.js itself uses `\"main\"` for standard module resolution. And if you've ever encountered a `\"browser\"` field, Browserify, Webpack, and Rollup (with rollup-plugin-node-resolve plugin) all three leverage that during module resolution, without even making a single web request in the process.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Aleksey-Bykov/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Aleksey-Bykov\">@Aleksey-Bykov</a> No, and that's not the implication. Besides, TypeScript already uses the <code class=\"notranslate\">\"types\"</code> (alias: <code class=\"notranslate\">\"typings\"</code>) field to resolve declarations within <code class=\"notranslate\">node_modules</code>, and Node.js itself uses <code class=\"notranslate\">\"main\"</code> for standard module resolution. And if you've ever encountered a <code class=\"notranslate\">\"browser\"</code> field, Browserify, Webpack, and Rollup (with rollup-plugin-node-resolve plugin) all three leverage that during module resolution, without even making a single web request in the process.</p>",
        "createdAt": "2018-09-08T16:44:29Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-419656645",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxOTY1NzExMg==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "well good, because although typescript supports npm and get shipped via npm and even has it mentioned in its specs, but when it comes to core features like nominals/branding, i wish we weren't bound to configuration files of npm, because far not all projects need it (like ours), we use npm only to get the compiler",
        "bodyHTML": "<p dir=\"auto\">well good, because although typescript supports npm and get shipped via npm and even has it mentioned in its specs, but when it comes to core features like nominals/branding, i wish we weren't bound to configuration files of npm, because far not all projects need it (like ours), we use npm only to get the compiler</p>",
        "createdAt": "2018-09-08T16:51:26Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-419657112",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxOTc1MDk5NA==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "FYI: `types` works by filtering the contents of the `typeRoots` directories, that only defaults to `node_modules/@types`. The only bit of `package.json` handling in TS (to my knowledge) is identical to `node` itself when using `\"moduleResolution\": \"node\"`, using the `main` field if the module is resolving to a directory with a `package.json` field. There's no use of the `name` field, or any requirement the `package.json` files are in `node_modules`, no does TS use the browser field spec.",
        "bodyHTML": "<p dir=\"auto\">FYI: <code class=\"notranslate\">types</code> works by filtering the contents of the <code class=\"notranslate\">typeRoots</code> directories, that only defaults to <code class=\"notranslate\">node_modules/@types</code>. The only bit of <code class=\"notranslate\">package.json</code> handling in TS (to my knowledge) is identical to <code class=\"notranslate\">node</code> itself when using <code class=\"notranslate\">\"moduleResolution\": \"node\"</code>, using the <code class=\"notranslate\">main</code> field if the module is resolving to a directory with a <code class=\"notranslate\">package.json</code> field. There's no use of the <code class=\"notranslate\">name</code> field, or any requirement the <code class=\"notranslate\">package.json</code> files are in <code class=\"notranslate\">node_modules</code>, no does TS use the browser field spec.</p>",
        "createdAt": "2018-09-09T22:53:15Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-419750994",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxOTg3ODk1NQ==",
        "author": {
          "login": "PAStheLoD"
        },
        "authorAssociation": "NONE",
        "body": "Would keeping track of where a type is defined and comparing based on that solve the naming/branding problem? And if someone wants to declare UserId from some/module/user.ts equal to what/ever/mate/users.model.ts, then that user should say so (somewhere in their code).\r\n\r\nAnd whether that conversion table is global, its scope and other properties can/should be debated of course. ",
        "bodyHTML": "<p dir=\"auto\">Would keeping track of where a type is defined and comparing based on that solve the naming/branding problem? And if someone wants to declare UserId from some/module/user.ts equal to what/ever/mate/users.model.ts, then that user should say so (somewhere in their code).</p>\n<p dir=\"auto\">And whether that conversion table is global, its scope and other properties can/should be debated of course.</p>",
        "createdAt": "2018-09-10T11:18:42Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-419878955",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxOTk0Mzk3OQ==",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "> But here's my issue with that: it'd require some level of namespacing for dealing with keeping branding distinct. Something that instead took into account the package.json's \"name\" field might help with addressing that implicitly so it doesn't require so much boilerplate to brand everything. But you still have to manually construct a version identifier for every update.\r\n\r\nSo just use \"packagename.ObjectBrand.version\" (the version is only bumped when the actual object brand becomes incompatible, so you could e.g. bump the commentId brand but not the userId).",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">But here's my issue with that: it'd require some level of namespacing for dealing with keeping branding distinct. Something that instead took into account the package.json's \"name\" field might help with addressing that implicitly so it doesn't require so much boilerplate to brand everything. But you still have to manually construct a version identifier for every update.</p>\n</blockquote>\n<p dir=\"auto\">So just use \"packagename.ObjectBrand.version\" (the version is only bumped when the actual object brand becomes incompatible, so you could e.g. bump the commentId brand but not the userId).</p>",
        "createdAt": "2018-09-10T14:57:59Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-419943979",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxOTk0NTU4OA==",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "Of course, since all this is code, you could have a two-brand Branded type with a package brand specified in it:\r\n\r\n```typescript\r\ntype PackageBranded<T, Brand> = { \r\n  \" package brand\": \"PackageName.version\",\r\n  \" object brand\": Brand,\r\n  ...\r\n}\r\n```\r\n\r\n(obviously the machinery would be a bit more sophisticated than that)\r\n\r\nThat way you specify the package brand once, then you don't have to write it out for every type.",
        "bodyHTML": "<p dir=\"auto\">Of course, since all this is code, you could have a two-brand Branded type with a package brand specified in it:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type PackageBranded&lt;T, Brand&gt; = { \n  &quot; package brand&quot;: &quot;PackageName.version&quot;,\n  &quot; object brand&quot;: Brand,\n  ...\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">PackageBranded</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span> \n  <span class=\"pl-s\">\" package brand\"</span>: <span class=\"pl-s\">\"PackageName.version\"</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-s\">\" object brand\"</span>: <span class=\"pl-smi\">Brand</span><span class=\"pl-kos\">,</span>\n  ...\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">(obviously the machinery would be a bit more sophisticated than that)</p>\n<p dir=\"auto\">That way you specify the package brand once, then you don't have to write it out for every type.</p>",
        "createdAt": "2018-09-10T15:02:26Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-419945588",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxOTk0NzQzMw==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "why does it need namespaces or names in the first place? \r\n\r\nall we need is a somehow attached unique value that can be used as a distinction between 2 otherwise identical types\r\n\r\nbest option as of now are the symbols, because they are unique and serve as a good example of zero-cost abstraction as long as they stay in the type domain\r\n\r\nquestion is whether we can combine 2 symbols to get a new unique symbol that posses the properties of its constituents, so that uniqueness is composable, like in my previous example https://github.com/Microsoft/TypeScript/issues/202#issuecomment-418527883:\r\n\r\n```ts\r\ndeclare const myData1Brand: unique symbol;\r\ninterface MyData1 {\r\n    nominality: typeof myData1Brand;\r\n}\r\n\r\ndeclare const myData2Brand: unique symbol;\r\ninterface MyData2 {\r\n   nominality: MyData1['brand'] & typeof myData2Brand;\r\n}\r\ndeclare var myData1: MyData1;\r\ndeclare var myData2: MyData2;\r\nmyData1 = myData2; // <-- should not be a problem\r\nmyData2 = myData1; // <-- should be a problem\r\n```\r\n\r\n",
        "bodyHTML": "<p dir=\"auto\">why does it need namespaces or names in the first place?</p>\n<p dir=\"auto\">all we need is a somehow attached unique value that can be used as a distinction between 2 otherwise identical types</p>\n<p dir=\"auto\">best option as of now are the symbols, because they are unique and serve as a good example of zero-cost abstraction as long as they stay in the type domain</p>\n<p dir=\"auto\">question is whether we can combine 2 symbols to get a new unique symbol that posses the properties of its constituents, so that uniqueness is composable, like in my previous example <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard?comment_id=418527883&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-418527883\">#202 (comment)</a>:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"declare const myData1Brand: unique symbol;\ninterface MyData1 {\n    nominality: typeof myData1Brand;\n}\n\ndeclare const myData2Brand: unique symbol;\ninterface MyData2 {\n   nominality: MyData1['brand'] &amp; typeof myData2Brand;\n}\ndeclare var myData1: MyData1;\ndeclare var myData2: MyData2;\nmyData1 = myData2; // &lt;-- should not be a problem\nmyData2 = myData1; // &lt;-- should be a problem\"><pre class=\"notranslate\"><span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">myData1Brand</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">MyData1</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">nominality</span>: <span class=\"pl-k\">typeof</span> <span class=\"pl-s1\">myData1Brand</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">myData2Brand</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">MyData2</span> <span class=\"pl-kos\">{</span>\n   <span class=\"pl-c1\">nominality</span>: <span class=\"pl-smi\">MyData1</span><span class=\"pl-kos\">[</span><span class=\"pl-s\">'brand'</span><span class=\"pl-kos\">]</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-s1\">myData2Brand</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">var</span> <span class=\"pl-s1\">myData1</span>: <span class=\"pl-smi\">MyData1</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">var</span> <span class=\"pl-s1\">myData2</span>: <span class=\"pl-smi\">MyData2</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">myData1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">myData2</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// &lt;-- should not be a problem</span>\n<span class=\"pl-s1\">myData2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">myData1</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// &lt;-- should be a problem</span></pre></div>",
        "createdAt": "2018-09-10T15:07:46Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-419947433",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxOTk0NzkxOQ==",
        "author": {
          "login": "zakhenry"
        },
        "authorAssociation": "NONE",
        "body": "If we need to have specific symbol import from specific packages, it's probably simpler to extend the import syntax so it would be `import { MyType } from 'some-npm-package@1.2.3'` if you care about the specifying which package, otherwise `import { MyType } from 'some-npm-package` if not. This would need to extend the module resolution capabilities, but that might actually be a good thing as it would allow for multiple import from the same project but different versions of it.",
        "bodyHTML": "<p dir=\"auto\">If we need to have specific symbol import from specific packages, it's probably simpler to extend the import syntax so it would be <code class=\"notranslate\">import { MyType } from 'some-npm-package@1.2.3'</code> if you care about the specifying which package, otherwise <code class=\"notranslate\">import { MyType } from 'some-npm-package</code> if not. This would need to extend the module resolution capabilities, but that might actually be a good thing as it would allow for multiple import from the same project but different versions of it.</p>",
        "createdAt": "2018-09-10T15:09:07Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-419947919",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQxOTk5OTc2MQ==",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "I don't think everyone realizes what the problem with unique symbols and nominal is, so I'll try to illustrate:\r\n\r\nSay you have Sequelize, which depends on bluebird v2, and you yourself are using bluebird v3 in your project. You might have something like:\r\n\r\n```typescript\r\nmyObject.someMethodReturningV3Promise.then(res =>\r\n  sequelizeObject.someQuery(res.id));\r\n```\r\n\r\n\r\nThe promises returned by Sequelize are bluebird v3 promises. They're fully compatible with bluebird v2 promises, and there is no problem returning a Sequelize (v2) promise within the `then` callback of the v3 promise, since it conforms to the structural `thenable` interface.\r\n\r\nHowever, imagine a similar situation with nominal types. Lets say you wrote a modular game engine, and there is an object manager for entities that manages objects by a nominal ID (exports a nominal entity type). This nominally typed object has a method:\r\n\r\n```typescript\r\nobject.compareTo(otherObject)\r\n```\r\n\r\nwhich compares by that ID.\r\n\r\nNow lets say that due to imperfect deduplication (which unfortunately is still very common in both npm and yarn), you have two libraries, like sequelize: one depending on object manager v2, and another depending on object manager v2.5. These object managers are completely compatible, but since there is an incompatible object manager v3 as the main dependency of your project, you end up with:\r\n\r\n```\r\nnode_modules\r\n| - objectManager@v3.0.0\r\n| - lib1\r\n|   | - objectManager@2.0.0\r\n| - lib2\r\n|   | - objectManager@v2.5.0\r\n```\r\n\r\nNow, unless you control the uniqueness of brand yourself, you could have the following fail to typecheck:\r\n\r\n```typescript\r\nlet o1 = lib1Instance.getSomeObjectFromManager(params);\r\nlet o2 = lib2Instance.getSomeObjectFromManager(otherParams);\r\nif (o1.compareTo(o2)) { // type error\r\n// ... do something\r\n}\r\n```\r\n\r\nThey come from a different path on the filesystem, and if that different path generates a different unique brand, you get a type error.\r\n\r\nThis is not a problem with TypeScript - its mostly a problem with the node modules resolution algorithm. However, thats the reality we live in...\r\n\r\nNow admittedly, if this were the only problem, it would be a pretty weak case against nominal types. However, a similar problem can manifest in testing, when you try to write fake objects and classes. With a structural type system, compatible fakes are trivially easy to write. With a nominal type system, even if only one in 100 types is nominal, they could quickly end up in a more complex object in some deep property, and as a result it would be impossible to make a compatible fake if you can't replicate the exact same brand - especially if its in a library you don't control.\r\n\r\nSure you can work around this problem by force-casting to the correct type through `any`, but then your tests are littered with casts and no longer type safe...",
        "bodyHTML": "<p dir=\"auto\">I don't think everyone realizes what the problem with unique symbols and nominal is, so I'll try to illustrate:</p>\n<p dir=\"auto\">Say you have Sequelize, which depends on bluebird v2, and you yourself are using bluebird v3 in your project. You might have something like:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"myObject.someMethodReturningV3Promise.then(res =&gt;\n  sequelizeObject.someQuery(res.id));\"><pre class=\"notranslate\"><span class=\"pl-s1\">myObject</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">someMethodReturningV3Promise</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">then</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">res</span> <span class=\"pl-c1\">=&gt;</span>\n  <span class=\"pl-s1\">sequelizeObject</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">someQuery</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">res</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">id</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">The promises returned by Sequelize are bluebird v3 promises. They're fully compatible with bluebird v2 promises, and there is no problem returning a Sequelize (v2) promise within the <code class=\"notranslate\">then</code> callback of the v3 promise, since it conforms to the structural <code class=\"notranslate\">thenable</code> interface.</p>\n<p dir=\"auto\">However, imagine a similar situation with nominal types. Lets say you wrote a modular game engine, and there is an object manager for entities that manages objects by a nominal ID (exports a nominal entity type). This nominally typed object has a method:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"object.compareTo(otherObject)\"><pre class=\"notranslate\"><span class=\"pl-s1\">object</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">compareTo</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">otherObject</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">which compares by that ID.</p>\n<p dir=\"auto\">Now lets say that due to imperfect deduplication (which unfortunately is still very common in both npm and yarn), you have two libraries, like sequelize: one depending on object manager v2, and another depending on object manager v2.5. These object managers are completely compatible, but since there is an incompatible object manager v3 as the main dependency of your project, you end up with:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"node_modules\n| - objectManager@v3.0.0\n| - lib1\n|   | - objectManager@2.0.0\n| - lib2\n|   | - objectManager@v2.5.0\"><pre class=\"notranslate\"><code class=\"notranslate\">node_modules\n| - objectManager@v3.0.0\n| - lib1\n|   | - objectManager@2.0.0\n| - lib2\n|   | - objectManager@v2.5.0\n</code></pre></div>\n<p dir=\"auto\">Now, unless you control the uniqueness of brand yourself, you could have the following fail to typecheck:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"let o1 = lib1Instance.getSomeObjectFromManager(params);\nlet o2 = lib2Instance.getSomeObjectFromManager(otherParams);\nif (o1.compareTo(o2)) { // type error\n// ... do something\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">let</span> <span class=\"pl-s1\">o1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">lib1Instance</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">getSomeObjectFromManager</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">params</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">o2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">lib2Instance</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">getSomeObjectFromManager</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">otherParams</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">o1</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">compareTo</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">o2</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c\">// type error</span>\n<span class=\"pl-c\">// ... do something</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">They come from a different path on the filesystem, and if that different path generates a different unique brand, you get a type error.</p>\n<p dir=\"auto\">This is not a problem with TypeScript - its mostly a problem with the node modules resolution algorithm. However, thats the reality we live in...</p>\n<p dir=\"auto\">Now admittedly, if this were the only problem, it would be a pretty weak case against nominal types. However, a similar problem can manifest in testing, when you try to write fake objects and classes. With a structural type system, compatible fakes are trivially easy to write. With a nominal type system, even if only one in 100 types is nominal, they could quickly end up in a more complex object in some deep property, and as a result it would be impossible to make a compatible fake if you can't replicate the exact same brand - especially if its in a library you don't control.</p>\n<p dir=\"auto\">Sure you can work around this problem by force-casting to the correct type through <code class=\"notranslate\">any</code>, but then your tests are littered with casts and no longer type safe...</p>",
        "createdAt": "2018-09-10T17:45:16Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-419999761",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDAwNDM4NQ==",
        "author": {
          "login": "RyanCavanaugh"
        },
        "authorAssociation": "MEMBER",
        "body": "⬆️ ⬆️ ⬆️ ⬆️ ⬆️ ⬆️ ⬆️ ⬆️ ⬆️ ⬆️ \r\n\r\nIn early days of TypeScript, *all* classes were nominal, and *exactly* the problem described above occurred. Even with only a few internal teams using TS, we very quickly got enough complaints to realize that \"nominal everywhere\" was a big problem.",
        "bodyHTML": "<p dir=\"auto\">⬆️ ⬆️ ⬆️ ⬆️ ⬆️ ⬆️ ⬆️ ⬆️ ⬆️ ⬆️</p>\n<p dir=\"auto\">In early days of TypeScript, <em>all</em> classes were nominal, and <em>exactly</em> the problem described above occurred. Even with only a few internal teams using TS, we very quickly got enough complaints to realize that \"nominal everywhere\" was a big problem.</p>",
        "createdAt": "2018-09-10T17:59:41Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420004385",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDAwNzk0OQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "@RyanCavanaugh i think we have a consensus that no one wants nominals everywhere\r\n\r\nwhat we want is a way to control their compatibility, ultimately it's no different from the operations on sets, where each set is a unique brand and its elements are the types that are branded with it, what we need the notion of subsets and intersection for starters, having this we can express what is compatible to what\r\n\r\n@spion \r\n\r\nthere is no problem with nominals and symbols as long as lib.v.3.0 bases its brands off lib.v.2.5, and that in its turn bases its brands off lib.v,2.0:\r\n\r\n```ts\r\n\r\ntype Brand_V3 = unique symbol & Band_V25 & Brand_V2;\r\n\r\n```\r\n\r\nand hey why would you use nominals if V3 is compatible all the way to V2? it looks like you should:\r\n- either go structural\r\n- or just carry Brand_V2 as it is to v.3.0",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/RyanCavanaugh/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/RyanCavanaugh\">@RyanCavanaugh</a> i think we have a consensus that no one wants nominals everywhere</p>\n<p dir=\"auto\">what we want is a way to control their compatibility, ultimately it's no different from the operations on sets, where each set is a unique brand and its elements are the types that are branded with it, what we need the notion of subsets and intersection for starters, having this we can express what is compatible to what</p>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/spion/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/spion\">@spion</a></p>\n<p dir=\"auto\">there is no problem with nominals and symbols as long as lib.v.3.0 bases its brands off lib.v.2.5, and that in its turn bases its brands off lib.v,2.0:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"\ntype Brand_V3 = unique symbol &amp; Band_V25 &amp; Brand_V2;\n\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">Brand_V3</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">symbol</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">Band_V25</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">Brand_V2</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">and hey why would you use nominals if V3 is compatible all the way to V2? it looks like you should:</p>\n<ul dir=\"auto\">\n<li>either go structural</li>\n<li>or just carry Brand_V2 as it is to v.3.0</li>\n</ul>",
        "createdAt": "2018-09-10T18:10:59Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420007949",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDAxNDMwNg==",
        "author": {
          "login": "zakhenry"
        },
        "authorAssociation": "NONE",
        "body": "@aleksey-bykov I think you might be missing the distinction that subsequent versions have no way of referencing prior versions. i.e. in your last example there, how would lib V3 reference `Brand_V25` without being able to import/reference it directly, and in that case it would become completely unmaintainable to have to union on all previous definitions on each version release.\r\n\r\nThe way I see it, nominal typing is something that we'd love to have, but it can only realistically be achieved through version-narrowing extensions to the import syntax, and _even that might have issues_ with compilation checks when you try to pass one object from one library to another library that might use a different version of the first.\r\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Aleksey-Bykov/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Aleksey-Bykov\">@Aleksey-Bykov</a> I think you might be missing the distinction that subsequent versions have no way of referencing prior versions. i.e. in your last example there, how would lib V3 reference <code class=\"notranslate\">Brand_V25</code> without being able to import/reference it directly, and in that case it would become completely unmaintainable to have to union on all previous definitions on each version release.</p>\n<p dir=\"auto\">The way I see it, nominal typing is something that we'd love to have, but it can only realistically be achieved through version-narrowing extensions to the import syntax, and <em>even that might have issues</em> with compilation checks when you try to pass one object from one library to another library that might use a different version of the first.</p>",
        "createdAt": "2018-09-10T18:30:34Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420014306",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDAxNTY5NA==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "@zakhenry i have no answer to that, that the problem at hands, it cannot be done **elegantly** with the current machinery, so we need a new vehicle to deliver this information\r\n\r\n@spion as far as testing goes you don't need nominals to get into trouble, say you are testing some entities that have ids, and ids get auto generated each time new entity is created, so there cannot be 2 entities with the same ids by design, how would you assert them for being equal?\r\n\r\nanswer is, your testing framework should be smart enough to bypass certain fields in assertions\r\n\r\nsorry for not being 100% on topic, \r\n\r\nnow back to your question, as far as nominallity goes, **if needed** you **can** plan your testing in a way that you assert your nominals to structural couterparts:\r\n```\r\ndeclare const myNominal: NominalData\r\nconst myStructural = turnIntoStructural(myNominal);\r\nassertEqual(myStructural, { x: 1, y: 'a' })\r\n```",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/zakhenry/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/zakhenry\">@zakhenry</a> i have no answer to that, that the problem at hands, it cannot be done <strong>elegantly</strong> with the current machinery, so we need a new vehicle to deliver this information</p>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/spion/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/spion\">@spion</a> as far as testing goes you don't need nominals to get into trouble, say you are testing some entities that have ids, and ids get auto generated each time new entity is created, so there cannot be 2 entities with the same ids by design, how would you assert them for being equal?</p>\n<p dir=\"auto\">answer is, your testing framework should be smart enough to bypass certain fields in assertions</p>\n<p dir=\"auto\">sorry for not being 100% on topic,</p>\n<p dir=\"auto\">now back to your question, as far as nominallity goes, <strong>if needed</strong> you <strong>can</strong> plan your testing in a way that you assert your nominals to structural couterparts:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"declare const myNominal: NominalData\nconst myStructural = turnIntoStructural(myNominal);\nassertEqual(myStructural, { x: 1, y: 'a' })\"><pre class=\"notranslate\"><code class=\"notranslate\">declare const myNominal: NominalData\nconst myStructural = turnIntoStructural(myNominal);\nassertEqual(myStructural, { x: 1, y: 'a' })\n</code></pre></div>",
        "createdAt": "2018-09-10T18:34:48Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420015694",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDI1MTYwOQ==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "My big fear is that nominal types will turn into an infectious disease that permeates TS libraries, with all the problems mentioned in this issue. I'm not against nominal types (though I've yet to come across a piece of real code I'm writing where I would need them). The big problem is that devs coming from an OO background (which is like 90% of all new JS devs I'm willing to bet), will use these nominal types as a default.\r\n\r\nI'm becoming more and more convinced that adding nominality to TypeScript would end up being a huge mistake. It will only result in a book years later where a gang of experts tells us to \"prefer structural typing over nominal typing\".",
        "bodyHTML": "<p dir=\"auto\">My big fear is that nominal types will turn into an infectious disease that permeates TS libraries, with all the problems mentioned in this issue. I'm not against nominal types (though I've yet to come across a piece of real code I'm writing where I would need them). The big problem is that devs coming from an OO background (which is like 90% of all new JS devs I'm willing to bet), will use these nominal types as a default.</p>\n<p dir=\"auto\">I'm becoming more and more convinced that adding nominality to TypeScript would end up being a huge mistake. It will only result in a book years later where a gang of experts tells us to \"prefer structural typing over nominal typing\".</p>",
        "createdAt": "2018-09-11T12:11:06Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420251609",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDM2NDU1OQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "please excuse me, could not help it\r\n\r\n![image](https://user-images.githubusercontent.com/937933/45378247-ebddc100-b5ca-11e8-99da-212dcc6f7d1e.png)\r\n",
        "bodyHTML": "<p dir=\"auto\">please excuse me, could not help it</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://user-images.githubusercontent.com/937933/45378247-ebddc100-b5ca-11e8-99da-212dcc6f7d1e.png\"><img src=\"https://user-images.githubusercontent.com/937933/45378247-ebddc100-b5ca-11e8-99da-212dcc6f7d1e.png\" alt=\"image\" style=\"max-width: 100%;\"></a></p>",
        "createdAt": "2018-09-11T17:59:52Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420364559",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDM2OTIwNQ==",
        "author": {
          "login": "aaronjensen"
        },
        "authorAssociation": "NONE",
        "body": "Use case #1 in OP I don't think has been addressed anywhere, though maybe I'm mistaken. We have tried a variety of opaque type workarounds for that and are currently doing this:\r\n\r\n```ts\r\nexport type FooId = 'opaque-foo-id'\r\n\r\nconst fooMap: {[fooId in FooId]: Foo} = {['id' as FooId]: foo}\r\n```\r\n\r\nThat's the only way I know of to have a nominally/opaquely typed Record key. Is there another way?\r\n\r\nI think we can separate the dangerous/sketchy OO nominal class stuff from opaque value types.",
        "bodyHTML": "<p dir=\"auto\">Use case <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"37836623\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/1\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/1/hovercard\" href=\"https://github.com/microsoft/TypeScript/issues/1\">#1</a> in OP I don't think has been addressed anywhere, though maybe I'm mistaken. We have tried a variety of opaque type workarounds for that and are currently doing this:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"export type FooId = 'opaque-foo-id'\n\nconst fooMap: {[fooId in FooId]: Foo} = {['id' as FooId]: foo}\"><pre class=\"notranslate\"><span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">FooId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'opaque-foo-id'</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">fooMap</span>: <span class=\"pl-kos\">{</span><span class=\"pl-kos\">[</span><span class=\"pl-smi\">fooId</span> <span class=\"pl-k\">in</span> <span class=\"pl-smi\">FooId</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">Foo</span><span class=\"pl-kos\">}</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">[</span><span class=\"pl-s\">'id'</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">FooId</span><span class=\"pl-kos\">]</span>: <span class=\"pl-s1\">foo</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">That's the only way I know of to have a nominally/opaquely typed Record key. Is there another way?</p>\n<p dir=\"auto\">I think we can separate the dangerous/sketchy OO nominal class stuff from opaque value types.</p>",
        "createdAt": "2018-09-11T18:14:37Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420369205",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDQxNTA0Mg==",
        "author": {
          "login": "fenduru"
        },
        "authorAssociation": "NONE",
        "body": "So basically the stance of TS is that if a feature could possibly be used incorrectly, then that wholesale invalidates other use cases?\r\n\r\nRight now I have to do the stupid `type nominal<T> = T & { [___secret: someUnnecessarySymbol]: any }` hack so that I can ensure I don't accidentally pass an invalid string into my system when it is expecting to receive one of the values it generated (the ID problem). I'm not re-exporting these IDs, so I don't have a problem related to multiple versions of the library. I simply want type safety inside my own code base. This does result in a worse experience when developing in the code base, worse error messages, etc.\r\n\r\nThe entire fact that `unique symbol` exists in typescript in the first place is an indicator that this feature is necessary. Why was this even needed - why is it accepted that structural typing breaks down here but it can't break down in user land? Because its blessed by the ecmascript standard? That should be irrelevant to the type system.",
        "bodyHTML": "<p dir=\"auto\">So basically the stance of TS is that if a feature could possibly be used incorrectly, then that wholesale invalidates other use cases?</p>\n<p dir=\"auto\">Right now I have to do the stupid <code class=\"notranslate\">type nominal&lt;T&gt; = T &amp; { [___secret: someUnnecessarySymbol]: any }</code> hack so that I can ensure I don't accidentally pass an invalid string into my system when it is expecting to receive one of the values it generated (the ID problem). I'm not re-exporting these IDs, so I don't have a problem related to multiple versions of the library. I simply want type safety inside my own code base. This does result in a worse experience when developing in the code base, worse error messages, etc.</p>\n<p dir=\"auto\">The entire fact that <code class=\"notranslate\">unique symbol</code> exists in typescript in the first place is an indicator that this feature is necessary. Why was this even needed - why is it accepted that structural typing breaks down here but it can't break down in user land? Because its blessed by the ecmascript standard? That should be irrelevant to the type system.</p>",
        "createdAt": "2018-09-11T20:31:27Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420415042",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDQ0MTMxNA==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "> So basically the stance of TS is that if a feature could possibly be used incorrectly, then that wholesale invalidates other use cases?\r\n\r\nNo, the stance of TS is that they shouldn't make the language worse. One concern is that libraries will (correctly) add nominal types, and then you get broken due to crap outside your control. There are others like how do test mocks work, but that seems like the big one ATM.\r\n\r\n> Why was [`unique symbol`] even needed\r\n\r\nBecause the entire point of symbols is to be able to do things like:\r\n\r\n```js\r\nexport const toMyThingSymbol = Symbol('toMyThing'); // always creates a new symbol instance\r\n\r\nexport function toMyThing(value) {\r\n  if (value && value[toMyThing]) {\r\n    return value[toMyThing]();\r\n  }\r\n  // default\r\n}\r\n```\r\n\r\nso TS needed to be able to represent the type semantics of this, such as:\r\n\r\n```ts\r\nexport declare const toMyThingSymbol: unique symbol;\r\n\r\ndeclare function toMyThing<T>(value: { [toMyThingSymbol](): MyThing<T> }): MyThing<T>;\r\ndeclare function toMyThing(value: any): MyThing<any>;\r\n```\r\n\r\nThere's more detail, but the point is, this is typing existing semantics, it's quite a different situation to adding a typing-only feature.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">So basically the stance of TS is that if a feature could possibly be used incorrectly, then that wholesale invalidates other use cases?</p>\n</blockquote>\n<p dir=\"auto\">No, the stance of TS is that they shouldn't make the language worse. One concern is that libraries will (correctly) add nominal types, and then you get broken due to crap outside your control. There are others like how do test mocks work, but that seems like the big one ATM.</p>\n<blockquote>\n<p dir=\"auto\">Why was [<code class=\"notranslate\">unique symbol</code>] even needed</p>\n</blockquote>\n<p dir=\"auto\">Because the entire point of symbols is to be able to do things like:</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"export const toMyThingSymbol = Symbol('toMyThing'); // always creates a new symbol instance\n\nexport function toMyThing(value) {\n  if (value &amp;&amp; value[toMyThing]) {\n    return value[toMyThing]();\n  }\n  // default\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">export</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">toMyThingSymbol</span> <span class=\"pl-c1\">=</span> <span class=\"pl-v\">Symbol</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'toMyThing'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// always creates a new symbol instance</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">function</span> <span class=\"pl-en\">toMyThing</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">value</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">value</span> <span class=\"pl-c1\">&amp;&amp;</span> <span class=\"pl-s1\">value</span><span class=\"pl-kos\">[</span><span class=\"pl-s1\">toMyThing</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-s1\">value</span><span class=\"pl-kos\">[</span><span class=\"pl-s1\">toMyThing</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-kos\">}</span>\n  <span class=\"pl-c\">// default</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">so TS needed to be able to represent the type semantics of this, such as:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"export declare const toMyThingSymbol: unique symbol;\n\ndeclare function toMyThing&lt;T&gt;(value: { [toMyThingSymbol](): MyThing&lt;T&gt; }): MyThing&lt;T&gt;;\ndeclare function toMyThing(value: any): MyThing&lt;any&gt;;\"><pre class=\"notranslate\"><span class=\"pl-k\">export</span> <span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">toMyThingSymbol</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">function</span> <span class=\"pl-s1\">toMyThing</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">value</span>: <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">[</span><span class=\"pl-s1\">toMyThingSymbol</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">MyThing</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">MyThing</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">function</span> <span class=\"pl-s1\">toMyThing</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">value</span>: <span class=\"pl-smi\">any</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">MyThing</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">any</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">There's more detail, but the point is, this is typing existing semantics, it's quite a different situation to adding a typing-only feature.</p>",
        "createdAt": "2018-09-11T22:03:24Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420441314",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDQ5MTEyNg==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "**Edit:** Got my assignability directions mixed up.\r\n\r\nWhat about allowing branded types, types with a transparent brand string? These would be disjoint from non-branded types, living in a separate namespace where the brand is the namespace key. Maybe something like this:\r\n\r\n```ts\r\n// Original type\r\ntype Version = 1\r\ntype Foo = number brand \"my-module/Foo@1\"\r\n\r\n// How it's parsed\r\ntype Foo = (number brand \"my-module/Foo@1\")\r\n\r\n// How it works\r\n// ✅ = `Foo` is assignable to it\r\n// ❎ = `Foo` is not assignable to it\r\n/* ✅ */ type Test1 = number brand \"my-module/Foo@1\"\r\n/* ❎ */ type Test2 = number\r\n/* ❎ */ type Test3 = number brand \"my-module/Foo@2\"\r\n/* ❎ */ type Test4 = Foo brand \"my-module/Foo@1\"\r\n/* ❎ */ type Test5 = (number brand \"my-module/Foo@1\") brand \"my-module/Foo@1\"\r\n/* ✅ */ type Test6 = (number brand \"my-module/Foo@1\") | (number brand \"my-module/Foo@2\")\r\n```\r\n\r\nHere's the behavior I propose:\r\n\r\n- Branded types are `{type: Type, brand: string}` pairs. Types can be any type, and strings can be any non-template string.\r\n- Branded types are considered disjoint from their inner types. This includes when the inner type itself is a branded type.\r\n- Type brands may nest arbitrarily deep.\r\n- Type brands are not directly queryable. If you accept multiple versions, accept a union.\r\n- In the future, it might be okay to accept a regexp or parameterized brand.\r\n- In the future, symbol-based brands might also become acceptable. This would provide for full nominal typing together with unique symbols, but it'd be complicated and boilerplatey enough (you have to create two types instead of one) that it's clearly not idiomatic and generally the wrong thing to do for most cases.",
        "bodyHTML": "<p dir=\"auto\"><strong>Edit:</strong> Got my assignability directions mixed up.</p>\n<p dir=\"auto\">What about allowing branded types, types with a transparent brand string? These would be disjoint from non-branded types, living in a separate namespace where the brand is the namespace key. Maybe something like this:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// Original type\ntype Version = 1\ntype Foo = number brand &quot;my-module/Foo@1&quot;\n\n// How it's parsed\ntype Foo = (number brand &quot;my-module/Foo@1&quot;)\n\n// How it works\n// ✅ = `Foo` is assignable to it\n// ❎ = `Foo` is not assignable to it\n/* ✅ */ type Test1 = number brand &quot;my-module/Foo@1&quot;\n/* ❎ */ type Test2 = number\n/* ❎ */ type Test3 = number brand &quot;my-module/Foo@2&quot;\n/* ❎ */ type Test4 = Foo brand &quot;my-module/Foo@1&quot;\n/* ❎ */ type Test5 = (number brand &quot;my-module/Foo@1&quot;) brand &quot;my-module/Foo@1&quot;\n/* ✅ */ type Test6 = (number brand &quot;my-module/Foo@1&quot;) | (number brand &quot;my-module/Foo@2&quot;)\"><pre class=\"notranslate\"><span class=\"pl-c\">// Original type</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Version</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">1</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Foo</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-s1\">brand</span> <span class=\"pl-s\">\"my-module/Foo@1\"</span>\n\n<span class=\"pl-c\">// How it's parsed</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Foo</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span>number <span class=\"pl-s1\">brand</span> <span class=\"pl-s\">\"my-module/Foo@1\"</span><span class=\"pl-kos\">)</span>\n\n<span class=\"pl-c\">// How it works</span>\n<span class=\"pl-c\">// ✅ = `Foo` is assignable to it</span>\n<span class=\"pl-c\">// ❎ = `Foo` is not assignable to it</span>\n<span class=\"pl-c\">/* ✅ */</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Test1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-s1\">brand</span> <span class=\"pl-s\">\"my-module/Foo@1\"</span>\n<span class=\"pl-c\">/* ❎ */</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Test2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span>\n<span class=\"pl-c\">/* ❎ */</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Test3</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-s1\">brand</span> <span class=\"pl-s\">\"my-module/Foo@2\"</span>\n<span class=\"pl-c\">/* ❎ */</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Test4</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Foo</span> <span class=\"pl-s1\">brand</span> <span class=\"pl-s\">\"my-module/Foo@1\"</span>\n<span class=\"pl-c\">/* ❎ */</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Test5</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span>number <span class=\"pl-s1\">brand</span> <span class=\"pl-s\">\"my-module/Foo@1\"</span><span class=\"pl-kos\">)</span> <span class=\"pl-s1\">brand</span> <span class=\"pl-s\">\"my-module/Foo@1\"</span>\n<span class=\"pl-c\">/* ✅ */</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Test6</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span>number <span class=\"pl-s1\">brand</span> <span class=\"pl-s\">\"my-module/Foo@1\"</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">|</span> <span class=\"pl-kos\">(</span>number <span class=\"pl-s1\">brand</span> <span class=\"pl-s\">\"my-module/Foo@2\"</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">Here's the behavior I propose:</p>\n<ul dir=\"auto\">\n<li>Branded types are <code class=\"notranslate\">{type: Type, brand: string}</code> pairs. Types can be any type, and strings can be any non-template string.</li>\n<li>Branded types are considered disjoint from their inner types. This includes when the inner type itself is a branded type.</li>\n<li>Type brands may nest arbitrarily deep.</li>\n<li>Type brands are not directly queryable. If you accept multiple versions, accept a union.</li>\n<li>In the future, it might be okay to accept a regexp or parameterized brand.</li>\n<li>In the future, symbol-based brands might also become acceptable. This would provide for full nominal typing together with unique symbols, but it'd be complicated and boilerplatey enough (you have to create two types instead of one) that it's clearly not idiomatic and generally the wrong thing to do for most cases.</li>\n</ul>",
        "createdAt": "2018-09-12T02:30:10Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420491126",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDQ5MjUwNw==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "> type Foo = number brand \"my-module/Foo@1\"\r\n> type Test6 = // Assignable to `Foo`\r\n>    number brand \"my-module/Foo@1\" |\r\n>    number brand \"my-module/Foo@2\"\r\n\r\nhow is `Test6` assignable to `Foo`? `Foo` doesn't imply `Foo@2` as a valid option whereas in `Test6` it's possible\r\n\r\nthe syntax hurts my eyes, if the syntax is proposed too",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">type Foo = number brand \"my-module/Foo@1\"<br>\ntype Test6 = // Assignable to <code class=\"notranslate\">Foo</code><br>\nnumber brand \"my-module/Foo@1\" |<br>\nnumber brand \"my-module/Foo@2\"</p>\n</blockquote>\n<p dir=\"auto\">how is <code class=\"notranslate\">Test6</code> assignable to <code class=\"notranslate\">Foo</code>? <code class=\"notranslate\">Foo</code> doesn't imply <code class=\"notranslate\">Foo@2</code> as a valid option whereas in <code class=\"notranslate\">Test6</code> it's possible</p>\n<p dir=\"auto\">the syntax hurts my eyes, if the syntax is proposed too</p>",
        "createdAt": "2018-09-12T02:38:28Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420492507",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDQ5MzYyOQ==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@aleksey-bykov \r\n\r\n> how is Test6 assignable to Foo? Foo doesn't imply Foo@2 as a valid option whereas in Test6 it's possible\r\n\r\nNote the type *union* here. That would parse as this:\r\n\r\n```ts\r\ntype Test6 =\r\n    (number brand \"my-module/Foo@1\") |\r\n    (number brand \"my-module/Foo@2\")\r\n```\r\n\r\n(The `brand` is higher precedence than union/intersection.)\r\n\r\n> the syntax hurts my eyes, if the syntax is proposed too\r\n\r\nThe syntax here is mostly for demonstration. I'm not a huge fan, but I'm more concerned about the semantics first. Once the functionality gets nailed down, then we can worry about how it looks.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Aleksey-Bykov/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Aleksey-Bykov\">@Aleksey-Bykov</a></p>\n<blockquote>\n<p dir=\"auto\">how is Test6 assignable to Foo? Foo doesn't imply Foo@2 as a valid option whereas in Test6 it's possible</p>\n</blockquote>\n<p dir=\"auto\">Note the type <em>union</em> here. That would parse as this:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type Test6 =\n    (number brand &quot;my-module/Foo@1&quot;) |\n    (number brand &quot;my-module/Foo@2&quot;)\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">Test6</span> <span class=\"pl-c1\">=</span>\n    <span class=\"pl-kos\">(</span>number <span class=\"pl-s1\">brand</span> <span class=\"pl-s\">\"my-module/Foo@1\"</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">|</span>\n    <span class=\"pl-kos\">(</span>number <span class=\"pl-s1\">brand</span> <span class=\"pl-s\">\"my-module/Foo@2\"</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">(The <code class=\"notranslate\">brand</code> is higher precedence than union/intersection.)</p>\n<blockquote>\n<p dir=\"auto\">the syntax hurts my eyes, if the syntax is proposed too</p>\n</blockquote>\n<p dir=\"auto\">The syntax here is mostly for demonstration. I'm not a huge fan, but I'm more concerned about the semantics first. Once the functionality gets nailed down, then we can worry about how it looks.</p>",
        "createdAt": "2018-09-12T02:45:47Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420493629",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDQ5NDI2Mw==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "from my naive point of view `|` is for unions in TS and translating your example to TS it would sound like you stated that `Y` is assignable to `X` in:\r\n\r\n```ts\r\ntype X = string\r\ntype Y = string | number;\r\ndeclare var x: X;\r\ndeclare var y: Y;\r\nx = y; // <-- ok?\r\n```",
        "bodyHTML": "<p dir=\"auto\">from my naive point of view <code class=\"notranslate\">|</code> is for unions in TS and translating your example to TS it would sound like you stated that <code class=\"notranslate\">Y</code> is assignable to <code class=\"notranslate\">X</code> in:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type X = string\ntype Y = string | number;\ndeclare var x: X;\ndeclare var y: Y;\nx = y; // &lt;-- ok?\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">X</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">string</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Y</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">string</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">var</span> <span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">X</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">var</span> <span class=\"pl-s1\">y</span>: <span class=\"pl-smi\">Y</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">y</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// &lt;-- ok?</span></pre></div>",
        "createdAt": "2018-09-12T02:49:43Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420494263",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDQ5NDM4NQ==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows I think he means that `Test6` isn't assignable to `Foo`, seems like you meant `Foo` is assignable to `Test6`!\r\n\r\nI wouldn't have a huge issue with something like this (other than the brand accidental collisions being a potential foot-gun). This seems to be largely equivalent to `T & { brand: \"my-module/Foo@1\" }` with the edges filed off, e.g. always disjoint from `T`, including nesting, meaning general type-algebra like `T & U` behaves nicely.\r\n\r\nWhat about actual operations on these, though:\r\n\r\n```ts\r\nconst foo: Foo = 123; // legal?\r\nconst x = 123;\r\nconst foo2: Foo = x; // not legal, presumably\r\nconst foo3 = x as Foo; // legal, presumably\r\nconst foo4 = foo + 1; // legal?\r\nconst foo5 = foo + foo2; // legal?\r\nfoo.toFixed(); // legal?\r\nsomeArray[foo]; // legal?\r\n```\r\n\r\n(edit: fixed foo2, foo3)",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows I think he means that <code class=\"notranslate\">Test6</code> isn't assignable to <code class=\"notranslate\">Foo</code>, seems like you meant <code class=\"notranslate\">Foo</code> is assignable to <code class=\"notranslate\">Test6</code>!</p>\n<p dir=\"auto\">I wouldn't have a huge issue with something like this (other than the brand accidental collisions being a potential foot-gun). This seems to be largely equivalent to <code class=\"notranslate\">T &amp; { brand: \"my-module/Foo@1\" }</code> with the edges filed off, e.g. always disjoint from <code class=\"notranslate\">T</code>, including nesting, meaning general type-algebra like <code class=\"notranslate\">T &amp; U</code> behaves nicely.</p>\n<p dir=\"auto\">What about actual operations on these, though:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const foo: Foo = 123; // legal?\nconst x = 123;\nconst foo2: Foo = x; // not legal, presumably\nconst foo3 = x as Foo; // legal, presumably\nconst foo4 = foo + 1; // legal?\nconst foo5 = foo + foo2; // legal?\nfoo.toFixed(); // legal?\nsomeArray[foo]; // legal?\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-s1\">foo</span>: <span class=\"pl-smi\">Foo</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">123</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// legal?</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">123</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">foo2</span>: <span class=\"pl-smi\">Foo</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">x</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// not legal, presumably</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">foo3</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">x</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Foo</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// legal, presumably</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">foo4</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">foo</span> <span class=\"pl-c1\">+</span> <span class=\"pl-c1\">1</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// legal?</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">foo5</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">foo</span> <span class=\"pl-c1\">+</span> <span class=\"pl-s1\">foo2</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// legal?</span>\n<span class=\"pl-s1\">foo</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">toFixed</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// legal?</span>\n<span class=\"pl-s1\">someArray</span><span class=\"pl-kos\">[</span><span class=\"pl-s1\">foo</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// legal?</span></pre></div>\n<p dir=\"auto\">(edit: fixed foo2, foo3)</p>",
        "createdAt": "2018-09-12T02:50:27Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420494385",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDQ5NTExMw==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "```\r\nconst foo: Foo = 123; // legal?\r\n```\r\n no, since you didn't say it should be\r\n```\r\nconst foo2: Foo = 123; // not legal, presumably,\r\n``` \r\nsame as first one?\r\n```\r\nconst foo3 = 123 as Foo; // legal, presumably\r\n```\r\nsort of, need better syntax\r\n```\r\nconst foo4 = foo + 1; // legal?\r\n```\r\nnot until [units of measure](https://github.com/Microsoft/TypeScript/issues/364)\r\n```\r\nconst foo5 = foo + foo2; // legal?\r\n```\r\nneed arithmetic on nominals, what is it?\r\n```\r\nfoo.toFixed(); // legal?\r\n```\r\nyes\r\n```\r\nsomeArray[foo]; // legal?\r\n```\r\ndepends, if `someArray` keys are nominal or not",
        "bodyHTML": "<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const foo: Foo = 123; // legal?\"><pre class=\"notranslate\"><code class=\"notranslate\">const foo: Foo = 123; // legal?\n</code></pre></div>\n<p dir=\"auto\">no, since you didn't say it should be</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const foo2: Foo = 123; // not legal, presumably,\"><pre class=\"notranslate\"><code class=\"notranslate\">const foo2: Foo = 123; // not legal, presumably,\n</code></pre></div>\n<p dir=\"auto\">same as first one?</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const foo3 = 123 as Foo; // legal, presumably\"><pre class=\"notranslate\"><code class=\"notranslate\">const foo3 = 123 as Foo; // legal, presumably\n</code></pre></div>\n<p dir=\"auto\">sort of, need better syntax</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const foo4 = foo + 1; // legal?\"><pre class=\"notranslate\"><code class=\"notranslate\">const foo4 = foo + 1; // legal?\n</code></pre></div>\n<p dir=\"auto\">not until <a href=\"https://github.com/Microsoft/TypeScript/issues/364\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/364/hovercard\">units of measure</a></p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const foo5 = foo + foo2; // legal?\"><pre class=\"notranslate\"><code class=\"notranslate\">const foo5 = foo + foo2; // legal?\n</code></pre></div>\n<p dir=\"auto\">need arithmetic on nominals, what is it?</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"foo.toFixed(); // legal?\"><pre class=\"notranslate\"><code class=\"notranslate\">foo.toFixed(); // legal?\n</code></pre></div>\n<p dir=\"auto\">yes</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"someArray[foo]; // legal?\"><pre class=\"notranslate\"><code class=\"notranslate\">someArray[foo]; // legal?\n</code></pre></div>\n<p dir=\"auto\">depends, if <code class=\"notranslate\">someArray</code> keys are nominal or not</p>",
        "createdAt": "2018-09-12T02:55:12Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420495113",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDQ5NTIzNA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@simonbuchan \r\n\r\n> I think he means that Test6 isn't assignable to Foo, seems like you meant Foo is assignable to Test6!\r\n\r\nYeah...I'll correct the initial comment. 😄 \r\n\r\n> I wouldn't have a huge issue with something like this (other than the brand accidental collisions being a potential foot-gun).\r\n\r\nI'm aware that's a potential footgun, but I don't believe it'll run into too many issues in practice, especially since you're not going to have nearly as many types to fit into namespaces. Most of the scaling issues are going to be within the area of type declarations, not primary source code.\r\n\r\n> What about actual operations on these, though:\r\n\r\nI didn't think that far, but I think it could be refined to actually support something down that vein.\r\n\r\nBTW, `123 as Foo` would be invalid thanks to TS's type system. Instead, you'd need `123 as any as Foo`, because it's disjoint, not a downcast.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/simonbuchan/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/simonbuchan\">@simonbuchan</a></p>\n<blockquote>\n<p dir=\"auto\">I think he means that Test6 isn't assignable to Foo, seems like you meant Foo is assignable to Test6!</p>\n</blockquote>\n<p dir=\"auto\">Yeah...I'll correct the initial comment. 😄</p>\n<blockquote>\n<p dir=\"auto\">I wouldn't have a huge issue with something like this (other than the brand accidental collisions being a potential foot-gun).</p>\n</blockquote>\n<p dir=\"auto\">I'm aware that's a potential footgun, but I don't believe it'll run into too many issues in practice, especially since you're not going to have nearly as many types to fit into namespaces. Most of the scaling issues are going to be within the area of type declarations, not primary source code.</p>\n<blockquote>\n<p dir=\"auto\">What about actual operations on these, though:</p>\n</blockquote>\n<p dir=\"auto\">I didn't think that far, but I think it could be refined to actually support something down that vein.</p>\n<p dir=\"auto\">BTW, <code class=\"notranslate\">123 as Foo</code> would be invalid thanks to TS's type system. Instead, you'd need <code class=\"notranslate\">123 as any as Foo</code>, because it's disjoint, not a downcast.</p>",
        "createdAt": "2018-09-12T02:56:02Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420495234",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDQ5NjEyOA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "I just updated [my branding proposal](https://github.com/Microsoft/TypeScript/issues/202#issuecomment-420491126) to fix the wrong typing direction.",
        "bodyHTML": "<p dir=\"auto\">I just updated <a href=\"https://github.com/Microsoft/TypeScript/issues/202#issuecomment-420491126\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">my branding proposal</a> to fix the wrong typing direction.</p>",
        "createdAt": "2018-09-12T03:01:59Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420496128",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDQ5NzQ1Ng==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "@aleksey-bykov Sorry, I fixed foo2 and foo3.\r\n\r\nSince `foo.toFixed()` is legal, does `(\"\" as string brand \"bar\").slice()` have type `string` or `string brand \"bar\"`?\r\n\r\n> need arithmetic on nominals, what is it?\r\n\r\nDepends on your use case. For example, `number brand \"byte-size\"` vs `number brand \"object-count\"` could support units of measure if the details are worked out. Without working them out now, you would want to be sure adding this now wouldn't break that in the future.\r\n\r\nSee also these old comments in this thread by Ryan:\r\n- proposal requirements https://github.com/Microsoft/TypeScript/issues/202#issuecomment-49829643\r\n- implementation cost vs. motivation https://github.com/Microsoft/TypeScript/issues/202#issuecomment-69646899\r\n- \"hack scale\", what the bar is https://github.com/Microsoft/TypeScript/issues/202#issuecomment-246586720",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Aleksey-Bykov/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Aleksey-Bykov\">@Aleksey-Bykov</a> Sorry, I fixed foo2 and foo3.</p>\n<p dir=\"auto\">Since <code class=\"notranslate\">foo.toFixed()</code> is legal, does <code class=\"notranslate\">(\"\" as string brand \"bar\").slice()</code> have type <code class=\"notranslate\">string</code> or <code class=\"notranslate\">string brand \"bar\"</code>?</p>\n<blockquote>\n<p dir=\"auto\">need arithmetic on nominals, what is it?</p>\n</blockquote>\n<p dir=\"auto\">Depends on your use case. For example, <code class=\"notranslate\">number brand \"byte-size\"</code> vs <code class=\"notranslate\">number brand \"object-count\"</code> could support units of measure if the details are worked out. Without working them out now, you would want to be sure adding this now wouldn't break that in the future.</p>\n<p dir=\"auto\">See also these old comments in this thread by Ryan:</p>\n<ul dir=\"auto\">\n<li>proposal requirements <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard?comment_id=49829643&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-49829643\">#202 (comment)</a></li>\n<li>implementation cost vs. motivation <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard?comment_id=69646899&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-69646899\">#202 (comment)</a></li>\n<li>\"hack scale\", what the bar is <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard?comment_id=246586720&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-246586720\">#202 (comment)</a></li>\n</ul>",
        "createdAt": "2018-09-12T03:10:32Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420497456",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDQ5ODE1Ng==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows  using strings for nominals could save the day, what bothers me is that each time you need the full path to declare a new nominal\r\n\r\nthe history of XML namespaces declarations could be of help here, something like\r\n```ts\r\ndeclare domain Xyz of 'my-company/my-project/my-app';\r\ntype UserId = string of Xyz of 'my-users';\r\nconst userId = 'me' of UserId; // 'me' of UserId\r\n// or\r\nconst userId: UserId = 'me'; // string of UserId\r\n```\r\n(edited)",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows  using strings for nominals could save the day, what bothers me is that each time you need the full path to declare a new nominal</p>\n<p dir=\"auto\">the history of XML namespaces declarations could be of help here, something like</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"declare domain Xyz of 'my-company/my-project/my-app';\ntype UserId = string of Xyz of 'my-users';\nconst userId = 'me' of UserId; // 'me' of UserId\n// or\nconst userId: UserId = 'me'; // string of UserId\"><pre class=\"notranslate\"><span class=\"pl-k\">declare</span> <span class=\"pl-s1\">domain</span> <span class=\"pl-smi\">Xyz</span> <span class=\"pl-k\">of</span> <span class=\"pl-s\">'my-company/my-project/my-app'</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">UserId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">string</span> <span class=\"pl-s1\">of</span> <span class=\"pl-smi\">Xyz</span> <span class=\"pl-k\">of</span> <span class=\"pl-s\">'my-users'</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">userId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'me'</span> <span class=\"pl-k\">of</span> <span class=\"pl-smi\">UserId</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// 'me' of UserId</span>\n<span class=\"pl-c\">// or</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">userId</span>: <span class=\"pl-smi\">UserId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'me'</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// string of UserId</span></pre></div>\n<p dir=\"auto\">(edited)</p>",
        "createdAt": "2018-09-12T03:15:30Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420498156",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDQ5ODk2NQ==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "> depends, if `someArray` keys are nominal or not\r\n\r\nNote this one is an interesting case, as if you want to index arrays with nominal keys, you will also want the methods to take nominal keys for their index parameters:\r\n\r\n```ts\r\ninterface Arrayesqe<T, Index extends number = number> {\r\n  [index: Index]: T;\r\n  length: Index;\r\n  slice(start?: Index, end?: Index): Arrayesqe<T, Index>;\r\n  findIndex(value: T): Index | undefined;\r\n  // ...\r\n}\r\n```\r\n\r\nIf this is supported, should `Array<>` etc. be updated to match this? That could get really messy. (similar to my question on `string.slice()` above)",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">depends, if <code class=\"notranslate\">someArray</code> keys are nominal or not</p>\n</blockquote>\n<p dir=\"auto\">Note this one is an interesting case, as if you want to index arrays with nominal keys, you will also want the methods to take nominal keys for their index parameters:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"interface Arrayesqe&lt;T, Index extends number = number&gt; {\n  [index: Index]: T;\n  length: Index;\n  slice(start?: Index, end?: Index): Arrayesqe&lt;T, Index&gt;;\n  findIndex(value: T): Index | undefined;\n  // ...\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">interface</span> <span class=\"pl-smi\">Arrayesqe</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">Index</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-kos\">[</span><span class=\"pl-s1\">index</span>: <span class=\"pl-smi\">Index</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">T</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-c1\">length</span>: <span class=\"pl-smi\">Index</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-c1\">slice</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">start</span>?: <span class=\"pl-smi\">Index</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">end</span>?: <span class=\"pl-smi\">Index</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">Arrayesqe</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">Index</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-c1\">findIndex</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">value</span>: <span class=\"pl-smi\">T</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">Index</span> <span class=\"pl-c1\">|</span> <span class=\"pl-c1\">undefined</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-c\">// ...</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">If this is supported, should <code class=\"notranslate\">Array&lt;&gt;</code> etc. be updated to match this? That could get really messy. (similar to my question on <code class=\"notranslate\">string.slice()</code> above)</p>",
        "createdAt": "2018-09-12T03:20:51Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420498965",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDQ5OTc0OQ==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@aleksey-bykov \r\n\r\n> using strings for nominals could save the day, what bothers me is that each time you need the full path to declare a new nominal\r\n\r\nI see that more as a feature than as a bug. You should be encouraged to *not* try to make everything nominal - TS has never been that way, and one of the most common issues I've seen at least is trying to code TS like it's a C#/Java wannabe.\r\n\r\n> the history of XML namespaces declarations could be of help here, something like [code]\r\n\r\nHow about no. XML namespacing is boilerplatey trash, and it's even less useful for anything that doesn't deal with types exclusively.\r\n\r\nNote that I did propose one possible thing that *could* help (emphasis on proposed solution here):\r\n\r\n> - In the future, it might be okay to accept a regexp or **parameterized brand**.\r\n\r\nPending type-level string concatenation, if it were added, that could be addressed without actually adding anything specific.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Aleksey-Bykov/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Aleksey-Bykov\">@Aleksey-Bykov</a></p>\n<blockquote>\n<p dir=\"auto\">using strings for nominals could save the day, what bothers me is that each time you need the full path to declare a new nominal</p>\n</blockquote>\n<p dir=\"auto\">I see that more as a feature than as a bug. You should be encouraged to <em>not</em> try to make everything nominal - TS has never been that way, and one of the most common issues I've seen at least is trying to code TS like it's a C#/Java wannabe.</p>\n<blockquote>\n<p dir=\"auto\">the history of XML namespaces declarations could be of help here, something like [code]</p>\n</blockquote>\n<p dir=\"auto\">How about no. XML namespacing is boilerplatey trash, and it's even less useful for anything that doesn't deal with types exclusively.</p>\n<p dir=\"auto\">Note that I did propose one possible thing that <em>could</em> help (emphasis on proposed solution here):</p>\n<blockquote>\n<ul dir=\"auto\">\n<li>In the future, it might be okay to accept a regexp or <strong>parameterized brand</strong>.</li>\n</ul>\n</blockquote>\n<p dir=\"auto\">Pending type-level string concatenation, if it were added, that could be addressed without actually adding anything specific.</p>",
        "createdAt": "2018-09-12T03:26:02Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420499749",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDUwMDY3NQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "XML namespaces solved 2 things:\r\n- they were unique up to one nasty declaration\r\n- they were terse anywhere since\r\n\r\nso they were a piece of common sense that worked good enough for the task\r\n\r\nif string concatenation at the type level is here, it will help lot, have no problem with that, except that strings need to stay strings, and brands need something that distantiates them from strings",
        "bodyHTML": "<p dir=\"auto\">XML namespaces solved 2 things:</p>\n<ul dir=\"auto\">\n<li>they were unique up to one nasty declaration</li>\n<li>they were terse anywhere since</li>\n</ul>\n<p dir=\"auto\">so they were a piece of common sense that worked good enough for the task</p>\n<p dir=\"auto\">if string concatenation at the type level is here, it will help lot, have no problem with that, except that strings need to stay strings, and brands need something that distantiates them from strings</p>",
        "createdAt": "2018-09-12T03:32:34Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420500675",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMDk5NzA3Nw==",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "You don't need to declare the full type every time. I mean, I wrote a solution for this a couple of lines above, but I guess nobody read it - just use two brands:\r\n\r\nhttps://goo.gl/b8g5QK\r\n\r\n```typescript\r\n\r\n\r\nfunction makePackageBrands<PkgName extends string>(pkgname:PkgName) {\r\n    return function branded<T, Brand>() {\r\n        return class Type {\r\n            private value: Type;\r\n            private '__ kind': Brand;\r\n            private '__ package': PkgName;\r\n            static toBranded(t: T) { return t as any as Type; }\r\n            static fromBranded(b: Type) { return b as any as T }\r\n            static Type: Type;\r\n        }\r\n    }\r\n}\r\n\r\nlet branded = makePackageBrands('my-package');\r\n\r\nlet branded2 = makePackageBrands('other-package');\r\n\r\nlet OrderId = branded<string, 'OrderId'>()\r\ntype OrderId = typeof OrderId.Type;\r\n\r\n\r\nlet OrderId2 = branded2<string, 'OrderId'>()\r\ntype OrderId2 = typeof OrderId2.Type;\r\n\r\nlet x = OrderId.toBranded('someUuid')\r\nlet y = OrderId2.toBranded('someString');\r\nlet b1 = y == x;\r\nlet b2 = y == OrderId.fromBranded(x)\r\n\r\nlet m: Map<OrderId, string> = new Map;\r\n\r\nm.set(y, '1') // error\r\nm.set(x, '2') \r\n\r\n```\r\n\r\nThe error:\r\n\r\n```\r\nArgument of type \r\n    'makePackageBrands<\"other-package\">.branded<string, \"OrderId\">.Type' \r\n  is not assignable to parameter of type \r\n    'makePackageBrands<\"my-package\">.branded<string, \"OrderId\">.Type'.\r\n  Type '\"other-package\"' is not assignable to type '\"my-package\"'.\r\n```\r\n\r\nNo need to repeat the namespace now.\r\n\r\n",
        "bodyHTML": "<p dir=\"auto\">You don't need to declare the full type every time. I mean, I wrote a solution for this a couple of lines above, but I guess nobody read it - just use two brands:</p>\n<p dir=\"auto\"><a href=\"https://goo.gl/b8g5QK\" rel=\"nofollow\">https://goo.gl/b8g5QK</a></p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"\n\nfunction makePackageBrands&lt;PkgName extends string&gt;(pkgname:PkgName) {\n    return function branded&lt;T, Brand&gt;() {\n        return class Type {\n            private value: Type;\n            private '__ kind': Brand;\n            private '__ package': PkgName;\n            static toBranded(t: T) { return t as any as Type; }\n            static fromBranded(b: Type) { return b as any as T }\n            static Type: Type;\n        }\n    }\n}\n\nlet branded = makePackageBrands('my-package');\n\nlet branded2 = makePackageBrands('other-package');\n\nlet OrderId = branded&lt;string, 'OrderId'&gt;()\ntype OrderId = typeof OrderId.Type;\n\n\nlet OrderId2 = branded2&lt;string, 'OrderId'&gt;()\ntype OrderId2 = typeof OrderId2.Type;\n\nlet x = OrderId.toBranded('someUuid')\nlet y = OrderId2.toBranded('someString');\nlet b1 = y == x;\nlet b2 = y == OrderId.fromBranded(x)\n\nlet m: Map&lt;OrderId, string&gt; = new Map;\n\nm.set(y, '1') // error\nm.set(x, '2') \n\"><pre class=\"notranslate\"><span class=\"pl-k\">function</span> <span class=\"pl-en\">makePackageBrands</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">PkgName</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">string</span><span class=\"pl-c1\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">pkgname</span>:<span class=\"pl-smi\">PkgName</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-k\">function</span> <span class=\"pl-en\">branded</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-c1\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n        <span class=\"pl-k\">return</span> <span class=\"pl-k\">class</span> <span class=\"pl-smi\">Type</span> <span class=\"pl-kos\">{</span>\n            <span class=\"pl-k\">private</span> <span class=\"pl-c1\">value</span>: <span class=\"pl-smi\">Type</span><span class=\"pl-kos\">;</span>\n            <span class=\"pl-k\">private</span> <span class=\"pl-s\">'__ kind'</span>: <span class=\"pl-smi\">Brand</span><span class=\"pl-kos\">;</span>\n            <span class=\"pl-k\">private</span> <span class=\"pl-s\">'__ package'</span>: <span class=\"pl-smi\">PkgName</span><span class=\"pl-kos\">;</span>\n            <span class=\"pl-k\">static</span> <span class=\"pl-en\">toBranded</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">t</span>: <span class=\"pl-smi\">T</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">return</span> <span class=\"pl-s1\">t</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">any</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Type</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span>\n            <span class=\"pl-k\">static</span> <span class=\"pl-en\">fromBranded</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">b</span>: <span class=\"pl-smi\">Type</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">return</span> <span class=\"pl-s1\">b</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">any</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">T</span> <span class=\"pl-kos\">}</span>\n            <span class=\"pl-k\">static</span> <span class=\"pl-c1\">Type</span>: <span class=\"pl-smi\">Type</span><span class=\"pl-kos\">;</span>\n        <span class=\"pl-kos\">}</span>\n    <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">branded</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">makePackageBrands</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'my-package'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">branded2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">makePackageBrands</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'other-package'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-smi\">OrderId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">branded</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'OrderId'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">OrderId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">OrderId</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">Type</span><span class=\"pl-kos\">;</span>\n\n\n<span class=\"pl-k\">let</span> <span class=\"pl-smi\">OrderId2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">branded2</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'OrderId'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">OrderId2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">OrderId2</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">Type</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">OrderId</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">toBranded</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'someUuid'</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">y</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">OrderId2</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">toBranded</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'someString'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">b1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">y</span> <span class=\"pl-c1\">==</span> <span class=\"pl-s1\">x</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">b2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">y</span> <span class=\"pl-c1\">==</span> <span class=\"pl-smi\">OrderId</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">fromBranded</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span><span class=\"pl-kos\">)</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">m</span>: <span class=\"pl-smi\">Map</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">OrderId</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">string</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Map</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-s1\">m</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">set</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">y</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'1'</span><span class=\"pl-kos\">)</span> <span class=\"pl-c\">// error</span>\n<span class=\"pl-s1\">m</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">set</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'2'</span><span class=\"pl-kos\">)</span> </pre></div>\n<p dir=\"auto\">The error:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Argument of type \n    'makePackageBrands&lt;&quot;other-package&quot;&gt;.branded&lt;string, &quot;OrderId&quot;&gt;.Type' \n  is not assignable to parameter of type \n    'makePackageBrands&lt;&quot;my-package&quot;&gt;.branded&lt;string, &quot;OrderId&quot;&gt;.Type'.\n  Type '&quot;other-package&quot;' is not assignable to type '&quot;my-package&quot;'.\"><pre class=\"notranslate\"><code class=\"notranslate\">Argument of type \n    'makePackageBrands&lt;\"other-package\"&gt;.branded&lt;string, \"OrderId\"&gt;.Type' \n  is not assignable to parameter of type \n    'makePackageBrands&lt;\"my-package\"&gt;.branded&lt;string, \"OrderId\"&gt;.Type'.\n  Type '\"other-package\"' is not assignable to type '\"my-package\"'.\n</code></pre></div>\n<p dir=\"auto\">No need to repeat the namespace now.</p>",
        "createdAt": "2018-09-13T12:57:51Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-420997077",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMTAwMzM3Mw==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "@spion , your example works in the value domain and requires `typeof` for each brand, i hope you meant it only for demonstration purposes, otherwise i'd say it's rather awkward",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/spion/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/spion\">@spion</a> , your example works in the value domain and requires <code class=\"notranslate\">typeof</code> for each brand, i hope you meant it only for demonstration purposes, otherwise i'd say it's rather awkward</p>",
        "createdAt": "2018-09-13T13:17:36Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-421003373",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMTAzNTc4OQ==",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "Sure, you can also use \r\n\r\n```typescript\r\nclass OrderId extends branded<string, 'OrderId'>() {}\r\n\r\nclass OrderId2 extends branded2<string, 'OrderId'>() {}\r\n```\r\n\r\nif you like to convince the TS compiler to generate a type and a value at the same time. https://goo.gl/Dt7LS8\r\n\r\nDon't know a less awkward syntax to do that.",
        "bodyHTML": "<p dir=\"auto\">Sure, you can also use</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"class OrderId extends branded&lt;string, 'OrderId'&gt;() {}\n\nclass OrderId2 extends branded2&lt;string, 'OrderId'&gt;() {}\"><pre class=\"notranslate\"><span class=\"pl-k\">class</span> <span class=\"pl-smi\">OrderId</span> <span class=\"pl-k\">extends</span> <span class=\"pl-en\">branded</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'OrderId'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">class</span> <span class=\"pl-smi\">OrderId2</span> <span class=\"pl-k\">extends</span> <span class=\"pl-en\">branded2</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'OrderId'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">if you like to convince the TS compiler to generate a type and a value at the same time. <a href=\"https://goo.gl/Dt7LS8\" rel=\"nofollow\">https://goo.gl/Dt7LS8</a></p>\n<p dir=\"auto\">Don't know a less awkward syntax to do that.</p>",
        "createdAt": "2018-09-13T14:52:28Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-421035789",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMTA0MDUwNQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "less awkward syntax requires a direct intervention to the types domain, after all branding is about types, so it has to be something like:\r\n\r\ntype barand XXX = ...\r\nor \r\ndeclare brand XXX = ...\r\n\r\n(any values that you make for brands to work will be solely virtual, hence should not belong to values)\r\n",
        "bodyHTML": "<p dir=\"auto\">less awkward syntax requires a direct intervention to the types domain, after all branding is about types, so it has to be something like:</p>\n<p dir=\"auto\">type barand XXX = ...<br>\nor<br>\ndeclare brand XXX = ...</p>\n<p dir=\"auto\">(any values that you make for brands to work will be solely virtual, hence should not belong to values)</p>",
        "createdAt": "2018-09-13T15:05:19Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-421040505",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMTA0MTk0MQ==",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "They are virtual. The class and the private fields are completely a type level lie. `toBranded` returns the same value passed as the argument, only casted to this fake class. Nothing is wrapped. I only use the `class` keyword to convince TypeScript to make a type and a value at the same time (the value only holds the two methods used for conversion)...\r\n\r\nBut yeah - nicer syntax would be appreciated.",
        "bodyHTML": "<p dir=\"auto\">They are virtual. The class and the private fields are completely a type level lie. <code class=\"notranslate\">toBranded</code> returns the same value passed as the argument, only casted to this fake class. Nothing is wrapped. I only use the <code class=\"notranslate\">class</code> keyword to convince TypeScript to make a type and a value at the same time (the value only holds the two methods used for conversion)...</p>\n<p dir=\"auto\">But yeah - nicer syntax would be appreciated.</p>",
        "createdAt": "2018-09-13T15:09:30Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-421041941",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyMTM2OTcxMA==",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "Another reason I use `class` is because its is the only construct in the value domain that also creates a new type, which allows us to use curried functions as a substitute for curried generics\r\n\r\nIf we had something like:\r\n\r\n```typescript\r\ntype PBrand<PkgName> = <Type, Brand> {\r\n    value: Type;\r\n    '__ kind': Brand;\r\n    '__ package': PkgName;\r\n}\r\n\r\ntype Branded = PBrand<'my-package'>;\r\ntype OrderId = Branded<string, 'OrderID'>;\r\n```\r\n\r\nthat would also work, but we don't have it. \r\n",
        "bodyHTML": "<p dir=\"auto\">Another reason I use <code class=\"notranslate\">class</code> is because its is the only construct in the value domain that also creates a new type, which allows us to use curried functions as a substitute for curried generics</p>\n<p dir=\"auto\">If we had something like:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type PBrand&lt;PkgName&gt; = &lt;Type, Brand&gt; {\n    value: Type;\n    '__ kind': Brand;\n    '__ package': PkgName;\n}\n\ntype Branded = PBrand&lt;'my-package'&gt;;\ntype OrderId = Branded&lt;string, 'OrderID'&gt;;\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">PBrand</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">PkgName</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">Type</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">value</span>: <span class=\"pl-smi\">Type</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-s\">'__ kind'</span>: <span class=\"pl-smi\">Brand</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-s\">'__ package'</span>: <span class=\"pl-smi\">PkgName</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Branded</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">PBrand</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'my-package'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">OrderId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Branded</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'OrderID'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">that would also work, but we don't have it.</p>",
        "createdAt": "2018-09-14T14:07:20Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-421369710",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyOTU3ODE0OQ==",
        "author": {
          "login": "Chacha-26"
        },
        "authorAssociation": "NONE",
        "body": "Just discovered this technique that I've not found posted anywhere.\r\nI'm not confident that it'll keep working in the future though since it relies on silencing a compiler error, but it works in at least 2.8.1, 2.9.1, 3.0.1, and 3.1.1-insiders.20180926\r\nThere's probably a way of doing this without the error, but `@ts-ignore` works well enough for me.\r\n\r\n```ts\r\n// @ts-ignore: 'infer' declarations are only permitted in the 'extends' clause of a conditional type.\r\ntype Brand<T, B> = infer _ extends B ? T : never;\r\n```\r\nIt has the following behaviour:\r\nThere are no restrictions on the values of the `T` and `B` type parameters.\r\nGiven two different types `type X = Brand<TX, BX>` and `type Y = Brand<TY, BY>` then `X` is assignable to `Y` if and only if:\r\n1. `BX` and `BY` are _identical_ (I'm not sure on the specifics, but assignability is not sufficient)\r\n2. `TX` is assignable to `TY`\r\n\r\nCasting from `TX` to `X` is allowed, but must be explicit.\r\nCasting from `X` to `Y` is never allowed since \"neither type sufficiently overlaps with the other\".\r\n\r\nSome examples:\r\n```ts\r\ntype Id1 = Brand<string, \"id1\">;\r\ntype Id2 = Brand<string, \"id2\">;\r\ndeclare var id1: Id1, id2: Id2;\r\n\r\nid1 = \"foo\" as Id1; // OK with cast\r\nid1 = id1; // OK without cast\r\n\r\nid1 = \"foo\"; // Type '\"foo\"' is not assignable to type 'Brand<string, \"id1\">'.\r\nid1 = id2; // Type 'Brand<string, \"id2\">' is not assignable to type 'Brand<string, \"id1\">'.\r\nid1 as Id2; // Conversion of type 'Brand<string, \"id1\">' to type 'Brand<string, \"id2\">' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.\r\n```\r\n[Playground link](https://www.typescriptlang.org/play/#src=%2F%2F%20%40ts-ignore%0D%0Atype%20Brand%3CT%2C%20B%3E%20%3D%20infer%20_%20extends%20B%20%3F%20T%20%3A%20never%3B%0D%0A%0D%0Atype%20Id1%20%3D%20Brand%3Cstring%2C%20%22id1%22%3E%3B%0D%0Atype%20Id2%20%3D%20Brand%3Cstring%2C%20%22id2%22%3E%3B%0D%0Adeclare%20var%20id1%3A%20Id1%2C%20id2%3A%20Id2%3B%0D%0A%0D%0Aid1%20%3D%20%22foo%22%20as%20Id1%3B%0D%0Aid1%20%3D%20id1%3B%0D%0A%0D%0Aid1%20%3D%20%22foo%22%3B%0D%0Aid1%20%3D%20id2%3B%0D%0Aid1%20as%20Id2%3B)",
        "bodyHTML": "<p dir=\"auto\">Just discovered this technique that I've not found posted anywhere.<br>\nI'm not confident that it'll keep working in the future though since it relies on silencing a compiler error, but it works in at least 2.8.1, 2.9.1, 3.0.1, and 3.1.1-insiders.20180926<br>\nThere's probably a way of doing this without the error, but <code class=\"notranslate\">@ts-ignore</code> works well enough for me.</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// @ts-ignore: 'infer' declarations are only permitted in the 'extends' clause of a conditional type.\ntype Brand&lt;T, B&gt; = infer _ extends B ? T : never;\"><pre class=\"notranslate\"><span class=\"pl-c\">// <span class=\"pl-k\">@ts</span>-ignore: 'infer' declarations are only permitted in the 'extends' clause of a conditional type.</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">B</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> infer <span class=\"pl-smi\">_</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">B</span> ? <span class=\"pl-smi\">T</span> : <span class=\"pl-smi\">never</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">It has the following behaviour:<br>\nThere are no restrictions on the values of the <code class=\"notranslate\">T</code> and <code class=\"notranslate\">B</code> type parameters.<br>\nGiven two different types <code class=\"notranslate\">type X = Brand&lt;TX, BX&gt;</code> and <code class=\"notranslate\">type Y = Brand&lt;TY, BY&gt;</code> then <code class=\"notranslate\">X</code> is assignable to <code class=\"notranslate\">Y</code> if and only if:</p>\n<ol dir=\"auto\">\n<li><code class=\"notranslate\">BX</code> and <code class=\"notranslate\">BY</code> are <em>identical</em> (I'm not sure on the specifics, but assignability is not sufficient)</li>\n<li><code class=\"notranslate\">TX</code> is assignable to <code class=\"notranslate\">TY</code></li>\n</ol>\n<p dir=\"auto\">Casting from <code class=\"notranslate\">TX</code> to <code class=\"notranslate\">X</code> is allowed, but must be explicit.<br>\nCasting from <code class=\"notranslate\">X</code> to <code class=\"notranslate\">Y</code> is never allowed since \"neither type sufficiently overlaps with the other\".</p>\n<p dir=\"auto\">Some examples:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type Id1 = Brand&lt;string, &quot;id1&quot;&gt;;\ntype Id2 = Brand&lt;string, &quot;id2&quot;&gt;;\ndeclare var id1: Id1, id2: Id2;\n\nid1 = &quot;foo&quot; as Id1; // OK with cast\nid1 = id1; // OK without cast\n\nid1 = &quot;foo&quot;; // Type '&quot;foo&quot;' is not assignable to type 'Brand&lt;string, &quot;id1&quot;&gt;'.\nid1 = id2; // Type 'Brand&lt;string, &quot;id2&quot;&gt;' is not assignable to type 'Brand&lt;string, &quot;id1&quot;&gt;'.\nid1 as Id2; // Conversion of type 'Brand&lt;string, &quot;id1&quot;&gt;' to type 'Brand&lt;string, &quot;id2&quot;&gt;' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">Id1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">\"id1\"</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Id2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">\"id2\"</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">var</span> <span class=\"pl-s1\">id1</span>: <span class=\"pl-smi\">Id1</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">id2</span>: <span class=\"pl-smi\">Id2</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-s1\">id1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">\"foo\"</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Id1</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// OK with cast</span>\n<span class=\"pl-s1\">id1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">id1</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// OK without cast</span>\n\n<span class=\"pl-s1\">id1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">\"foo\"</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// Type '\"foo\"' is not assignable to type 'Brand&lt;string, \"id1\"&gt;'.</span>\n<span class=\"pl-s1\">id1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">id2</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// Type 'Brand&lt;string, \"id2\"&gt;' is not assignable to type 'Brand&lt;string, \"id1\"&gt;'.</span>\n<span class=\"pl-s1\">id1</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Id2</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// Conversion of type 'Brand&lt;string, \"id1\"&gt;' to type 'Brand&lt;string, \"id2\"&gt;' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.</span></pre></div>\n<p dir=\"auto\"><a href=\"https://www.typescriptlang.org/play/#src=%2F%2F%20%40ts-ignore%0D%0Atype%20Brand%3CT%2C%20B%3E%20%3D%20infer%20_%20extends%20B%20%3F%20T%20%3A%20never%3B%0D%0A%0D%0Atype%20Id1%20%3D%20Brand%3Cstring%2C%20%22id1%22%3E%3B%0D%0Atype%20Id2%20%3D%20Brand%3Cstring%2C%20%22id2%22%3E%3B%0D%0Adeclare%20var%20id1%3A%20Id1%2C%20id2%3A%20Id2%3B%0D%0A%0D%0Aid1%20%3D%20%22foo%22%20as%20Id1%3B%0D%0Aid1%20%3D%20id1%3B%0D%0A%0D%0Aid1%20%3D%20%22foo%22%3B%0D%0Aid1%20%3D%20id2%3B%0D%0Aid1%20as%20Id2%3B\" rel=\"nofollow\">Playground link</a></p>",
        "createdAt": "2018-10-13T21:50:40Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-429578149",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyOTU4NDQ4NA==",
        "author": {
          "login": "aaronjensen"
        },
        "authorAssociation": "NONE",
        "body": "@Chacha-26 interesting, though it [doesn't work with Records afaict](https://www.typescriptlang.org/play/#src=%2F%2F%20%40ts-ignore%0D%0Atype%20Brand%3CT%2C%20B%3E%20%3D%20infer%20_%20extends%20B%20%3F%20T%20%3A%20never%3B%0D%0A%0D%0Atype%20Id1%20%3D%20Brand%3Cstring%2C%20%22id1%22%3E%3B%0D%0Atype%20Id2%20%3D%20Brand%3Cstring%2C%20%22id2%22%3E%3B%0D%0Adeclare%20var%20id1%3A%20Id1%2C%20id2%3A%20Id2%3B%0D%0A%0D%0Aid1%20%3D%20%22foo%22%20as%20Id1%3B%0D%0Aid1%20%3D%20id1%3B%0D%0A%0D%0Atype%20R%20%3D%20Record%3CId1%2C%20boolean%3E%0D%0A%0D%0A%2F%2F%20cast%20required%0D%0Avar%20z%3A%20R%20%3D%20%7B%20%5Bid1%5D%3A%20true%20%7D%20as%20R%0D%0A%0D%0Avar%20x%20%3D%20z%5Bid1%5D%0D%0A%2F%2F%20should%20error%0D%0Ax%20%3D%20z%5B%22foob%22%5D%0D%0A%0D%0Aid1%20%3D%20%22foo%22%3B%0D%0Aid1%20%3D%20id2%3B%0D%0Aid1%20as%20Id2%3B)",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Chacha-26/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Chacha-26\">@Chacha-26</a> interesting, though it <a href=\"https://www.typescriptlang.org/play/#src=%2F%2F%20%40ts-ignore%0D%0Atype%20Brand%3CT%2C%20B%3E%20%3D%20infer%20_%20extends%20B%20%3F%20T%20%3A%20never%3B%0D%0A%0D%0Atype%20Id1%20%3D%20Brand%3Cstring%2C%20%22id1%22%3E%3B%0D%0Atype%20Id2%20%3D%20Brand%3Cstring%2C%20%22id2%22%3E%3B%0D%0Adeclare%20var%20id1%3A%20Id1%2C%20id2%3A%20Id2%3B%0D%0A%0D%0Aid1%20%3D%20%22foo%22%20as%20Id1%3B%0D%0Aid1%20%3D%20id1%3B%0D%0A%0D%0Atype%20R%20%3D%20Record%3CId1%2C%20boolean%3E%0D%0A%0D%0A%2F%2F%20cast%20required%0D%0Avar%20z%3A%20R%20%3D%20%7B%20%5Bid1%5D%3A%20true%20%7D%20as%20R%0D%0A%0D%0Avar%20x%20%3D%20z%5Bid1%5D%0D%0A%2F%2F%20should%20error%0D%0Ax%20%3D%20z%5B%22foob%22%5D%0D%0A%0D%0Aid1%20%3D%20%22foo%22%3B%0D%0Aid1%20%3D%20id2%3B%0D%0Aid1%20as%20Id2%3B\" rel=\"nofollow\">doesn't work with Records afaict</a></p>",
        "createdAt": "2018-10-13T23:48:38Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-429584484",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQyOTU4NzE5Nw==",
        "author": {
          "login": "Chacha-26"
        },
        "authorAssociation": "NONE",
        "body": "~Yeah, it doesn't seem to care for literal values at all in 3.1.1. It seems to work better in earlier versions though.~\r\n~Guarding against other brands and dot-properties seems to work at least:~\r\nEdit: Looks like it's just a no-implicit-any issue\r\n```ts\r\ndeclare var x: Record<Id1, boolean>;\r\nx[id1] = true; // OK\r\nx[\"a\"] = true; // Element implicitly has an 'any' type because type 'Record<Brand<string, \"id1\">, boolean>' has no index signature.\r\nx[123] = true; // Element implicitly has an 'any' type because type 'Record<Brand<string, \"id1\">, boolean>' has no index signature.\r\nx.aaaa = true; // Property 'aaaa' does not exist on type 'Record<Brand<string, \"id1\">, boolean>'.\r\nx[id2] = true; // Type 'Brand<string, \"id2\">' cannot be used to index type 'Record<Brand<string, \"id1\">, boolean>'.\r\n```",
        "bodyHTML": "<p dir=\"auto\"><del>Yeah, it doesn't seem to care for literal values at all in 3.1.1. It seems to work better in earlier versions though.</del><br>\n<del>Guarding against other brands and dot-properties seems to work at least:</del><br>\nEdit: Looks like it's just a no-implicit-any issue</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"declare var x: Record&lt;Id1, boolean&gt;;\nx[id1] = true; // OK\nx[&quot;a&quot;] = true; // Element implicitly has an 'any' type because type 'Record&lt;Brand&lt;string, &quot;id1&quot;&gt;, boolean&gt;' has no index signature.\nx[123] = true; // Element implicitly has an 'any' type because type 'Record&lt;Brand&lt;string, &quot;id1&quot;&gt;, boolean&gt;' has no index signature.\nx.aaaa = true; // Property 'aaaa' does not exist on type 'Record&lt;Brand&lt;string, &quot;id1&quot;&gt;, boolean&gt;'.\nx[id2] = true; // Type 'Brand&lt;string, &quot;id2&quot;&gt;' cannot be used to index type 'Record&lt;Brand&lt;string, &quot;id1&quot;&gt;, boolean&gt;'.\"><pre class=\"notranslate\"><span class=\"pl-k\">declare</span> <span class=\"pl-k\">var</span> <span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">Record</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Id1</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">boolean</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">x</span><span class=\"pl-kos\">[</span><span class=\"pl-s1\">id1</span><span class=\"pl-kos\">]</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">true</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// OK</span>\n<span class=\"pl-s1\">x</span><span class=\"pl-kos\">[</span><span class=\"pl-s\">\"a\"</span><span class=\"pl-kos\">]</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">true</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// Element implicitly has an 'any' type because type 'Record&lt;Brand&lt;string, \"id1\"&gt;, boolean&gt;' has no index signature.</span>\n<span class=\"pl-s1\">x</span><span class=\"pl-kos\">[</span><span class=\"pl-c1\">123</span><span class=\"pl-kos\">]</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">true</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// Element implicitly has an 'any' type because type 'Record&lt;Brand&lt;string, \"id1\"&gt;, boolean&gt;' has no index signature.</span>\n<span class=\"pl-s1\">x</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">aaaa</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">true</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// Property 'aaaa' does not exist on type 'Record&lt;Brand&lt;string, \"id1\"&gt;, boolean&gt;'.</span>\n<span class=\"pl-s1\">x</span><span class=\"pl-kos\">[</span><span class=\"pl-s1\">id2</span><span class=\"pl-kos\">]</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">true</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// Type 'Brand&lt;string, \"id2\"&gt;' cannot be used to index type 'Record&lt;Brand&lt;string, \"id1\"&gt;, boolean&gt;'.</span></pre></div>",
        "createdAt": "2018-10-14T00:50:28Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-429587197",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQzNjkwMDczOA==",
        "author": {
          "login": "miyaokamarina"
        },
        "authorAssociation": "NONE",
        "body": "This solution fails if brand strings are same:\r\n\r\n```ts\r\ntype Real = Brand<number, 'Real'>;\r\ntype Fake = Brand<number, 'Real'>;\r\n\r\ndeclare const real: Real;\r\ndeclare const fake: Fake;\r\n\r\nconst x: Real = fake; // I'm not a fake I told!\r\n```\r\n\r\nHere two solutions, both with declared unique-typed constants, `typeof` and `extends symbol`\r\n\r\nFirst, with `@ts-ignore`:\r\n\r\n```ts\r\n// @ts-ignore\r\ntype Brand<A, B extends symbol> = infer _ extends B ? A : never;\r\n\r\ndeclare const A: unique symbol;\r\nexport type A = Brand<number, typeof A>;\r\n\r\ndeclare const B: unique symbol;\r\nexport type B = Brand<number, typeof B>;\r\n\r\ndeclare const C: unique symbol;\r\nexport type C = Brand<object, typeof C>;\r\n\r\ndeclare const a: A;\r\ndeclare const b: B;\r\ndeclare const c: C;\r\n\r\nconst d: A = 0;      // error, ok\r\nconst e: A = b;      // error, ok\r\nconst f: A = b as A; // error, ok\r\n\r\nconst g: A      = 0 as A; // no error, ok\r\nconst h: A      = a;      // no error, ok\r\nconst i: A | B  = a;      // no error, ok\r\nconst j: number = a;      // no error, ok\r\n\r\nconst k: object = 0; // error, ok\r\nconst l: object = a; // error, ok\r\n\r\nconst m: object = c; // no error, ok\r\n```\r\n\r\nSecond:\r\n\r\n```ts\r\ntype Brand<A, B extends symbol> =\r\n    A extends void | undefined | null | symbol\r\n    ? A\r\n    : A & { [B]: B };\r\n// <...>\r\nconst l: object = a; // no error, not ok\r\n// <...>\r\n```\r\n\r\nThis solution doesn't abuse compiler errors, but all primitives become objects.\r\n\r\nPossible third solution:\r\n\r\n```ts\r\n// `brand` keyword as type-level `Symbol()`\r\ntype A = brand;\r\ntype B = brand;\r\ntype C = number & brand;\r\ntype D = number & brand;\r\n\r\ndeclare const a1: A;\r\ndeclare const b1: B;\r\ndeclare const c1: C;\r\ndeclare const d1: D;\r\n\r\nconst a2: A = b1; // error\r\nconst b2: B = a1; // error\r\nconst c2: C = d1; // error\r\nconst d2: D = c1; // error\r\n\r\ntype Brand<T> = T & brand;\r\n```",
        "bodyHTML": "<p dir=\"auto\">This solution fails if brand strings are same:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type Real = Brand&lt;number, 'Real'&gt;;\ntype Fake = Brand&lt;number, 'Real'&gt;;\n\ndeclare const real: Real;\ndeclare const fake: Fake;\n\nconst x: Real = fake; // I'm not a fake I told!\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">Real</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'Real'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Fake</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'Real'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">real</span>: <span class=\"pl-smi\">Real</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">fake</span>: <span class=\"pl-smi\">Fake</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">Real</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">fake</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// I'm not a fake I told!</span></pre></div>\n<p dir=\"auto\">Here two solutions, both with declared unique-typed constants, <code class=\"notranslate\">typeof</code> and <code class=\"notranslate\">extends symbol</code></p>\n<p dir=\"auto\">First, with <code class=\"notranslate\">@ts-ignore</code>:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// @ts-ignore\ntype Brand&lt;A, B extends symbol&gt; = infer _ extends B ? A : never;\n\ndeclare const A: unique symbol;\nexport type A = Brand&lt;number, typeof A&gt;;\n\ndeclare const B: unique symbol;\nexport type B = Brand&lt;number, typeof B&gt;;\n\ndeclare const C: unique symbol;\nexport type C = Brand&lt;object, typeof C&gt;;\n\ndeclare const a: A;\ndeclare const b: B;\ndeclare const c: C;\n\nconst d: A = 0;      // error, ok\nconst e: A = b;      // error, ok\nconst f: A = b as A; // error, ok\n\nconst g: A      = 0 as A; // no error, ok\nconst h: A      = a;      // no error, ok\nconst i: A | B  = a;      // no error, ok\nconst j: number = a;      // no error, ok\n\nconst k: object = 0; // error, ok\nconst l: object = a; // error, ok\n\nconst m: object = c; // no error, ok\"><pre class=\"notranslate\"><span class=\"pl-c\">// <span class=\"pl-k\">@ts</span>-ignore</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">A</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">B</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">symbol</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> infer <span class=\"pl-smi\">_</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">B</span> ? <span class=\"pl-smi\">A</span> : <span class=\"pl-smi\">never</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">A</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">A</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">,</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">A</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">B</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">B</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">,</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">B</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">C</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">C</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">object</span><span class=\"pl-kos\">,</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">C</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">a</span>: <span class=\"pl-smi\">A</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">b</span>: <span class=\"pl-smi\">B</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">c</span>: <span class=\"pl-smi\">C</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">d</span>: <span class=\"pl-smi\">A</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">0</span><span class=\"pl-kos\">;</span>      <span class=\"pl-c\">// error, ok</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">e</span>: <span class=\"pl-smi\">A</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">b</span><span class=\"pl-kos\">;</span>      <span class=\"pl-c\">// error, ok</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">f</span>: <span class=\"pl-smi\">A</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">b</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">A</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error, ok</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">g</span>: <span class=\"pl-smi\">A</span>      <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">0</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">A</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// no error, ok</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">h</span>: <span class=\"pl-smi\">A</span>      <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">a</span><span class=\"pl-kos\">;</span>      <span class=\"pl-c\">// no error, ok</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">i</span>: <span class=\"pl-smi\">A</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">B</span>  <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">a</span><span class=\"pl-kos\">;</span>      <span class=\"pl-c\">// no error, ok</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">j</span>: <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">a</span><span class=\"pl-kos\">;</span>      <span class=\"pl-c\">// no error, ok</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">k</span>: <span class=\"pl-smi\">object</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">0</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error, ok</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">l</span>: <span class=\"pl-smi\">object</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">a</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error, ok</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">m</span>: <span class=\"pl-smi\">object</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">c</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// no error, ok</span></pre></div>\n<p dir=\"auto\">Second:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type Brand&lt;A, B extends symbol&gt; =\n    A extends void | undefined | null | symbol\n    ? A\n    : A &amp; { [B]: B };\n// &lt;...&gt;\nconst l: object = a; // no error, not ok\n// &lt;...&gt;\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">A</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">B</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">symbol</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span>\n    <span class=\"pl-smi\">A</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\"><span class=\"pl-k\">void</span></span> <span class=\"pl-c1\">|</span> <span class=\"pl-c1\">undefined</span> <span class=\"pl-c1\">|</span> <span class=\"pl-c1\">null</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">symbol</span>\n    ? <span class=\"pl-smi\">A</span>\n    : <span class=\"pl-smi\">A</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">[</span><span class=\"pl-smi\">B</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">B</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-c\">// &lt;...&gt;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">l</span>: <span class=\"pl-smi\">object</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">a</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// no error, not ok</span>\n<span class=\"pl-c\">// &lt;...&gt;</span></pre></div>\n<p dir=\"auto\">This solution doesn't abuse compiler errors, but all primitives become objects.</p>\n<p dir=\"auto\">Possible third solution:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// `brand` keyword as type-level `Symbol()`\ntype A = brand;\ntype B = brand;\ntype C = number &amp; brand;\ntype D = number &amp; brand;\n\ndeclare const a1: A;\ndeclare const b1: B;\ndeclare const c1: C;\ndeclare const d1: D;\n\nconst a2: A = b1; // error\nconst b2: B = a1; // error\nconst c2: C = d1; // error\nconst d2: D = c1; // error\n\ntype Brand&lt;T&gt; = T &amp; brand;\"><pre class=\"notranslate\"><span class=\"pl-c\">// `brand` keyword as type-level `Symbol()`</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">A</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">brand</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">B</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">brand</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">C</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">brand</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">D</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">brand</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">a1</span>: <span class=\"pl-smi\">A</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">b1</span>: <span class=\"pl-smi\">B</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">c1</span>: <span class=\"pl-smi\">C</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">d1</span>: <span class=\"pl-smi\">D</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">a2</span>: <span class=\"pl-smi\">A</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">b1</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">b2</span>: <span class=\"pl-smi\">B</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">a1</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">c2</span>: <span class=\"pl-smi\">C</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">d1</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">d2</span>: <span class=\"pl-smi\">D</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">c1</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">brand</span><span class=\"pl-kos\">;</span></pre></div>",
        "createdAt": "2018-11-08T07:38:26Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-436900738",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQzNzIxNTc2MQ==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "What about expanding `unique symbol` to just any `unique T` for arbitrary types? This could solve almost the entire issue here, preventing people from mixing up types while still allowing coercion as necessary.",
        "bodyHTML": "<p dir=\"auto\">What about expanding <code class=\"notranslate\">unique symbol</code> to just any <code class=\"notranslate\">unique T</code> for arbitrary types? This could solve almost the entire issue here, preventing people from mixing up types while still allowing coercion as necessary.</p>",
        "createdAt": "2018-11-09T01:18:35Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-437215761",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQzNzIxOTk3OA==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "The syntax is not the problem. Check the links to Ryan's comments to this thread to why we don't have this yet I posted in this comment: https://github.com/Microsoft/TypeScript/issues/202#issuecomment-420497456",
        "bodyHTML": "<p dir=\"auto\">The syntax is not the problem. Check the links to Ryan's comments to this thread to why we don't have this yet I posted in this comment: <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard?comment_id=420497456&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-420497456\">#202 (comment)</a></p>",
        "createdAt": "2018-11-09T01:40:01Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-437219978",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQzNzMwNjQ1NQ==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@RyanCavanaugh So here's what I'm thinking:\r\n\r\n`unique symbol` exists to provide uniquely branded symbols already. This is well-established practice and exists to account for the fact people often use symbols as property keys. So for obvious reasons, native `Symbol.iterator` doesn't replace Node's `util.inspect.custom`.\r\n\r\nWe could expand that from symbols to all types by allowing arbitrary type expressions via `unique Type` instead of just `symbol`. Conceptually, it's quite simple and non-invasive, so I don't think it's a major change apart from the keyword reuse.\r\n\r\nSemantically, it'd work the same way as `unique symbol` does now, just with other types:\r\n\r\n- `unique` types are uniquely generated subtypes of their underlying type.\r\n\t- This means they are assignable to their underlying type, but you can't assign `0` to a `unique number` without a downcast.\r\n\r\n- `unique` types are not considered assignable to any other `unique` type.\r\n\r\n- `(unique A) & B` is assignable to `A & B`, but is not equivalent.\r\n\t- `string & (unique unknown)` is assignable to `string`, but not `never`.\r\n\t- `unknown & (unique string)` is assignable to `string`, but not `never`.\r\n\t- `number & (unique string)` is assignable to `never`.\r\n\t- More formally, type-checking `positive` succeeds and checking `negative` fails: `declare const test: (unique A) & B; const positive: A & B = test; const negative: typeof test = positive`\r\n\r\n- `(unique A) & (unique B)` is assignable to `A & B`, but is not equivalent.\r\n\t- `(unique string) & (unique unknown)` is assignable to `string`, but not `never`.\r\n\t- `(unique number) & (unique string)` is assignable to `never`.\r\n\t- More formally, type-checking `positive` succeeds and checking `negative` fails: `declare const test: (unique A) & (unique B); const target: A & B = test; const negative: typeof test = positive`\r\n\r\n- If you create generic `unique` types that depend on a generic type variable, it considers separate instantiations as not equal, but aliases retain identity. This is to retain the fact generics are equal to their fully expanded selves, that `Taint<number>` is equivalent to specifying `unique number` inline in the example below, even though it means `Foo<T>` no longer necessarily equals `Foo<T>` in the general case.\r\n\r\n\t<details>\r\n\t<summary>For a concrete example of how this works in practice:</summary>\r\n\r\n\t```ts\r\n\ttype Taint<T> = unique T\r\n\ttype Alias = Taint<number>\r\n\t\r\n\t// Pass\r\n\tdeclare const foo: Alias\r\n\tconst bar: Alias = foo // works\r\n\t\r\n\t// Fail\r\n\tdeclare const foo: Alias\r\n\tconst bar: Taint<number> = foo // error: incompatible types\r\n\t\r\n\t// Fail\r\n\tdeclare const foo: Taint<number>\r\n\tconst bar: Alias = foo // error: incompatible types\r\n\t\r\n\t// Fail\r\n\tdeclare const foo: Taint<number>\r\n\tconst bar: Taint<number> = foo // error: incompatible types\r\n\t```\r\n\t\r\n\tIn each of these cases, here's what TypeScript would see as per this proposal, after generic expansion (this makes the errors a lot more obvious):\r\n\t\r\n\t```ts\r\n\ttype Alias = unique number\r\n\ttype T0 = unique number\r\n\ttype T1 = unique number\r\n\ttype T2 = unique number\r\n\ttype T3 = unique number\r\n\t\r\n\t// Pass\r\n\tdeclare const foo: Alias\r\n\tconst bar: Alias = foo // works\r\n\t\r\n\t// Fail\r\n\tdeclare const foo: Alias\r\n\tconst bar: T0 = foo // error: incompatible types\r\n\t\r\n\t// Fail\r\n\tdeclare const foo: T1\r\n\tconst bar: Alias = foo // error: incompatible types\r\n\t\r\n\t// Fail\r\n\tdeclare const foo: T2\r\n\tconst bar: T3 = foo // error: incompatible types\r\n\t```\r\n\t</details>\r\n\r\nThis is similar to Flow's [opaque types](https://flow.org/en/docs/types/opaque-types/), but the info is carried with the *type* instead of the *reference*. This is the key difference, and it's more flexible (you can pass it as a generic parameter), a simpler to teach and understand, and easier to implement.\r\n\r\nHere's a few concrete areas where unique types could be useful today:\r\n\r\n- The DOM's `nodeType` property generally only makes sense as an enum value, but it's documented more like an anonymous enum rather than an actual enum type.\r\n\r\n\t<details>\r\n\t<summary>You could treat that correctly *as* an anonymous enum if you do this:</summary>\r\n\r\n\t```ts\r\n\tinterface NodeConstructor {\r\n\t\tELEMENT_NODE: unique 1;\r\n\t\tTEXT_NODE: unique 3;\r\n\t\tCDATA_SECTION_NODE: unique 4;\r\n\t\tPROCESSING_INSTRUCTION_NODE: unique 7;\r\n\t\tCOMMENT_NODE: unique 8;\r\n\t\tDOCUMENT_NODE: unique 9;\r\n\t\tDOCUMENT_TYPE_NODE: unique 10;\r\n\t\tDOCUMENT_FRAGMENT_NODE: unique 11;\r\n\t}\r\n\tinterface Node {\r\n\t\tnodeType: typeof Node.ELEMENT_NODE |\r\n\t\t\ttypeof Node.TEXT_NODE |\r\n\t\t\ttypeof Node.CDATA_SECTION_NODE |\r\n\t\t\ttypeof Node.PROCESSING_INSTRUCTION_NODE |\r\n\t\t\ttypeof Node.COMMENT_NODE |\r\n\t\t\ttypeof Node.DOCUMENT_NODE |\r\n\t\t\ttypeof Node.DOCUMENT_TYPE_NODE |\r\n\t\t\ttypeof Node.DOCUMENT_FRAGMENT_NODE;\r\n\t}\r\n\tinterface Element extends Node { nodeType: typeof Node.ELEMENT_NODE; }\r\n\tinterface Text extends Node { nodeType: typeof Node.TEXT_NODE; }\r\n\tinterface CDATASection extends Node { nodeType: typeof Node.CDATA_SECTION_NODE; }\r\n\tinterface ProcessingInstruction extends Node { nodeType: typeof Node.PROCESSING_INSTRUCTION_NODE; }\r\n\tinterface Comment extends Node { nodeType: typeof Node.COMMENT_NODE; }\r\n\tinterface Document extends Node { nodeType: typeof Node.DOCUMENT_NODE; }\r\n\tinterface DocumentType extends Node { nodeType: typeof Node.DOCUMENT_TYPE_NODE; }\r\n\tinterface DocumentFragment extends Node { nodeType: typeof Node.DOCUMENT_FRAGMENT_NODE; }\r\n\t```\r\n\t</details>\r\n\r\n- [glMatrix's values](http://glmatrix.net/docs/module-mat2.html) are all typed arrays, but it makes more sense to alias them as stuff like `type Matrix2D = unique (Float64Array & {length: 4})` and so on. You *could* theoretically pass arbitrary typed arrays to it, but it generally wouldn't work unless the lengths are correct. So in this case, nominal types are appropriate for preventing bugs and type mixups here. (Typed arrays are incredibly common with performance-sensitive game code, and they're used for a variety of things, including WebGL data.)\r\n\r\n- Node's [async hooks API](https://nodejs.org/api/async_hooks.html) provides integer IDs, but you should only give it what it generates. This can only realistically be enforced by accepting and exposing only `type AsyncID = unique number`: you shouldn't use arbitrary `numbers`, even though they are exposed as such.\r\n\r\nThis proposal is flexible enough to cover a few more cases:\r\n\r\n- You can easily emulate branding in a relatively hack-free way:\r\n\r\n\t```ts\r\n\ttype Foo = ... // some magical type\r\n\ttype Brand = unique unknown\r\n\ttype BrandedFoo = Foo & Brand\r\n\t```\r\n\r\n- You could enforce limited static taint checking pretty easily, with some help with generics and conditional types:\r\n\r\n\t```ts\r\n\ttype Tainted = unique unknown\r\n\t\r\n\tdeclare function getUserInput(): string & Tainted\r\n\tdeclare function doSomethingTrusted<T extends string>(\r\n\t\tfoo: T extends Tainted ? never : T\r\n\t): void\r\n\t\r\n\tdoSomethingTrusted(\"not user input\") // okay\r\n\tdoSomethingTrusted(getUserInput()) // error\r\n\tdoSomethingTrusted<string>(getUserInput()) // escape hatch\r\n\t\r\n\t// N.B.: this is also a place where proper existentials could help - I could\r\n\t// drop the generic.\r\n\t```\r\n\t\r\n- Purely nominal types could be emulated by only exposing and accepting their `unique` form, rather than the structural form. In fact, I do this with Node's async hooks API above.\r\n\r\n- You could redefine enums as a union of their members, all typed as `unique 0` and similar, with minimal functional breakage. These can then become almost pure sugar rather than complicated primitives during type checking - the only thing lacking is the ability to define a type-level namespace that doesn't exist at the value level. The payoffs may seem abstract for this, but it becomes a lot easier to reason about, and you have fewer weird quirks like [this](https://www.typescriptlang.org/play/index.html#src=enum%20Direction%20%7B%20Up%20%3D%201%20%7D%0D%0Aconst%20foo%3A%20%22Up%22%20%3D%20Direction%5BDirection.Up%5D). At the very least, you can use this in the formal model to verify the compiler and ensure logical consistency.\r\n\r\n\t<details>\r\n\t<summary>For a concrete example from the docs:</summary>\r\n\r\n\tLink: https://www.typescriptlang.org/docs/handbook/enums.html\r\n\r\n\t```ts\r\n\t// Sugar\r\n\tenum Direction {\r\n\t\tUp = 1,\r\n\t\tDown,\r\n\t\tLeft,\r\n\t\tRight,\r\n\t}\r\n\r\n\t// Desugared\r\n\ttype namespace Direction { // This is more pseudo-syntax\r\n\t\texport type Up = unique 1\r\n\t\texport type Down = unique 2\r\n\t\texport type Left = unique 3\r\n\t\texport type Right = unique 4\r\n\t}\r\n\ttype Direction = Direction.Up | Direction.Down | Direction.Left | Direction.Right;\r\n\tconst Direction = {\r\n\t\tUp: 1 as Direction.Up, [1 as Direction.Up]: \"Up\",\r\n\t\tDown: 2 as Direction.Down, [2 as Direction.Down]: \"Down\",\r\n\t\tLeft: 3 as Direction.Left, [3 as Direction.Left]: \"Left\",\r\n\t\tRight: 4 as Direction.Right, [4 as Direction.Right]: \"Right\",\r\n\t};\r\n\r\n\t// Sugar\r\n\tconst enum Direction {\r\n\t\tUp = 1,\r\n\t\tDown,\r\n\t\tLeft,\r\n\t\tRight,\r\n\t}\r\n\r\n\t// Desugared\r\n\tnamespace Direction {\r\n\t\texport type Up = unique 1; export const Up = 1 as Up\r\n\t\texport type Down = unique 2; export const Down = 2 as Down\r\n\t\texport type Left = unique 3; export const Left = 3 as Left\r\n\t\texport type Right = unique 4; export const Right = 4 as Right\r\n\t}\r\n\ttype Direction = Direction.Up | Direction.Down | Direction.Left | Direction.Right;\r\n\t```\r\n\t</details>\r\n\r\nWhat are your thoughts on it? I tried to keep it relatively small here and light on hacks, leaving most of the desired functionality to just fall out of the system naturally. (I know you were [looking for a proposal](https://github.com/Microsoft/TypeScript/issues/202#issuecomment-49829643) with some [real-world examples](https://github.com/Microsoft/TypeScript/issues/202#issuecomment-69646899).)",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/RyanCavanaugh/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/RyanCavanaugh\">@RyanCavanaugh</a> So here's what I'm thinking:</p>\n<p dir=\"auto\"><code class=\"notranslate\">unique symbol</code> exists to provide uniquely branded symbols already. This is well-established practice and exists to account for the fact people often use symbols as property keys. So for obvious reasons, native <code class=\"notranslate\">Symbol.iterator</code> doesn't replace Node's <code class=\"notranslate\">util.inspect.custom</code>.</p>\n<p dir=\"auto\">We could expand that from symbols to all types by allowing arbitrary type expressions via <code class=\"notranslate\">unique Type</code> instead of just <code class=\"notranslate\">symbol</code>. Conceptually, it's quite simple and non-invasive, so I don't think it's a major change apart from the keyword reuse.</p>\n<p dir=\"auto\">Semantically, it'd work the same way as <code class=\"notranslate\">unique symbol</code> does now, just with other types:</p>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">unique</code> types are uniquely generated subtypes of their underlying type.</p>\n<ul dir=\"auto\">\n<li>This means they are assignable to their underlying type, but you can't assign <code class=\"notranslate\">0</code> to a <code class=\"notranslate\">unique number</code> without a downcast.</li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">unique</code> types are not considered assignable to any other <code class=\"notranslate\">unique</code> type.</p>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">(unique A) &amp; B</code> is assignable to <code class=\"notranslate\">A &amp; B</code>, but is not equivalent.</p>\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">string &amp; (unique unknown)</code> is assignable to <code class=\"notranslate\">string</code>, but not <code class=\"notranslate\">never</code>.</li>\n<li><code class=\"notranslate\">unknown &amp; (unique string)</code> is assignable to <code class=\"notranslate\">string</code>, but not <code class=\"notranslate\">never</code>.</li>\n<li><code class=\"notranslate\">number &amp; (unique string)</code> is assignable to <code class=\"notranslate\">never</code>.</li>\n<li>More formally, type-checking <code class=\"notranslate\">positive</code> succeeds and checking <code class=\"notranslate\">negative</code> fails: <code class=\"notranslate\">declare const test: (unique A) &amp; B; const positive: A &amp; B = test; const negative: typeof test = positive</code></li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\"><code class=\"notranslate\">(unique A) &amp; (unique B)</code> is assignable to <code class=\"notranslate\">A &amp; B</code>, but is not equivalent.</p>\n<ul dir=\"auto\">\n<li><code class=\"notranslate\">(unique string) &amp; (unique unknown)</code> is assignable to <code class=\"notranslate\">string</code>, but not <code class=\"notranslate\">never</code>.</li>\n<li><code class=\"notranslate\">(unique number) &amp; (unique string)</code> is assignable to <code class=\"notranslate\">never</code>.</li>\n<li>More formally, type-checking <code class=\"notranslate\">positive</code> succeeds and checking <code class=\"notranslate\">negative</code> fails: <code class=\"notranslate\">declare const test: (unique A) &amp; (unique B); const target: A &amp; B = test; const negative: typeof test = positive</code></li>\n</ul>\n</li>\n<li>\n<p dir=\"auto\">If you create generic <code class=\"notranslate\">unique</code> types that depend on a generic type variable, it considers separate instantiations as not equal, but aliases retain identity. This is to retain the fact generics are equal to their fully expanded selves, that <code class=\"notranslate\">Taint&lt;number&gt;</code> is equivalent to specifying <code class=\"notranslate\">unique number</code> inline in the example below, even though it means <code class=\"notranslate\">Foo&lt;T&gt;</code> no longer necessarily equals <code class=\"notranslate\">Foo&lt;T&gt;</code> in the general case.</p>\n  <details>\n  <summary>For a concrete example of how this works in practice:</summary>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\" type Taint&lt;T&gt; = unique T\n type Alias = Taint&lt;number&gt;\n \n // Pass\n declare const foo: Alias\n const bar: Alias = foo // works\n \n // Fail\n declare const foo: Alias\n const bar: Taint&lt;number&gt; = foo // error: incompatible types\n \n // Fail\n declare const foo: Taint&lt;number&gt;\n const bar: Alias = foo // error: incompatible types\n \n // Fail\n declare const foo: Taint&lt;number&gt;\n const bar: Taint&lt;number&gt; = foo // error: incompatible types\"><pre class=\"notranslate\"> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Taint</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">T</span>\n <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Alias</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Taint</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span>\n \n <span class=\"pl-c\">// Pass</span>\n <span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">foo</span>: <span class=\"pl-smi\">Alias</span>\n <span class=\"pl-k\">const</span> <span class=\"pl-s1\">bar</span>: <span class=\"pl-smi\">Alias</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">foo</span> <span class=\"pl-c\">// works</span>\n \n <span class=\"pl-c\">// Fail</span>\n <span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">foo</span>: <span class=\"pl-smi\">Alias</span>\n <span class=\"pl-k\">const</span> <span class=\"pl-s1\">bar</span>: <span class=\"pl-smi\">Taint</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">foo</span> <span class=\"pl-c\">// error: incompatible types</span>\n \n <span class=\"pl-c\">// Fail</span>\n <span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">foo</span>: <span class=\"pl-smi\">Taint</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span>\n <span class=\"pl-k\">const</span> <span class=\"pl-s1\">bar</span>: <span class=\"pl-smi\">Alias</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">foo</span> <span class=\"pl-c\">// error: incompatible types</span>\n \n <span class=\"pl-c\">// Fail</span>\n <span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">foo</span>: <span class=\"pl-smi\">Taint</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span>\n <span class=\"pl-k\">const</span> <span class=\"pl-s1\">bar</span>: <span class=\"pl-smi\">Taint</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">foo</span> <span class=\"pl-c\">// error: incompatible types</span></pre></div>\n<p dir=\"auto\">In each of these cases, here's what TypeScript would see as per this proposal, after generic expansion (this makes the errors a lot more obvious):</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\" type Alias = unique number\n type T0 = unique number\n type T1 = unique number\n type T2 = unique number\n type T3 = unique number\n \n // Pass\n declare const foo: Alias\n const bar: Alias = foo // works\n \n // Fail\n declare const foo: Alias\n const bar: T0 = foo // error: incompatible types\n \n // Fail\n declare const foo: T1\n const bar: Alias = foo // error: incompatible types\n \n // Fail\n declare const foo: T2\n const bar: T3 = foo // error: incompatible types\"><pre class=\"notranslate\"> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Alias</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">number</span>\n <span class=\"pl-k\">type</span> <span class=\"pl-smi\">T0</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">number</span>\n <span class=\"pl-k\">type</span> <span class=\"pl-smi\">T1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">number</span>\n <span class=\"pl-k\">type</span> <span class=\"pl-smi\">T2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">number</span>\n <span class=\"pl-k\">type</span> <span class=\"pl-smi\">T3</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">number</span>\n \n <span class=\"pl-c\">// Pass</span>\n <span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">foo</span>: <span class=\"pl-smi\">Alias</span>\n <span class=\"pl-k\">const</span> <span class=\"pl-s1\">bar</span>: <span class=\"pl-smi\">Alias</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">foo</span> <span class=\"pl-c\">// works</span>\n \n <span class=\"pl-c\">// Fail</span>\n <span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">foo</span>: <span class=\"pl-smi\">Alias</span>\n <span class=\"pl-k\">const</span> <span class=\"pl-s1\">bar</span>: <span class=\"pl-smi\">T0</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">foo</span> <span class=\"pl-c\">// error: incompatible types</span>\n \n <span class=\"pl-c\">// Fail</span>\n <span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">foo</span>: <span class=\"pl-smi\">T1</span>\n <span class=\"pl-k\">const</span> <span class=\"pl-s1\">bar</span>: <span class=\"pl-smi\">Alias</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">foo</span> <span class=\"pl-c\">// error: incompatible types</span>\n \n <span class=\"pl-c\">// Fail</span>\n <span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">foo</span>: <span class=\"pl-smi\">T2</span>\n <span class=\"pl-k\">const</span> <span class=\"pl-s1\">bar</span>: <span class=\"pl-smi\">T3</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">foo</span> <span class=\"pl-c\">// error: incompatible types</span></pre></div>\n  </details>\n</li>\n</ul>\n<p dir=\"auto\">This is similar to Flow's <a href=\"https://flow.org/en/docs/types/opaque-types/\" rel=\"nofollow\">opaque types</a>, but the info is carried with the <em>type</em> instead of the <em>reference</em>. This is the key difference, and it's more flexible (you can pass it as a generic parameter), a simpler to teach and understand, and easier to implement.</p>\n<p dir=\"auto\">Here's a few concrete areas where unique types could be useful today:</p>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">The DOM's <code class=\"notranslate\">nodeType</code> property generally only makes sense as an enum value, but it's documented more like an anonymous enum rather than an actual enum type.</p>\n  <details>\n  <summary>You could treat that correctly *as* an anonymous enum if you do this:</summary>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\" interface NodeConstructor {\n \tELEMENT_NODE: unique 1;\n \tTEXT_NODE: unique 3;\n \tCDATA_SECTION_NODE: unique 4;\n \tPROCESSING_INSTRUCTION_NODE: unique 7;\n \tCOMMENT_NODE: unique 8;\n \tDOCUMENT_NODE: unique 9;\n \tDOCUMENT_TYPE_NODE: unique 10;\n \tDOCUMENT_FRAGMENT_NODE: unique 11;\n }\n interface Node {\n \tnodeType: typeof Node.ELEMENT_NODE |\n \t\ttypeof Node.TEXT_NODE |\n \t\ttypeof Node.CDATA_SECTION_NODE |\n \t\ttypeof Node.PROCESSING_INSTRUCTION_NODE |\n \t\ttypeof Node.COMMENT_NODE |\n \t\ttypeof Node.DOCUMENT_NODE |\n \t\ttypeof Node.DOCUMENT_TYPE_NODE |\n \t\ttypeof Node.DOCUMENT_FRAGMENT_NODE;\n }\n interface Element extends Node { nodeType: typeof Node.ELEMENT_NODE; }\n interface Text extends Node { nodeType: typeof Node.TEXT_NODE; }\n interface CDATASection extends Node { nodeType: typeof Node.CDATA_SECTION_NODE; }\n interface ProcessingInstruction extends Node { nodeType: typeof Node.PROCESSING_INSTRUCTION_NODE; }\n interface Comment extends Node { nodeType: typeof Node.COMMENT_NODE; }\n interface Document extends Node { nodeType: typeof Node.DOCUMENT_NODE; }\n interface DocumentType extends Node { nodeType: typeof Node.DOCUMENT_TYPE_NODE; }\n interface DocumentFragment extends Node { nodeType: typeof Node.DOCUMENT_FRAGMENT_NODE; }\"><pre class=\"notranslate\"> <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">NodeConstructor</span> <span class=\"pl-kos\">{</span>\n \t<span class=\"pl-c1\">ELEMENT_NODE</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-c1\">1</span><span class=\"pl-kos\">;</span>\n \t<span class=\"pl-c1\">TEXT_NODE</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-c1\">3</span><span class=\"pl-kos\">;</span>\n \t<span class=\"pl-c1\">CDATA_SECTION_NODE</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-c1\">4</span><span class=\"pl-kos\">;</span>\n \t<span class=\"pl-c1\">PROCESSING_INSTRUCTION_NODE</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-c1\">7</span><span class=\"pl-kos\">;</span>\n \t<span class=\"pl-c1\">COMMENT_NODE</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-c1\">8</span><span class=\"pl-kos\">;</span>\n \t<span class=\"pl-c1\">DOCUMENT_NODE</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-c1\">9</span><span class=\"pl-kos\">;</span>\n \t<span class=\"pl-c1\">DOCUMENT_TYPE_NODE</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-c1\">10</span><span class=\"pl-kos\">;</span>\n \t<span class=\"pl-c1\">DOCUMENT_FRAGMENT_NODE</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-c1\">11</span><span class=\"pl-kos\">;</span>\n <span class=\"pl-kos\">}</span>\n <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">Node</span> <span class=\"pl-kos\">{</span>\n \t<span class=\"pl-c1\">nodeType</span>: <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">ELEMENT_NODE</span> <span class=\"pl-c1\">|</span>\n \t\t<span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">TEXT_NODE</span> <span class=\"pl-c1\">|</span>\n \t\t<span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">CDATA_SECTION_NODE</span> <span class=\"pl-c1\">|</span>\n \t\t<span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">PROCESSING_INSTRUCTION_NODE</span> <span class=\"pl-c1\">|</span>\n \t\t<span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">COMMENT_NODE</span> <span class=\"pl-c1\">|</span>\n \t\t<span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">DOCUMENT_NODE</span> <span class=\"pl-c1\">|</span>\n \t\t<span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">DOCUMENT_TYPE_NODE</span> <span class=\"pl-c1\">|</span>\n \t\t<span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">DOCUMENT_FRAGMENT_NODE</span><span class=\"pl-kos\">;</span>\n <span class=\"pl-kos\">}</span>\n <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">Element</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Node</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">nodeType</span>: <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">ELEMENT_NODE</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span>\n <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">Text</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Node</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">nodeType</span>: <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">TEXT_NODE</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span>\n <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">CDATASection</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Node</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">nodeType</span>: <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">CDATA_SECTION_NODE</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span>\n <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">ProcessingInstruction</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Node</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">nodeType</span>: <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">PROCESSING_INSTRUCTION_NODE</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span>\n <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">Comment</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Node</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">nodeType</span>: <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">COMMENT_NODE</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span>\n <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">Document</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Node</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">nodeType</span>: <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">DOCUMENT_NODE</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span>\n <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">DocumentType</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Node</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">nodeType</span>: <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">DOCUMENT_TYPE_NODE</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span>\n <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">DocumentFragment</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Node</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">nodeType</span>: <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Node</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">DOCUMENT_FRAGMENT_NODE</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span></pre></div>\n  </details>\n</li>\n<li>\n<p dir=\"auto\"><a href=\"http://glmatrix.net/docs/module-mat2.html\" rel=\"nofollow\">glMatrix's values</a> are all typed arrays, but it makes more sense to alias them as stuff like <code class=\"notranslate\">type Matrix2D = unique (Float64Array &amp; {length: 4})</code> and so on. You <em>could</em> theoretically pass arbitrary typed arrays to it, but it generally wouldn't work unless the lengths are correct. So in this case, nominal types are appropriate for preventing bugs and type mixups here. (Typed arrays are incredibly common with performance-sensitive game code, and they're used for a variety of things, including WebGL data.)</p>\n</li>\n<li>\n<p dir=\"auto\">Node's <a href=\"https://nodejs.org/api/async_hooks.html\" rel=\"nofollow\">async hooks API</a> provides integer IDs, but you should only give it what it generates. This can only realistically be enforced by accepting and exposing only <code class=\"notranslate\">type AsyncID = unique number</code>: you shouldn't use arbitrary <code class=\"notranslate\">numbers</code>, even though they are exposed as such.</p>\n</li>\n</ul>\n<p dir=\"auto\">This proposal is flexible enough to cover a few more cases:</p>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">You can easily emulate branding in a relatively hack-free way:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\" type Foo = ... // some magical type\n type Brand = unique unknown\n type BrandedFoo = Foo &amp; Brand\"><pre class=\"notranslate\"> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Foo</span> <span class=\"pl-c1\">=</span> ... <span class=\"pl-c\">// some magical type</span>\n <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Brand</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">unknown</span>\n <span class=\"pl-k\">type</span> <span class=\"pl-smi\">BrandedFoo</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Foo</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">Brand</span></pre></div>\n</li>\n<li>\n<p dir=\"auto\">You could enforce limited static taint checking pretty easily, with some help with generics and conditional types:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\" type Tainted = unique unknown\n \n declare function getUserInput(): string &amp; Tainted\n declare function doSomethingTrusted&lt;T extends string&gt;(\n \tfoo: T extends Tainted ? never : T\n ): void\n \n doSomethingTrusted(&quot;not user input&quot;) // okay\n doSomethingTrusted(getUserInput()) // error\n doSomethingTrusted&lt;string&gt;(getUserInput()) // escape hatch\n \n // N.B.: this is also a place where proper existentials could help - I could\n // drop the generic.\"><pre class=\"notranslate\"> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Tainted</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">unknown</span>\n \n <span class=\"pl-k\">declare</span> <span class=\"pl-k\">function</span> <span class=\"pl-s1\">getUserInput</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">string</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">Tainted</span>\n <span class=\"pl-k\">declare</span> <span class=\"pl-k\">function</span> <span class=\"pl-s1\">doSomethingTrusted</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">string</span><span class=\"pl-c1\">&gt;</span><span class=\"pl-kos\">(</span>\n \t<span class=\"pl-s1\">foo</span>: <span class=\"pl-smi\">T</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Tainted</span> ? <span class=\"pl-smi\">never</span> : <span class=\"pl-smi\">T</span>\n <span class=\"pl-kos\">)</span>: <span class=\"pl-smi\"><span class=\"pl-k\">void</span></span>\n \n <span class=\"pl-en\">doSomethingTrusted</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"not user input\"</span><span class=\"pl-kos\">)</span> <span class=\"pl-c\">// okay</span>\n <span class=\"pl-en\">doSomethingTrusted</span><span class=\"pl-kos\">(</span><span class=\"pl-en\">getUserInput</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span> <span class=\"pl-c\">// error</span>\n <span class=\"pl-en\">doSomethingTrusted</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-en\">getUserInput</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span> <span class=\"pl-c\">// escape hatch</span>\n \n <span class=\"pl-c\">// N.B.: this is also a place where proper existentials could help - I could</span>\n <span class=\"pl-c\">// drop the generic.</span></pre></div>\n</li>\n<li>\n<p dir=\"auto\">Purely nominal types could be emulated by only exposing and accepting their <code class=\"notranslate\">unique</code> form, rather than the structural form. In fact, I do this with Node's async hooks API above.</p>\n</li>\n<li>\n<p dir=\"auto\">You could redefine enums as a union of their members, all typed as <code class=\"notranslate\">unique 0</code> and similar, with minimal functional breakage. These can then become almost pure sugar rather than complicated primitives during type checking - the only thing lacking is the ability to define a type-level namespace that doesn't exist at the value level. The payoffs may seem abstract for this, but it becomes a lot easier to reason about, and you have fewer weird quirks like <a href=\"https://www.typescriptlang.org/play/index.html#src=enum%20Direction%20%7B%20Up%20%3D%201%20%7D%0D%0Aconst%20foo%3A%20%22Up%22%20%3D%20Direction%5BDirection.Up%5D\" rel=\"nofollow\">this</a>. At the very least, you can use this in the formal model to verify the compiler and ensure logical consistency.</p>\n  <details>\n  <summary>For a concrete example from the docs:</summary>\n<p dir=\"auto\">Link: <a href=\"https://www.typescriptlang.org/docs/handbook/enums.html\" rel=\"nofollow\">https://www.typescriptlang.org/docs/handbook/enums.html</a></p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\" // Sugar\n enum Direction {\n \tUp = 1,\n \tDown,\n \tLeft,\n \tRight,\n }\n\n // Desugared\n type namespace Direction { // This is more pseudo-syntax\n \texport type Up = unique 1\n \texport type Down = unique 2\n \texport type Left = unique 3\n \texport type Right = unique 4\n }\n type Direction = Direction.Up | Direction.Down | Direction.Left | Direction.Right;\n const Direction = {\n \tUp: 1 as Direction.Up, [1 as Direction.Up]: &quot;Up&quot;,\n \tDown: 2 as Direction.Down, [2 as Direction.Down]: &quot;Down&quot;,\n \tLeft: 3 as Direction.Left, [3 as Direction.Left]: &quot;Left&quot;,\n \tRight: 4 as Direction.Right, [4 as Direction.Right]: &quot;Right&quot;,\n };\n\n // Sugar\n const enum Direction {\n \tUp = 1,\n \tDown,\n \tLeft,\n \tRight,\n }\n\n // Desugared\n namespace Direction {\n \texport type Up = unique 1; export const Up = 1 as Up\n \texport type Down = unique 2; export const Down = 2 as Down\n \texport type Left = unique 3; export const Left = 3 as Left\n \texport type Right = unique 4; export const Right = 4 as Right\n }\n type Direction = Direction.Up | Direction.Down | Direction.Left | Direction.Right;\"><pre class=\"notranslate\"> <span class=\"pl-c\">// Sugar</span>\n <span class=\"pl-k\">enum</span> <span class=\"pl-smi\">Direction</span> <span class=\"pl-kos\">{</span>\n \t<span class=\"pl-c1\">Up</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">1</span><span class=\"pl-kos\">,</span>\n \t<span class=\"pl-c1\">Down</span><span class=\"pl-kos\">,</span>\n \t<span class=\"pl-c1\">Left</span><span class=\"pl-kos\">,</span>\n \t<span class=\"pl-c1\">Right</span><span class=\"pl-kos\">,</span>\n <span class=\"pl-kos\">}</span>\n\n <span class=\"pl-c\">// Desugared</span>\n <span class=\"pl-k\">type</span> <span class=\"pl-s1\">namespace</span> <span class=\"pl-smi\">Direction</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c\">// This is more pseudo-syntax</span>\n \t<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Up</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-c1\">1</span>\n \t<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Down</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-c1\">2</span>\n \t<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Left</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-c1\">3</span>\n \t<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Right</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">unique</span> <span class=\"pl-c1\">4</span>\n <span class=\"pl-kos\">}</span>\n <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Direction</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Direction</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Up</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">Direction</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Down</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">Direction</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Left</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">Direction</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Right</span><span class=\"pl-kos\">;</span>\n <span class=\"pl-k\">const</span> <span class=\"pl-smi\">Direction</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span>\n \t<span class=\"pl-c1\">Up</span>: <span class=\"pl-c1\">1</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Direction</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Up</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">[</span><span class=\"pl-c1\">1</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Direction</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Up</span><span class=\"pl-kos\">]</span>: <span class=\"pl-s\">\"Up\"</span><span class=\"pl-kos\">,</span>\n \t<span class=\"pl-c1\">Down</span>: <span class=\"pl-c1\">2</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Direction</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Down</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">[</span><span class=\"pl-c1\">2</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Direction</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Down</span><span class=\"pl-kos\">]</span>: <span class=\"pl-s\">\"Down\"</span><span class=\"pl-kos\">,</span>\n \t<span class=\"pl-c1\">Left</span>: <span class=\"pl-c1\">3</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Direction</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Left</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">[</span><span class=\"pl-c1\">3</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Direction</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Left</span><span class=\"pl-kos\">]</span>: <span class=\"pl-s\">\"Left\"</span><span class=\"pl-kos\">,</span>\n \t<span class=\"pl-c1\">Right</span>: <span class=\"pl-c1\">4</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Direction</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Right</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">[</span><span class=\"pl-c1\">4</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Direction</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Right</span><span class=\"pl-kos\">]</span>: <span class=\"pl-s\">\"Right\"</span><span class=\"pl-kos\">,</span>\n <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n <span class=\"pl-c\">// Sugar</span>\n <span class=\"pl-k\">const</span> <span class=\"pl-k\">enum</span> <span class=\"pl-smi\">Direction</span> <span class=\"pl-kos\">{</span>\n \t<span class=\"pl-c1\">Up</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">1</span><span class=\"pl-kos\">,</span>\n \t<span class=\"pl-c1\">Down</span><span class=\"pl-kos\">,</span>\n \t<span class=\"pl-c1\">Left</span><span class=\"pl-kos\">,</span>\n \t<span class=\"pl-c1\">Right</span><span class=\"pl-kos\">,</span>\n <span class=\"pl-kos\">}</span>\n\n <span class=\"pl-c\">// Desugared</span>\n <span class=\"pl-k\">namespace</span> <span class=\"pl-smi\">Direction</span> <span class=\"pl-kos\">{</span>\n \t<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Up</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">unique</span> <span class=\"pl-c1\">1</span><span class=\"pl-kos\">;</span> <span class=\"pl-k\">export</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">Up</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">1</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Up</span>\n \t<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Down</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">unique</span> <span class=\"pl-c1\">2</span><span class=\"pl-kos\">;</span> <span class=\"pl-k\">export</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">Down</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">2</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Down</span>\n \t<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Left</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">unique</span> <span class=\"pl-c1\">3</span><span class=\"pl-kos\">;</span> <span class=\"pl-k\">export</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">Left</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">3</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Left</span>\n \t<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Right</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">unique</span> <span class=\"pl-c1\">4</span><span class=\"pl-kos\">;</span> <span class=\"pl-k\">export</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">Right</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">4</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Right</span>\n <span class=\"pl-kos\">}</span>\n <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Direction</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Direction</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Up</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">Direction</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Down</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">Direction</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Left</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">Direction</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Right</span><span class=\"pl-kos\">;</span></pre></div>\n  </details>\n</li>\n</ul>\n<p dir=\"auto\">What are your thoughts on it? I tried to keep it relatively small here and light on hacks, leaving most of the desired functionality to just fall out of the system naturally. (I know you were <a href=\"https://github.com/Microsoft/TypeScript/issues/202#issuecomment-49829643\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">looking for a proposal</a> with some <a href=\"https://github.com/Microsoft/TypeScript/issues/202#issuecomment-69646899\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">real-world examples</a>.)</p>",
        "createdAt": "2018-11-09T09:46:30Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-437306455",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 20
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 6
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQzNzM1NDEyNg==",
        "author": {
          "login": "Kinrany"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows  \r\nHow do we instantiate `unique` types without type assertions?",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows<br>\nHow do we instantiate <code class=\"notranslate\">unique</code> types without type assertions?</p>",
        "createdAt": "2018-11-09T13:06:54Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-437354126",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQzNzQzNTQ3Mw==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@Kinrany `unique` types are just type-level expressions, no different than `keyof T` or `Foo<T>` syntactically. So if you want to name them, you'll have to use a type alias.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Kinrany/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Kinrany\">@Kinrany</a> <code class=\"notranslate\">unique</code> types are just type-level expressions, no different than <code class=\"notranslate\">keyof T</code> or <code class=\"notranslate\">Foo&lt;T&gt;</code> syntactically. So if you want to name them, you'll have to use a type alias.</p>",
        "createdAt": "2018-11-09T17:34:31Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-437435473",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQzNzQ0NDM4Mg==",
        "author": {
          "login": "weswigham"
        },
        "authorAssociation": "MEMBER",
        "body": "> We could expand that from symbols to all types by allowing arbitrary type expressions via unique Type instead of just symbol. \r\n\r\nWe've had this at the back of our minds since we added `unique symbol` - it's actually why `unique` is implemented in the AST as a keyword type operator like `keyof` already.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">We could expand that from symbols to all types by allowing arbitrary type expressions via unique Type instead of just symbol.</p>\n</blockquote>\n<p dir=\"auto\">We've had this at the back of our minds since we added <code class=\"notranslate\">unique symbol</code> - it's actually why <code class=\"notranslate\">unique</code> is implemented in the AST as a keyword type operator like <code class=\"notranslate\">keyof</code> already.</p>",
        "createdAt": "2018-11-09T18:05:32Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-437444382",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 7
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 7
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQzNzQ0NTg2NA==",
        "author": {
          "login": "Kinrany"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows \r\nI mean, how do we create values with `unique` types?\r\n```typescript\r\ntype Foo = unique 'bar' | 'baz';\r\nconst bar: Foo = <Foo> 'bar'; // potentially unsafe?\r\n```\r\n\r\nAnother thing: would something like this work?\r\n```typescript\r\ntype Foo = unique 'bar' | 'baz';\r\ntype Bar = unique (Foo & 'bar');\r\nconst bar1: Bar = <Foo> 'bar'; // error: Foo not assignable to Bar\r\nconst bar2: Bar = <Bar> 'bar'; // error: 'bar' not assignable to Foo\r\nconst bar3: Bar = <Bar> <Foo> 'bar'; // no error\r\n```",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows<br>\nI mean, how do we create values with <code class=\"notranslate\">unique</code> types?</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type Foo = unique 'bar' | 'baz';\nconst bar: Foo = &lt;Foo&gt; 'bar'; // potentially unsafe?\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">Foo</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-s\">'bar'</span> <span class=\"pl-c1\">|</span> <span class=\"pl-s\">'baz'</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">bar</span>: <span class=\"pl-smi\">Foo</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Foo</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-s\">'bar'</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// potentially unsafe?</span></pre></div>\n<p dir=\"auto\">Another thing: would something like this work?</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type Foo = unique 'bar' | 'baz';\ntype Bar = unique (Foo &amp; 'bar');\nconst bar1: Bar = &lt;Foo&gt; 'bar'; // error: Foo not assignable to Bar\nconst bar2: Bar = &lt;Bar&gt; 'bar'; // error: 'bar' not assignable to Foo\nconst bar3: Bar = &lt;Bar&gt; &lt;Foo&gt; 'bar'; // no error\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">Foo</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-s\">'bar'</span> <span class=\"pl-c1\">|</span> <span class=\"pl-s\">'baz'</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Bar</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-kos\">(</span><span class=\"pl-smi\">Foo</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-s\">'bar'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">bar1</span>: <span class=\"pl-smi\">Bar</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Foo</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-s\">'bar'</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error: Foo not assignable to Bar</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">bar2</span>: <span class=\"pl-smi\">Bar</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Bar</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-s\">'bar'</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error: 'bar' not assignable to Foo</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">bar3</span>: <span class=\"pl-smi\">Bar</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Bar</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Foo</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-s\">'bar'</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// no error</span></pre></div>",
        "createdAt": "2018-11-09T18:10:48Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-437445864",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQzNzQ0NjMwMA==",
        "author": {
          "login": "weswigham"
        },
        "authorAssociation": "MEMBER",
        "body": "The same way classes with privates are made - you have a function defined to return one or you cast or narrow to it.",
        "bodyHTML": "<p dir=\"auto\">The same way classes with privates are made - you have a function defined to return one or you cast or narrow to it.</p>",
        "createdAt": "2018-11-09T18:12:19Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-437446300",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQzNzQ4MjA4NQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows how does your proposal address multiversioning?",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows how does your proposal address multiversioning?</p>",
        "createdAt": "2018-11-09T20:14:58Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-437482085",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQzNzQ5NjY3OA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@aleksey-bykov Two things:\r\n\r\n1. If two versions are compatible, the package manager is usually good enough. The type definitions get resolved to the same file, so it just works.\r\n2. If two versions are incompatible, you probably don't want to keep the nominal types as compatible, either. They might be managed differently, and the behavior might be different, so you shouldn't try to mix the two.\r\n\r\nIf you *really* want to escape (rarely necessary), use `value as any/unknown as NewType`, something you already sometimes have to do for other more arcane scenarios like casting between two enum types. If you find yourself doing this frequently, you could implement version translation yourself via generics and conditional types like this:\r\n\r\n```ts\r\ntype TranslateV1<T> =\r\n\tT extends V2.Foo ? V1.Foo :\r\n\tT extends V2.Bar<infer U> ? V1.Bar<U> :\r\n\t// etc.\r\n\tnever\r\n```\r\n\r\nBut if you're doing it so often it merits using this kind of utility everywhere, you should be fixing your code base to either to use *structural* types instead or to only use one version. (If you're migrating versions, you're already fixing it, so it's not a real problem.)",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Aleksey-Bykov/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Aleksey-Bykov\">@Aleksey-Bykov</a> Two things:</p>\n<ol dir=\"auto\">\n<li>If two versions are compatible, the package manager is usually good enough. The type definitions get resolved to the same file, so it just works.</li>\n<li>If two versions are incompatible, you probably don't want to keep the nominal types as compatible, either. They might be managed differently, and the behavior might be different, so you shouldn't try to mix the two.</li>\n</ol>\n<p dir=\"auto\">If you <em>really</em> want to escape (rarely necessary), use <code class=\"notranslate\">value as any/unknown as NewType</code>, something you already sometimes have to do for other more arcane scenarios like casting between two enum types. If you find yourself doing this frequently, you could implement version translation yourself via generics and conditional types like this:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type TranslateV1&lt;T&gt; =\n\tT extends V2.Foo ? V1.Foo :\n\tT extends V2.Bar&lt;infer U&gt; ? V1.Bar&lt;U&gt; :\n\t// etc.\n\tnever\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">TranslateV1</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span>\n\t<span class=\"pl-smi\">T</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">V2</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Foo</span> ? <span class=\"pl-smi\">V1</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Foo</span> :\n\t<span class=\"pl-smi\">T</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">V2</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Bar</span><span class=\"pl-kos\">&lt;</span>infer <span class=\"pl-smi\">U</span><span class=\"pl-kos\">&gt;</span> ? <span class=\"pl-smi\">V1</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">Bar</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">U</span><span class=\"pl-kos\">&gt;</span> :\n\t<span class=\"pl-c\">// etc.</span>\n\t<span class=\"pl-smi\">never</span></pre></div>\n<p dir=\"auto\">But if you're doing it so often it merits using this kind of utility everywhere, you should be fixing your code base to either to use <em>structural</em> types instead or to only use one version. (If you're migrating versions, you're already fixing it, so it's not a real problem.)</p>",
        "createdAt": "2018-11-09T21:12:31Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-437496678",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQzNzUwMzYwMw==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows i understand the mechanics of nominals vs structurals, so i can definitely come up with a hack to make versions work, questions is rather what would other 75% of developers do, from what you said they will be suffering until they master TS enough to be able to make their own hacks around these stiff nominals, so we basically sweep the problem under the rug",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows i understand the mechanics of nominals vs structurals, so i can definitely come up with a hack to make versions work, questions is rather what would other 75% of developers do, from what you said they will be suffering until they master TS enough to be able to make their own hacks around these stiff nominals, so we basically sweep the problem under the rug</p>",
        "createdAt": "2018-11-09T21:40:27Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-437503603",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ0NzE5NDMwNw==",
        "author": {
          "login": "ORESoftware"
        },
        "authorAssociation": "NONE",
        "body": "Don't use `<Named>`, just use `<Exact>` or some sheet like that. I agree that introducing nominal types to a structurally typed language is bad because nominal types are too restrictive and ultimately what I don't like about Java etc. Because nominal types make writing library code too hard.",
        "bodyHTML": "<p dir=\"auto\">Don't use <code class=\"notranslate\">&lt;Named&gt;</code>, just use <code class=\"notranslate\">&lt;Exact&gt;</code> or some sheet like that. I agree that introducing nominal types to a structurally typed language is bad because nominal types are too restrictive and ultimately what I don't like about Java etc. Because nominal types make writing library code too hard.</p>",
        "createdAt": "2018-12-14T02:43:33Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-447194307",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ0NzY3ODU0OQ==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@ORESoftware TS `enum`s are themselves nominal subtypes, so keep that in mind. 😉 ",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/ORESoftware/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ORESoftware\">@ORESoftware</a> TS <code class=\"notranslate\">enum</code>s are themselves nominal subtypes, so keep that in mind. 😉</p>",
        "createdAt": "2018-12-16T21:41:26Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-447678549",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ0NzY4MTM3NA==",
        "author": {
          "login": "ORESoftware"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows I'd be willing to bet enums in TS can be used structurally, I think I am right:\r\n\r\n![screenshot from 2018-12-16 14-19-28](https://user-images.githubusercontent.com/11139560/50059576-a4bd1a00-013d-11e9-8dd0-913aeaa995bb.png)\r\n",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows I'd be willing to bet enums in TS can be used structurally, I think I am right:</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://user-images.githubusercontent.com/11139560/50059576-a4bd1a00-013d-11e9-8dd0-913aeaa995bb.png\"><img src=\"https://user-images.githubusercontent.com/11139560/50059576-a4bd1a00-013d-11e9-8dd0-913aeaa995bb.png\" alt=\"screenshot from 2018-12-16 14-19-28\" style=\"max-width: 100%;\"></a></p>",
        "createdAt": "2018-12-16T22:19:59Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-447681374",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ0NzY4MjE1NA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@ORESoftware [That's only with implicit downcasting](https://www.typescriptlang.org/play/index.html#src=enum%20Foo%20%7B%20One%20%3D%201%20%7D%0D%0Aenum%20Bar%20%7B%20One%20%3D%201%20%7D%0D%0A%0D%0Aconst%20foo1%3A%20Foo%20%3D%201%0D%0Aconst%20foo2%3A%20Foo%20%3D%20Bar.One%0D%0Aconst%20foo3%3A%20Foo.One%20%3D%201%0D%0Aconst%20foo4%3A%20Foo.One%20%3D%20Bar.One)",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/ORESoftware/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ORESoftware\">@ORESoftware</a> <a href=\"https://www.typescriptlang.org/play/index.html#src=enum%20Foo%20%7B%20One%20%3D%201%20%7D%0D%0Aenum%20Bar%20%7B%20One%20%3D%201%20%7D%0D%0A%0D%0Aconst%20foo1%3A%20Foo%20%3D%201%0D%0Aconst%20foo2%3A%20Foo%20%3D%20Bar.One%0D%0Aconst%20foo3%3A%20Foo.One%20%3D%201%0D%0Aconst%20foo4%3A%20Foo.One%20%3D%20Bar.One\" rel=\"nofollow\">That's only with implicit downcasting</a></p>",
        "createdAt": "2018-12-16T22:28:30Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-447682154",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ0NzY4NTg1Nw==",
        "author": {
          "login": "ORESoftware"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows try it with objects instead of primitives and post results here, I tried and couldn't figure out how to do it",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows try it with objects instead of primitives and post results here, I tried and couldn't figure out how to do it</p>",
        "createdAt": "2018-12-16T23:17:17Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-447685857",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ0NzcxMjA4NQ==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@ORESoftware That's why this feature request exists. 😉\r\n\r\nBTW, the reason people want nominal types is because not everything can be typed structurally. For example, consider server input (which obviously can't be used directly when building database calls) or units (kilometers should *not* be assignable to feet). Also, JS `instanceof` is nominal, so TS typing classes structurally and narrowing based on `instanceof` is technically incorrect here. It also prevents them from soundly eliminating cases like the `else` in [this](https://www.typescriptlang.org/play/index.html#src=class%20A%20%7B%20name%20%3D%20%22A%22%20%7D%0D%0Aclass%20B%20%7B%20name%20%3D%20%22B%22%20%7D%0D%0A%0D%0Afunction%20foo()%20%7B%0D%0A%20%20%20%20var%20a%3A%20A%20%3D%20new%20B()%0D%0A%0D%0A%20%20%20%20if%20(a%20instanceof%20A)%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20%22foo%22%0D%0A%20%20%20%20%7D%20else%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20%22bar%22%0D%0A%20%20%20%20%7D%0D%0A%7D).",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/ORESoftware/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ORESoftware\">@ORESoftware</a> That's why this feature request exists. 😉</p>\n<p dir=\"auto\">BTW, the reason people want nominal types is because not everything can be typed structurally. For example, consider server input (which obviously can't be used directly when building database calls) or units (kilometers should <em>not</em> be assignable to feet). Also, JS <code class=\"notranslate\">instanceof</code> is nominal, so TS typing classes structurally and narrowing based on <code class=\"notranslate\">instanceof</code> is technically incorrect here. It also prevents them from soundly eliminating cases like the <code class=\"notranslate\">else</code> in <a href=\"https://www.typescriptlang.org/play/index.html#src=class%20A%20%7B%20name%20%3D%20%22A%22%20%7D%0D%0Aclass%20B%20%7B%20name%20%3D%20%22B%22%20%7D%0D%0A%0D%0Afunction%20foo()%20%7B%0D%0A%20%20%20%20var%20a%3A%20A%20%3D%20new%20B()%0D%0A%0D%0A%20%20%20%20if%20(a%20instanceof%20A)%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20%22foo%22%0D%0A%20%20%20%20%7D%20else%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20%22bar%22%0D%0A%20%20%20%20%7D%0D%0A%7D\" rel=\"nofollow\">this</a>.</p>",
        "createdAt": "2018-12-17T03:29:02Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-447712085",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ0Nzc3NDY3OQ==",
        "author": {
          "login": "ORESoftware"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows I am not saying I am against the feature, but note that this also compiles:\r\n\r\n![screenshot from 2018-12-17 01-19-00](https://user-images.githubusercontent.com/11139560/50077672-e24f9080-0199-11e9-871f-949549a775e7.png)\r\n",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows I am not saying I am against the feature, but note that this also compiles:</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://user-images.githubusercontent.com/11139560/50077672-e24f9080-0199-11e9-871f-949549a775e7.png\"><img src=\"https://user-images.githubusercontent.com/11139560/50077672-e24f9080-0199-11e9-871f-949549a775e7.png\" alt=\"screenshot from 2018-12-17 01-19-00\" style=\"max-width: 100%;\"></a></p>",
        "createdAt": "2018-12-17T09:20:11Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-447774679",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1NDc1NzI5Mw==",
        "author": {
          "login": "lll000111"
        },
        "authorAssociation": "NONE",
        "body": "My use case, implemented thus far using Flow *(posting here because we are considering to move to TS at some point)* [and its opaque type alias feature](https://flow.org/en/docs/types/opaque-types/): In a global library file I have\r\n\r\n    declare opaque type SHA256Hash: string;\r\n\r\nThe hex representation of SHA-256 hashes is a string, but very, very few strings are SHA-256 hashes. Obviously, especially since our code has lots and lots of them, I'm better off with the type system using a different type for those kinds of strings and not accepting any string where a `SHA256Hash` is needed. There probably are lots of similar use cases just with strings.",
        "bodyHTML": "<p dir=\"auto\">My use case, implemented thus far using Flow <em>(posting here because we are considering to move to TS at some point)</em> <a href=\"https://flow.org/en/docs/types/opaque-types/\" rel=\"nofollow\">and its opaque type alias feature</a>: In a global library file I have</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"declare opaque type SHA256Hash: string;\"><pre class=\"notranslate\"><code class=\"notranslate\">declare opaque type SHA256Hash: string;\n</code></pre></div>\n<p dir=\"auto\">The hex representation of SHA-256 hashes is a string, but very, very few strings are SHA-256 hashes. Obviously, especially since our code has lots and lots of them, I'm better off with the type system using a different type for those kinds of strings and not accepting any string where a <code class=\"notranslate\">SHA256Hash</code> is needed. There probably are lots of similar use cases just with strings.</p>",
        "createdAt": "2019-01-16T12:11:44Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-454757293",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 11
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1NTgxMDczMA==",
        "author": {
          "login": "qm3ster"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows\r\n> eliminating cases like the `else` in [this](https://www.typescriptlang.org/play/index.html#src=class%20A%20%7B%20name%20%3D%20%22A%22%20%7D%0D%0Aclass%20B%20%7B%20name%20%3D%20%22B%22%20%7D%0D%0A%0D%0Afunction%20foo()%20%7B%0D%0A%20%20%20%20var%20a%3A%20A%20%3D%20new%20B()%0D%0A%0D%0A%20%20%20%20if%20(a%20instanceof%20A)%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20%22foo%22%0D%0A%20%20%20%20%7D%20else%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20%22bar%22%0D%0A%20%20%20%20%7D%0D%0A%7D).\r\n\r\nIt works if you make the field `readonly`.\r\n\r\nThat's not to be construed that I don't want this feature, I want it the most.\r\n",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows</p>\n<blockquote>\n<p dir=\"auto\">eliminating cases like the <code class=\"notranslate\">else</code> in <a href=\"https://www.typescriptlang.org/play/index.html#src=class%20A%20%7B%20name%20%3D%20%22A%22%20%7D%0D%0Aclass%20B%20%7B%20name%20%3D%20%22B%22%20%7D%0D%0A%0D%0Afunction%20foo()%20%7B%0D%0A%20%20%20%20var%20a%3A%20A%20%3D%20new%20B()%0D%0A%0D%0A%20%20%20%20if%20(a%20instanceof%20A)%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20%22foo%22%0D%0A%20%20%20%20%7D%20else%20%7B%0D%0A%20%20%20%20%20%20%20%20return%20%22bar%22%0D%0A%20%20%20%20%7D%0D%0A%7D\" rel=\"nofollow\">this</a>.</p>\n</blockquote>\n<p dir=\"auto\">It works if you make the field <code class=\"notranslate\">readonly</code>.</p>\n<p dir=\"auto\">That's not to be construed that I don't want this feature, I want it the most.</p>",
        "createdAt": "2019-01-19T20:01:46Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-455810730",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1NjEwMTc2OQ==",
        "author": {
          "login": "jussi-kalliokoski"
        },
        "authorAssociation": "NONE",
        "body": "Some (simplified) real world use cases where sometimes severe (million dollar) bugs can be prevented with nominal typing, but compile today:\r\n\r\n```typescript\r\ntype FileDescriptor = number;\r\n\r\ndeclare function openFile(): [FileDescriptor, number];\r\ndeclare function writeFile(fileDescriptor: FileDescriptor, bytes: ArrayBuffer);\r\n\r\nconst [availableSize, fileDescriptor] = openFile();\r\nwriteFile(fileDescriptor, new ArrayBuffer(availableSize)); // oh no!\r\n```\r\n\r\n```typescript\r\ntype Seconds = number;\r\ntype Milliseconds = number;\r\n\r\nfunction getTime(): Milliseconds { return Date.now(); }\r\nfunction wait(ms: Milliseconds): Promise<void> { return new Promise(r => { setTimeout(() => { r(); }, ms) }); }\r\nfunction setCurrentTime(element: HTMLMediaElement, seconds: Seconds) { element.currentTime = seconds; }\r\n\r\nasync function stopFrame(video: HTMLVideoElement, interval: Milliseconds) {\r\n  let previousTime = getTime();\r\n  while (true) {\r\n    await wait(interval);\r\n    const now = getTime();\r\n    const deltaTime = now - previousTime;\r\n    previousTime = now;\r\n    setCurrentTime(video, video.currentTime + deltaTime); // oh no!\r\n  }\r\n}\r\n\r\ndeclare var video: HTMLVideoElement;\r\nstopFrame(video, 250);\r\n```\r\n\r\n```typescript\r\ntype USD = number;\r\ntype MicroUSD = number; // one millionth of a dollar\r\n\r\ninterface Product {\r\n  price: MicroUSD;\r\n}\r\n\r\ndeclare function refund(userID: string, amount: USD);\r\n\r\ndeclare var userID: string;\r\ndeclare var product: Product;\r\nrefund(userID, product.price); // OH NOOOOOOOO!\r\n```",
        "bodyHTML": "<p dir=\"auto\">Some (simplified) real world use cases where sometimes severe (million dollar) bugs can be prevented with nominal typing, but compile today:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type FileDescriptor = number;\n\ndeclare function openFile(): [FileDescriptor, number];\ndeclare function writeFile(fileDescriptor: FileDescriptor, bytes: ArrayBuffer);\n\nconst [availableSize, fileDescriptor] = openFile();\nwriteFile(fileDescriptor, new ArrayBuffer(availableSize)); // oh no!\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">FileDescriptor</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">function</span> <span class=\"pl-s1\">openFile</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>: <span class=\"pl-kos\">[</span><span class=\"pl-smi\">FileDescriptor</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">function</span> <span class=\"pl-s1\">writeFile</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">fileDescriptor</span>: <span class=\"pl-smi\">FileDescriptor</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">bytes</span>: <span class=\"pl-smi\">ArrayBuffer</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-kos\">[</span><span class=\"pl-s1\">availableSize</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">fileDescriptor</span><span class=\"pl-kos\">]</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">openFile</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-en\">writeFile</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">fileDescriptor</span><span class=\"pl-kos\">,</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">ArrayBuffer</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">availableSize</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// oh no!</span></pre></div>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type Seconds = number;\ntype Milliseconds = number;\n\nfunction getTime(): Milliseconds { return Date.now(); }\nfunction wait(ms: Milliseconds): Promise&lt;void&gt; { return new Promise(r =&gt; { setTimeout(() =&gt; { r(); }, ms) }); }\nfunction setCurrentTime(element: HTMLMediaElement, seconds: Seconds) { element.currentTime = seconds; }\n\nasync function stopFrame(video: HTMLVideoElement, interval: Milliseconds) {\n  let previousTime = getTime();\n  while (true) {\n    await wait(interval);\n    const now = getTime();\n    const deltaTime = now - previousTime;\n    previousTime = now;\n    setCurrentTime(video, video.currentTime + deltaTime); // oh no!\n  }\n}\n\ndeclare var video: HTMLVideoElement;\nstopFrame(video, 250);\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">Seconds</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Milliseconds</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">getTime</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">Milliseconds</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">return</span> <span class=\"pl-smi\">Date</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">now</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">wait</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">ms</span>: <span class=\"pl-smi\">Milliseconds</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">Promise</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\"><span class=\"pl-k\">void</span></span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">return</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Promise</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">r</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-en\">setTimeout</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-en\">r</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">ms</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">setCurrentTime</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">element</span>: <span class=\"pl-smi\">HTMLMediaElement</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">seconds</span>: <span class=\"pl-smi\">Seconds</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> <span class=\"pl-s1\">element</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">currentTime</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">seconds</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">async</span> <span class=\"pl-k\">function</span> <span class=\"pl-en\">stopFrame</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">video</span>: <span class=\"pl-smi\">HTMLVideoElement</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">interval</span>: <span class=\"pl-smi\">Milliseconds</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">let</span> <span class=\"pl-s1\">previousTime</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">getTime</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-k\">while</span> <span class=\"pl-kos\">(</span><span class=\"pl-c1\">true</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">await</span> <span class=\"pl-en\">wait</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">interval</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-k\">const</span> <span class=\"pl-s1\">now</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">getTime</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-k\">const</span> <span class=\"pl-s1\">deltaTime</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">now</span> <span class=\"pl-c1\">-</span> <span class=\"pl-s1\">previousTime</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-s1\">previousTime</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">now</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-en\">setCurrentTime</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">video</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">video</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">currentTime</span> <span class=\"pl-c1\">+</span> <span class=\"pl-s1\">deltaTime</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// oh no!</span>\n  <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">var</span> <span class=\"pl-s1\">video</span>: <span class=\"pl-smi\">HTMLVideoElement</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-en\">stopFrame</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">video</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">250</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type USD = number;\ntype MicroUSD = number; // one millionth of a dollar\n\ninterface Product {\n  price: MicroUSD;\n}\n\ndeclare function refund(userID: string, amount: USD);\n\ndeclare var userID: string;\ndeclare var product: Product;\nrefund(userID, product.price); // OH NOOOOOOOO!\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">USD</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">MicroUSD</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// one millionth of a dollar</span>\n\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">Product</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c1\">price</span>: <span class=\"pl-smi\">MicroUSD</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">function</span> <span class=\"pl-s1\">refund</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">userID</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">amount</span>: <span class=\"pl-smi\">USD</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">var</span> <span class=\"pl-s1\">userID</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">var</span> <span class=\"pl-s1\">product</span>: <span class=\"pl-smi\">Product</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-en\">refund</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">userID</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">product</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">price</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// OH NOOOOOOOO!</span></pre></div>",
        "createdAt": "2019-01-21T14:58:12Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-456101769",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 8
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1NjI5NjkzMA==",
        "author": {
          "login": "joshburgess"
        },
        "authorAssociation": "NONE",
        "body": "I figured it was worth posting this library here since it has not been mentioned.\r\n\r\nhttps://github.com/gcanti/newtype-ts\r\n\r\nThis library simulates a form of nominal typing called `newtype`s, a feature of languages like Haskell, PureScript, etc.\r\n\r\nThis library is somewhat of a type system hack, leveraging \"branding\" to essentially lie to the TS type system, but it is _very_ effective and allows you to do quite a lot of cool things.\r\n\r\nFor example, you can do things that you can't do with \"native\" TS right now, like dynamically concatenating two or more unique string literals together into a new unique string literal (creating a truly unique type, not widening the type to `string`). This sort of thing is useful for code generation utilities that help to reduce boilerplate. Here is a gist where I used `newtype-ts` to pull that off:\r\n\r\nhttps://gist.github.com/joshburgess/729a2aeb7a9d6c09e3ac5a95cd2071be\r\n\r\nAlthough a hack, this seems to be a powerful & very useful tool. Is there any way the TS compiler could just abstract over this pattern & provide it some syntactic sugar in the form of a new keyword that triggers this same sort of idea or something like it behind the scenes?",
        "bodyHTML": "<p dir=\"auto\">I figured it was worth posting this library here since it has not been mentioned.</p>\n<p dir=\"auto\"><a href=\"https://github.com/gcanti/newtype-ts\">https://github.com/gcanti/newtype-ts</a></p>\n<p dir=\"auto\">This library simulates a form of nominal typing called <code class=\"notranslate\">newtype</code>s, a feature of languages like Haskell, PureScript, etc.</p>\n<p dir=\"auto\">This library is somewhat of a type system hack, leveraging \"branding\" to essentially lie to the TS type system, but it is <em>very</em> effective and allows you to do quite a lot of cool things.</p>\n<p dir=\"auto\">For example, you can do things that you can't do with \"native\" TS right now, like dynamically concatenating two or more unique string literals together into a new unique string literal (creating a truly unique type, not widening the type to <code class=\"notranslate\">string</code>). This sort of thing is useful for code generation utilities that help to reduce boilerplate. Here is a gist where I used <code class=\"notranslate\">newtype-ts</code> to pull that off:</p>\n<p dir=\"auto\"><a href=\"https://gist.github.com/joshburgess/729a2aeb7a9d6c09e3ac5a95cd2071be\">https://gist.github.com/joshburgess/729a2aeb7a9d6c09e3ac5a95cd2071be</a></p>\n<p dir=\"auto\">Although a hack, this seems to be a powerful &amp; very useful tool. Is there any way the TS compiler could just abstract over this pattern &amp; provide it some syntactic sugar in the form of a new keyword that triggers this same sort of idea or something like it behind the scenes?</p>",
        "createdAt": "2019-01-22T07:26:35Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-456296930",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1NjM2MzM4NA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@joshburgess BTW, this is basically [what I proposed here](https://github.com/Microsoft/TypeScript/issues/202#issuecomment-437306455).",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/joshburgess/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/joshburgess\">@joshburgess</a> BTW, this is basically <a href=\"https://github.com/Microsoft/TypeScript/issues/202#issuecomment-437306455\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">what I proposed here</a>.</p>",
        "createdAt": "2019-01-22T11:16:11Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-456363384",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1NjYxODQ0OA==",
        "author": {
          "login": "joshburgess"
        },
        "authorAssociation": "NONE",
        "body": "> @joshburgess BTW, this is basically what I proposed here.\r\n> \r\n> This is similar to Flow's opaque types, but the info is carried with the type instead of the reference. This is the key difference, and it's more flexible (you can pass it as a generic parameter), a simpler to teach and understand, and easier to implement.\r\n\r\nI strongly agree with this!",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/joshburgess/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/joshburgess\">@joshburgess</a> BTW, this is basically what I proposed here.</p>\n<p dir=\"auto\">This is similar to Flow's opaque types, but the info is carried with the type instead of the reference. This is the key difference, and it's more flexible (you can pass it as a generic parameter), a simpler to teach and understand, and easier to implement.</p>\n</blockquote>\n<p dir=\"auto\">I strongly agree with this!</p>",
        "createdAt": "2019-01-23T00:26:20Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-456618448",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1NzAyMDc5OQ==",
        "author": {
          "login": "kbtz"
        },
        "authorAssociation": "NONE",
        "body": "This could remove substantial overhead by reducing abstractions that sadly end up in our app's runtime.\r\n\r\nString Oriented Meta Programming™ anyone?!",
        "bodyHTML": "<p dir=\"auto\">This could remove substantial overhead by reducing abstractions that sadly end up in our app's runtime.</p>\n<p dir=\"auto\">String Oriented Meta Programming™ anyone?!</p>",
        "createdAt": "2019-01-24T00:33:47Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-457020799",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1Nzc0ODMxMg==",
        "author": {
          "login": "qm3ster"
        },
        "authorAssociation": "NONE",
        "body": "@kbtzr \r\n```ts\r\nopaque type Integer = number;\r\nimpl Integer {\r\n  new(val) { // val is implicitly `number` It is not a keyword, just first attribute.\r\n    if (!val.isInteger()) throw new TypeError('Dis not it tho')\r\n  } // no return, because the value is passed through unchanged\r\n  toStringWithOther(self, other) { // self is implicitly `Integer`. It is not a keyword, just first attribute. Maybe should use `this` keyword instead, unsure.\r\n    return `Integers: ${self}, ${other}`\r\n  }\r\n  static from(val: number) {\r\n    return new Integer(Math.floor(val))\r\n  }\r\n}\r\n\r\nconst int1 = new Integer(1)\r\nconst int2 = Integer.from(2.1)\r\nconsole.log(int1.toStringWithOther(int2))\r\n```\r\nWhich would compile to\r\n```js\r\nfunction Integer_new(val) {\r\n  if (!val.isInteger()) throw new TypeError('Dis not it tho')\r\n  return val\r\n}\r\nfunction Integer_toStringWithOther(self, other) {\r\n  return `Integers: ${self}, ${other}`\r\n}\r\nfunction Integer_from(val) {\r\n  return Integer_new(Math.floor(val))\r\n}\r\n\r\nconst int1 = Integer_new(1)\r\nconst int2 = Integer_from(2.1)\r\nconsole.log(Integer_toStringWithOther(int1, int2))\r\n```\r\n# 😫👌\r\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/kbtzr/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/kbtzr\">@kbtzr</a></p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"opaque type Integer = number;\nimpl Integer {\n  new(val) { // val is implicitly `number` It is not a keyword, just first attribute.\n    if (!val.isInteger()) throw new TypeError('Dis not it tho')\n  } // no return, because the value is passed through unchanged\n  toStringWithOther(self, other) { // self is implicitly `Integer`. It is not a keyword, just first attribute. Maybe should use `this` keyword instead, unsure.\n    return `Integers: ${self}, ${other}`\n  }\n  static from(val: number) {\n    return new Integer(Math.floor(val))\n  }\n}\n\nconst int1 = new Integer(1)\nconst int2 = Integer.from(2.1)\nconsole.log(int1.toStringWithOther(int2))\"><pre class=\"notranslate\"><span class=\"pl-s1\">opaque</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Integer</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">impl</span> <span class=\"pl-smi\">Integer</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">new</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">val</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\"></span> <span class=\"pl-kos\">{</span> <span class=\"pl-c\">// val is implicitly `number` It is not a keyword, just first attribute.</span>\n    <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-c1\">!</span><span class=\"pl-s1\">val</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">isInteger</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span> <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">TypeError</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'Dis not it tho'</span><span class=\"pl-kos\">)</span>\n  <span class=\"pl-kos\">}</span> <span class=\"pl-c\">// no return, because the value is passed through unchanged</span>\n  <span class=\"pl-en\">toStringWithOther</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">self</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">other</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\"></span> <span class=\"pl-kos\">{</span> <span class=\"pl-c\">// self is implicitly `Integer`. It is not a keyword, just first attribute. Maybe should use `this` keyword instead, unsure.</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-s\">`Integers: <span class=\"pl-s1\"><span class=\"pl-kos\">${</span><span class=\"pl-s1\">self</span><span class=\"pl-kos\">}</span></span>, <span class=\"pl-s1\"><span class=\"pl-kos\">${</span><span class=\"pl-s1\">other</span><span class=\"pl-kos\">}</span></span>`</span>\n  <span class=\"pl-kos\">}</span>\n  <span class=\"pl-en\">static</span> <span class=\"pl-s1\">from</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">val</span>: <span class=\"pl-s1\">number</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\"></span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Integer</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">Math</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">floor</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">val</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span>\n  <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">int1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Integer</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">int2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Integer</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">from</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">2.1</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-smi\">console</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">int1</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">toStringWithOther</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">int2</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">Which would compile to</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"function Integer_new(val) {\n  if (!val.isInteger()) throw new TypeError('Dis not it tho')\n  return val\n}\nfunction Integer_toStringWithOther(self, other) {\n  return `Integers: ${self}, ${other}`\n}\nfunction Integer_from(val) {\n  return Integer_new(Math.floor(val))\n}\n\nconst int1 = Integer_new(1)\nconst int2 = Integer_from(2.1)\nconsole.log(Integer_toStringWithOther(int1, int2))\"><pre class=\"notranslate\"><span class=\"pl-k\">function</span> <span class=\"pl-v\">Integer_new</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">val</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-c1\">!</span><span class=\"pl-s1\">val</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">isInteger</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span> <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">TypeError</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'Dis not it tho'</span><span class=\"pl-kos\">)</span>\n  <span class=\"pl-k\">return</span> <span class=\"pl-s1\">val</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">function</span> <span class=\"pl-v\">Integer_toStringWithOther</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">self</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">other</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">return</span> <span class=\"pl-s\">`Integers: <span class=\"pl-s1\"><span class=\"pl-kos\">${</span><span class=\"pl-s1\">self</span><span class=\"pl-kos\">}</span></span>, <span class=\"pl-s1\"><span class=\"pl-kos\">${</span><span class=\"pl-s1\">other</span><span class=\"pl-kos\">}</span></span>`</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">function</span> <span class=\"pl-v\">Integer_from</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">val</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">return</span> <span class=\"pl-v\">Integer_new</span><span class=\"pl-kos\">(</span><span class=\"pl-v\">Math</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">floor</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">val</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">int1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-v\">Integer_new</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">int2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-v\">Integer_from</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">2.1</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-smi\">console</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-v\">Integer_toStringWithOther</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">int1</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">int2</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span></pre></div>\n<h1 dir=\"auto\">😫👌</h1>",
        "createdAt": "2019-01-25T22:09:10Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-457748312",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 1
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1Nzc4MjAwOQ==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@qm3ster You don't really need extra syntax beyond the `opaque Foo` type I suggested, and TS people are *generally* hesitant to add syntax for *anything* affecting emit at this point unless it's extremely valuable, like `reflect-metadata` with compile-time decorators. In your suggestion, it'd be just as easy to implement without it, and it doesn't require namespaces:\r\n\r\n```ts\r\nopaque type Integer = number;\r\nfunction makeInteger(value: number): Integer {\r\n\tif (value % 1) throw new TypeError(\"value is not an integer\")\r\n\treturn value as Integer\r\n}\r\n\r\nfunction toStringWithOther(a: Integer, b: Integer): string {\r\n\treturn `Integers: ${a}, ${b}`\r\n}\r\n\r\nfunction toInteger(value: number): Integer {\r\n\treturn makeInteger(Math.floor(value))\r\n}\r\n\r\nconst int1 = makeInteger(1)\r\nconst int2 = toInteger(2.1)\r\nconsole.log(toStringWithOther(int1, int2))\r\n```\r\n\r\nI'm not on the TS team, BTW. I just doubt they'll accept that.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/qm3ster/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/qm3ster\">@qm3ster</a> You don't really need extra syntax beyond the <code class=\"notranslate\">opaque Foo</code> type I suggested, and TS people are <em>generally</em> hesitant to add syntax for <em>anything</em> affecting emit at this point unless it's extremely valuable, like <code class=\"notranslate\">reflect-metadata</code> with compile-time decorators. In your suggestion, it'd be just as easy to implement without it, and it doesn't require namespaces:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"opaque type Integer = number;\nfunction makeInteger(value: number): Integer {\n\tif (value % 1) throw new TypeError(&quot;value is not an integer&quot;)\n\treturn value as Integer\n}\n\nfunction toStringWithOther(a: Integer, b: Integer): string {\n\treturn `Integers: ${a}, ${b}`\n}\n\nfunction toInteger(value: number): Integer {\n\treturn makeInteger(Math.floor(value))\n}\n\nconst int1 = makeInteger(1)\nconst int2 = toInteger(2.1)\nconsole.log(toStringWithOther(int1, int2))\"><pre class=\"notranslate\"><span class=\"pl-s1\">opaque</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Integer</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">makeInteger</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">value</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">Integer</span> <span class=\"pl-kos\">{</span>\n\t<span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">value</span> <span class=\"pl-c1\">%</span> <span class=\"pl-c1\">1</span><span class=\"pl-kos\">)</span> <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">TypeError</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">\"value is not an integer\"</span><span class=\"pl-kos\">)</span>\n\t<span class=\"pl-k\">return</span> <span class=\"pl-s1\">value</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Integer</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">toStringWithOther</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">a</span>: <span class=\"pl-smi\">Integer</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">b</span>: <span class=\"pl-smi\">Integer</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">string</span> <span class=\"pl-kos\">{</span>\n\t<span class=\"pl-k\">return</span> <span class=\"pl-s\">`Integers: <span class=\"pl-s1\"><span class=\"pl-kos\">${</span><span class=\"pl-s1\">a</span><span class=\"pl-kos\">}</span></span>, <span class=\"pl-s1\"><span class=\"pl-kos\">${</span><span class=\"pl-s1\">b</span><span class=\"pl-kos\">}</span></span>`</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">toInteger</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">value</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">Integer</span> <span class=\"pl-kos\">{</span>\n\t<span class=\"pl-k\">return</span> <span class=\"pl-en\">makeInteger</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">Math</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">floor</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">value</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">int1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">makeInteger</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">1</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">int2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-en\">toInteger</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">2.1</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-smi\">console</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-en\">toStringWithOther</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">int1</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">int2</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">I'm not on the TS team, BTW. I just doubt they'll accept that.</p>",
        "createdAt": "2019-01-26T00:38:48Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-457782009",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1Nzg0MDU2NQ==",
        "author": {
          "login": "qm3ster"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows I don't doubt that, despite it being rather straightforward to transpile.\r\n(I don't share that sentiment, for me the only important interop is that almost all JS is still valid TS)\r\nIt would be ergonomic though, since it gives you all the affordances of an actual wrapped type like\r\n```ts\r\nclass Integer {\r\n  constructor(private val: number) {\r\n    if (!val.isInteger()) throw new TypeError('Dis not it tho')\r\n  }\r\n  valueOf() {\r\n    return this.val\r\n  }\r\n  toStringWithOther(other: Integer) {\r\n    return `Integers: ${this}, ${other}`\r\n  }\r\n  static from(val: number) {\r\n    return new Integer(Math.floor(val))\r\n  }\r\n}\r\n```\r\nWithout the runtime overhead of creating and passing objects.",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows I don't doubt that, despite it being rather straightforward to transpile.<br>\n(I don't share that sentiment, for me the only important interop is that almost all JS is still valid TS)<br>\nIt would be ergonomic though, since it gives you all the affordances of an actual wrapped type like</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"class Integer {\n  constructor(private val: number) {\n    if (!val.isInteger()) throw new TypeError('Dis not it tho')\n  }\n  valueOf() {\n    return this.val\n  }\n  toStringWithOther(other: Integer) {\n    return `Integers: ${this}, ${other}`\n  }\n  static from(val: number) {\n    return new Integer(Math.floor(val))\n  }\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">class</span> <span class=\"pl-smi\">Integer</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-en\">constructor</span><span class=\"pl-kos\">(</span><span class=\"pl-k\">private</span> <span class=\"pl-s1\">val</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-c1\">!</span><span class=\"pl-s1\">val</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">isInteger</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span> <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">TypeError</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'Dis not it tho'</span><span class=\"pl-kos\">)</span>\n  <span class=\"pl-kos\">}</span>\n  <span class=\"pl-en\">valueOf</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-smi\">this</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">val</span>\n  <span class=\"pl-kos\">}</span>\n  <span class=\"pl-en\">toStringWithOther</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">other</span>: <span class=\"pl-smi\">Integer</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-s\">`Integers: <span class=\"pl-s1\"><span class=\"pl-kos\">${</span><span class=\"pl-smi\">this</span><span class=\"pl-kos\">}</span></span>, <span class=\"pl-s1\"><span class=\"pl-kos\">${</span><span class=\"pl-s1\">other</span><span class=\"pl-kos\">}</span></span>`</span>\n  <span class=\"pl-kos\">}</span>\n  <span class=\"pl-k\">static</span> <span class=\"pl-en\">from</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">val</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Integer</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">Math</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">floor</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">val</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span>\n  <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">Without the runtime overhead of creating and passing objects.</p>",
        "createdAt": "2019-01-26T15:37:05Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-457840565",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1ODA0MjI0OQ==",
        "author": {
          "login": "jussi-kalliokoski"
        },
        "authorAssociation": "NONE",
        "body": "Extension methods are not related to this proposal in any way (except that they would be compatible with the proposal) and should be considered separately, see https://github.com/Microsoft/TypeScript/issues/9 - let's try not to go on a tangent in this topic.",
        "bodyHTML": "<p dir=\"auto\">Extension methods are not related to this proposal in any way (except that they would be compatible with the proposal) and should be considered separately, see <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"37903383\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/9\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/9/hovercard\" href=\"https://github.com/microsoft/TypeScript/issues/9\">#9</a> - let's try not to go on a tangent in this topic.</p>",
        "createdAt": "2019-01-28T08:47:52Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-458042249",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1ODMwNDIzNg==",
        "author": {
          "login": "qm3ster"
        },
        "authorAssociation": "NONE",
        "body": "@jussi-kalliokoski I agree that it is off-topic, and wasn't planning on continuing here.\r\nBut note these aren't extension methods like in the issue you linked, since these aren't actually classes (or even objects), and don't have inheritance and method shadowing concerns. This uniquely applies to opaque type aliases of primitive types.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/jussi-kalliokoski/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jussi-kalliokoski\">@jussi-kalliokoski</a> I agree that it is off-topic, and wasn't planning on continuing here.<br>\nBut note these aren't extension methods like in the issue you linked, since these aren't actually classes (or even objects), and don't have inheritance and method shadowing concerns. This uniquely applies to opaque type aliases of primitive types.</p>",
        "createdAt": "2019-01-28T21:15:38Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-458304236",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1ODU3Mzc2MA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@qm3ster They're basically an opaque type combined with extension methods.\r\n\r\n> But note these aren't extension methods like in the issue you linked, since these aren't actually classes (or even objects), and don't have inheritance and method shadowing concerns.\r\n\r\nSwift allows you to specify extension methods for structs, which *aren't* classes, *aren't* passed by reference, and *aren't* considered objects in that language. Swift structs can't be inherited from, BTW.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/qm3ster/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/qm3ster\">@qm3ster</a> They're basically an opaque type combined with extension methods.</p>\n<blockquote>\n<p dir=\"auto\">But note these aren't extension methods like in the issue you linked, since these aren't actually classes (or even objects), and don't have inheritance and method shadowing concerns.</p>\n</blockquote>\n<p dir=\"auto\">Swift allows you to specify extension methods for structs, which <em>aren't</em> classes, <em>aren't</em> passed by reference, and <em>aren't</em> considered objects in that language. Swift structs can't be inherited from, BTW.</p>",
        "createdAt": "2019-01-29T15:05:59Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-458573760",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1ODYwNDAzMw==",
        "author": {
          "login": "Kinrany"
        },
        "authorAssociation": "NONE",
        "body": "Type assertions with `unique` types should not allow widening:\r\n\r\n```typescript\r\ntype EvenDigit = 0 | 2 | 4 | 6 | 8;\r\ntype Legs = unique EvenDigit;\r\n\r\n// error: 3 is not assignable to EvenDigit\r\nconst x: Legs = 3 as Legs;\r\n\r\n// success\r\nconst two: number = 2;\r\nconst y: Legs = two as EvenDigit as Legs;\r\n```",
        "bodyHTML": "<p dir=\"auto\">Type assertions with <code class=\"notranslate\">unique</code> types should not allow widening:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type EvenDigit = 0 | 2 | 4 | 6 | 8;\ntype Legs = unique EvenDigit;\n\n// error: 3 is not assignable to EvenDigit\nconst x: Legs = 3 as Legs;\n\n// success\nconst two: number = 2;\nconst y: Legs = two as EvenDigit as Legs;\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">EvenDigit</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">0</span> <span class=\"pl-c1\">|</span> <span class=\"pl-c1\">2</span> <span class=\"pl-c1\">|</span> <span class=\"pl-c1\">4</span> <span class=\"pl-c1\">|</span> <span class=\"pl-c1\">6</span> <span class=\"pl-c1\">|</span> <span class=\"pl-c1\">8</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Legs</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">EvenDigit</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// error: 3 is not assignable to EvenDigit</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">Legs</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">3</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Legs</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// success</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">two</span>: <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">2</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">y</span>: <span class=\"pl-smi\">Legs</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">two</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">EvenDigit</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Legs</span><span class=\"pl-kos\">;</span></pre></div>",
        "createdAt": "2019-01-29T16:20:04Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-458604033",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1ODYxNDAyOA==",
        "author": {
          "login": "qm3ster"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows I was stealing from Rust. Where you only have structs, including unary structs that are basically newtypes like the ones we are discussing here, and you can implement methods and traits on them and traits even on primitive types.\r\n\r\n@Kinrany wouldn't you say the problem already begins here, without introducing the new keyword:\r\n```ts\r\ntype EvenDigit = 0 | 2 | 4 | 6 | 8;\r\nconst x = 3 as EvenDigit; // doesn't error\r\n\r\n// which should probably require manually widening\r\nconst x = 3 as number as EvenDigit;\r\n// even when being assigned to a mutable binding\r\nlet x: EvenDigit = 0;\r\nx = 3; // errors\r\nx = 3 as number; // errors, fortunately\r\nx = 3 as EvenDigit; // ⚠ doesn't error ⚠\r\nx = 3 as number as EvenDigit; // clear intention of shooting yourself in the leg, ok\r\n```\r\n",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows I was stealing from Rust. Where you only have structs, including unary structs that are basically newtypes like the ones we are discussing here, and you can implement methods and traits on them and traits even on primitive types.</p>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Kinrany/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Kinrany\">@Kinrany</a> wouldn't you say the problem already begins here, without introducing the new keyword:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type EvenDigit = 0 | 2 | 4 | 6 | 8;\nconst x = 3 as EvenDigit; // doesn't error\n\n// which should probably require manually widening\nconst x = 3 as number as EvenDigit;\n// even when being assigned to a mutable binding\nlet x: EvenDigit = 0;\nx = 3; // errors\nx = 3 as number; // errors, fortunately\nx = 3 as EvenDigit; // ⚠ doesn't error ⚠\nx = 3 as number as EvenDigit; // clear intention of shooting yourself in the leg, ok\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">EvenDigit</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">0</span> <span class=\"pl-c1\">|</span> <span class=\"pl-c1\">2</span> <span class=\"pl-c1\">|</span> <span class=\"pl-c1\">4</span> <span class=\"pl-c1\">|</span> <span class=\"pl-c1\">6</span> <span class=\"pl-c1\">|</span> <span class=\"pl-c1\">8</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">3</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">EvenDigit</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// doesn't error</span>\n\n<span class=\"pl-c\">// which should probably require manually widening</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">3</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">number</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">EvenDigit</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-c\">// even when being assigned to a mutable binding</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">EvenDigit</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">0</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">3</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// errors</span>\n<span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">3</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// errors, fortunately</span>\n<span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">3</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">EvenDigit</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// ⚠ doesn't error ⚠</span>\n<span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">3</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">number</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">EvenDigit</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// clear intention of shooting yourself in the leg, ok</span></pre></div>",
        "createdAt": "2019-01-29T16:44:24Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-458614028",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1ODYyNjMxMw==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@qm3ster I know you weren't pulling from Swift, or the syntax would've been a bit different. I was just drawing parallels between your proposal and a couple different languages to make a point: your proposal *is* basically extension methods mod explicit wrapping.\r\n\r\n@Kinrany \r\n\r\n> Type assertions with `unique` types should not allow widening:\r\n> \r\n> ```ts\r\n> type EvenDigit = 0 | 2 | 4 | 6 | 8;\r\n> type Legs = unique EvenDigit;\r\n> \r\n> // error: 3 is not assignable to EvenDigit\r\n> const x: Legs = 3 as Legs;\r\n> \r\n> // success\r\n> const two: number = 2;\r\n> const y: Legs = two as EvenDigit as Legs;\r\n> ```\r\n\r\n[That's already the case with objects](https://www.typescriptlang.org/play/index.html#src=type%20Base%20%3D%20%7B%20foo%3A%201%20%7D%20%7C%20%7B%20bar%3A%202%20%7D%20%7C%20%7B%20baz%3A%203%20%7D%3B%0D%0Atype%20Parent%20%3D%20%7B%20foo%3A%201%20%7D%20%7C%20%7B%20bar%3A%202%20%7D%3B%0D%0Atype%20Child%20%3D%20%7B%20foo%3A%201%2C%20bar%3A%202%20%7D%3B%0D%0A%0D%0A%2F%2F%20error%3A%20missing%20%60foo%60%20%2B%20%60bar%60%20properties%0D%0Aconst%20x%3A%20Child%20%3D%20%7B%20baz%3A%203%20%7D%20as%20Child%3B%0D%0A%0D%0A%2F%2F%20success%0D%0Aconst%20two%3A%20Base%20%3D%20%7B%20bar%3A%202%20%7D%3B%0D%0Aconst%20y%3A%20Parent%20%3D%20two%20as%20Parent%20as%20Child%3B), so assuming they go with [my proposal](https://github.com/Microsoft/TypeScript/issues/202#issuecomment-437306455), you'd have the same exact semantics. Note that in the playground snippet, `Base` &harr; `number`, `Parent` &harr; `EvenDigit`, and `Child` &harr; `Legs`.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/qm3ster/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/qm3ster\">@qm3ster</a> I know you weren't pulling from Swift, or the syntax would've been a bit different. I was just drawing parallels between your proposal and a couple different languages to make a point: your proposal <em>is</em> basically extension methods mod explicit wrapping.</p>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Kinrany/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Kinrany\">@Kinrany</a></p>\n<blockquote>\n<p dir=\"auto\">Type assertions with <code class=\"notranslate\">unique</code> types should not allow widening:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type EvenDigit = 0 | 2 | 4 | 6 | 8;\ntype Legs = unique EvenDigit;\n\n// error: 3 is not assignable to EvenDigit\nconst x: Legs = 3 as Legs;\n\n// success\nconst two: number = 2;\nconst y: Legs = two as EvenDigit as Legs;\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">EvenDigit</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">0</span> <span class=\"pl-c1\">|</span> <span class=\"pl-c1\">2</span> <span class=\"pl-c1\">|</span> <span class=\"pl-c1\">4</span> <span class=\"pl-c1\">|</span> <span class=\"pl-c1\">6</span> <span class=\"pl-c1\">|</span> <span class=\"pl-c1\">8</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Legs</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">EvenDigit</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// error: 3 is not assignable to EvenDigit</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">Legs</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">3</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Legs</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// success</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">two</span>: <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">2</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">y</span>: <span class=\"pl-smi\">Legs</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">two</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">EvenDigit</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Legs</span><span class=\"pl-kos\">;</span></pre></div>\n</blockquote>\n<p dir=\"auto\"><a href=\"https://www.typescriptlang.org/play/index.html#src=type%20Base%20%3D%20%7B%20foo%3A%201%20%7D%20%7C%20%7B%20bar%3A%202%20%7D%20%7C%20%7B%20baz%3A%203%20%7D%3B%0D%0Atype%20Parent%20%3D%20%7B%20foo%3A%201%20%7D%20%7C%20%7B%20bar%3A%202%20%7D%3B%0D%0Atype%20Child%20%3D%20%7B%20foo%3A%201%2C%20bar%3A%202%20%7D%3B%0D%0A%0D%0A%2F%2F%20error%3A%20missing%20%60foo%60%20%2B%20%60bar%60%20properties%0D%0Aconst%20x%3A%20Child%20%3D%20%7B%20baz%3A%203%20%7D%20as%20Child%3B%0D%0A%0D%0A%2F%2F%20success%0D%0Aconst%20two%3A%20Base%20%3D%20%7B%20bar%3A%202%20%7D%3B%0D%0Aconst%20y%3A%20Parent%20%3D%20two%20as%20Parent%20as%20Child%3B\" rel=\"nofollow\">That's already the case with objects</a>, so assuming they go with <a href=\"https://github.com/Microsoft/TypeScript/issues/202#issuecomment-437306455\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">my proposal</a>, you'd have the same exact semantics. Note that in the playground snippet, <code class=\"notranslate\">Base</code> ↔ <code class=\"notranslate\">number</code>, <code class=\"notranslate\">Parent</code> ↔ <code class=\"notranslate\">EvenDigit</code>, and <code class=\"notranslate\">Child</code> ↔ <code class=\"notranslate\">Legs</code>.</p>",
        "createdAt": "2019-01-29T17:16:08Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-458626313",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1ODYyODY2Ng==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "I do feel it'd allow them to also fix enum subtyping to not work [like this](https://www.typescriptlang.org/play/index.html#src=type%20EvenDigit%20%3D%200%20%7C%202%20%7C%204%20%7C%206%20%7C%208%3B%0D%0Aconst%20enum%20Legs%20%7B%0D%0A%20%20%20%20Zero%20%3D%200%2C%0D%0A%20%20%20%20Two%20%3D%202%2C%0D%0A%20%20%20%20Four%20%3D%204%2C%0D%0A%20%20%20%20Six%20%3D%206%2C%0D%0A%20%20%20%20Eight%20%3D%208%2C%0D%0A%7D%0D%0A%0D%0A%2F%2F%20error%3A%203%20is%20not%20assignable%20to%20EvenDigit%0D%0Aconst%20x%3A%20Legs%20%3D%203%20as%20Legs%3B%0D%0A%0D%0A%2F%2F%20success%0D%0Aconst%20two%3A%20number%20%3D%202%3B%0D%0Aconst%20y%3A%20Legs%20%3D%20two%20as%20EvenDigit%20as%20Legs%3B) - enums *should* be `unique` subtypes, [like in C++](https://godbolt.org/z/0TWNQs).\r\n\r\n```cpp\r\nenum Legs {\r\n    Zero = 0,\r\n    Two = 2,\r\n    Four = 4,\r\n    Six = 6,\r\n    Eight = 8,\r\n};\r\n\r\nint main() {\r\n    Legs x1 = (Legs) 2; // success\r\n    Legs x2 = 2;        // error\r\n}\r\n```",
        "bodyHTML": "<p dir=\"auto\">I do feel it'd allow them to also fix enum subtyping to not work <a href=\"https://www.typescriptlang.org/play/index.html#src=type%20EvenDigit%20%3D%200%20%7C%202%20%7C%204%20%7C%206%20%7C%208%3B%0D%0Aconst%20enum%20Legs%20%7B%0D%0A%20%20%20%20Zero%20%3D%200%2C%0D%0A%20%20%20%20Two%20%3D%202%2C%0D%0A%20%20%20%20Four%20%3D%204%2C%0D%0A%20%20%20%20Six%20%3D%206%2C%0D%0A%20%20%20%20Eight%20%3D%208%2C%0D%0A%7D%0D%0A%0D%0A%2F%2F%20error%3A%203%20is%20not%20assignable%20to%20EvenDigit%0D%0Aconst%20x%3A%20Legs%20%3D%203%20as%20Legs%3B%0D%0A%0D%0A%2F%2F%20success%0D%0Aconst%20two%3A%20number%20%3D%202%3B%0D%0Aconst%20y%3A%20Legs%20%3D%20two%20as%20EvenDigit%20as%20Legs%3B\" rel=\"nofollow\">like this</a> - enums <em>should</em> be <code class=\"notranslate\">unique</code> subtypes, <a href=\"https://godbolt.org/z/0TWNQs\" rel=\"nofollow\">like in C++</a>.</p>\n<div class=\"highlight highlight-source-c++ notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"enum Legs {\n    Zero = 0,\n    Two = 2,\n    Four = 4,\n    Six = 6,\n    Eight = 8,\n};\n\nint main() {\n    Legs x1 = (Legs) 2; // success\n    Legs x2 = 2;        // error\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">enum</span> Legs {\n    Zero = <span class=\"pl-c1\">0</span>,\n    Two = <span class=\"pl-c1\">2</span>,\n    Four = <span class=\"pl-c1\">4</span>,\n    Six = <span class=\"pl-c1\">6</span>,\n    Eight = <span class=\"pl-c1\">8</span>,\n};\n\n<span class=\"pl-k\">int</span> <span class=\"pl-en\">main</span>() {\n    Legs x1 = (Legs) <span class=\"pl-c1\">2</span>; <span class=\"pl-c\"><span class=\"pl-c\">//</span> success</span>\n    Legs x2 = <span class=\"pl-c1\">2</span>;        <span class=\"pl-c\"><span class=\"pl-c\">//</span> error</span>\n}</pre></div>",
        "createdAt": "2019-01-29T17:22:20Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-458628666",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1ODcwNTQwMQ==",
        "author": {
          "login": "xaviergonz"
        },
        "authorAssociation": "NONE",
        "body": "Right now my poor man's version of nominal typing is\r\n```ts\r\ndeclare const $myInterface1: unique symbol\r\ninterface MyInterface1 {\r\n    readonly [$myInterface1]?: undefined;\r\n}\r\n\r\ndeclare const $myInterface2: unique symbol\r\ninterface MyInterface2 {\r\n    readonly [$myInterface2]?: undefined;\r\n}\r\n\r\ntype Test = MyInterface1 extends MyInterface2 ? true : false; // false\r\n```",
        "bodyHTML": "<p dir=\"auto\">Right now my poor man's version of nominal typing is</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"declare const $myInterface1: unique symbol\ninterface MyInterface1 {\n    readonly [$myInterface1]?: undefined;\n}\n\ndeclare const $myInterface2: unique symbol\ninterface MyInterface2 {\n    readonly [$myInterface2]?: undefined;\n}\n\ntype Test = MyInterface1 extends MyInterface2 ? true : false; // false\"><pre class=\"notranslate\"><span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">$myInterface1</span>: <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">symbol</span>\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">MyInterface1</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">readonly</span> <span class=\"pl-kos\">[</span><span class=\"pl-s1\">$myInterface1</span><span class=\"pl-kos\">]</span>?: <span class=\"pl-c1\">undefined</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">$myInterface2</span>: <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">symbol</span>\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">MyInterface2</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">readonly</span> <span class=\"pl-kos\">[</span><span class=\"pl-s1\">$myInterface2</span><span class=\"pl-kos\">]</span>?: <span class=\"pl-c1\">undefined</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Test</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">MyInterface1</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">MyInterface2</span> ? <span class=\"pl-c1\">true</span> : <span class=\"pl-c1\">false</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// false</span></pre></div>",
        "createdAt": "2019-01-29T21:02:03Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-458705401",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1ODcyOTg5MQ==",
        "author": null,
        "authorAssociation": "NONE",
        "body": "@isiahmeadows Why not make `unique enum`s opt-in?  We preserve backward compatibility, while supporting both forms.\r\n\r\nI have actually seen instances where one enum is a superset of another enum, and their overlapping values are compatible.",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows Why not make <code class=\"notranslate\">unique enum</code>s opt-in?  We preserve backward compatibility, while supporting both forms.</p>\n<p dir=\"auto\">I have actually seen instances where one enum is a superset of another enum, and their overlapping values are compatible.</p>",
        "createdAt": "2019-01-29T22:17:57Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-458729891",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1ODczNDU5Mw==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@errorx666 That is true, but it's *very* rarely the case you actually want to treat the overlapping values as equivalent. I'm not suggesting it to be disabled by default, but maybe via compiler option. Besides, you can always cast it to `number` as necessary.\r\n\r\nBut combined with the fact TS classes are similarly structurally typed, [nominally typing classes *or* enums could avoid some much more subtle, yet far more insidious bugs](https://www.typescriptlang.org/play/index.html#src=const%20enum%20State%20%7B%20On%2C%20Off%20%7D%0D%0Adeclare%20function%20computeSomeNumber()%3A%20number%0D%0Aabstract%20class%20A%20%7B%0D%0A%20%20%20%20state%20%3D%20State.On%0D%0A%20%20%20%20protected%20abstract%20bar(n%3A%20number)%3A%20void%0D%0A%20%20%20%20baz()%20%7B%20this.bar(this.state)%20%7D%0D%0A%7D%0D%0A%0D%0Aclass%20B%20extends%20A%20%7B%0D%0A%20%20%20%20bar(n%3A%20number)%20%7B%20%2F*%20stuff%20*%2F%20%7D%0D%0A%7D%0D%0A%0D%0Aclass%20C%20%7B%0D%0A%20%20%20%20state%20%3D%2015%0D%0A%20%20%20%20message%20%3D%20%22string%22%0D%0A%20%20%20%20bar(n%3A%20number)%20%7B%20%2F*%20stuff%20*%2F%20%7D%0D%0A%20%20%20%20baz()%20%7B%20console.log(this.message)%20%7D%0D%0A%20%20%20%20whatever()%20%7B%0D%0A%20%20%20%20%20%20%20%20this.bar(computeSomeNumber())%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Aconst%20inst%3A%20B%20%3D%20new%20C()).",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/errorx666/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/errorx666\">@errorx666</a> That is true, but it's <em>very</em> rarely the case you actually want to treat the overlapping values as equivalent. I'm not suggesting it to be disabled by default, but maybe via compiler option. Besides, you can always cast it to <code class=\"notranslate\">number</code> as necessary.</p>\n<p dir=\"auto\">But combined with the fact TS classes are similarly structurally typed, <a href=\"https://www.typescriptlang.org/play/index.html#src=const%20enum%20State%20%7B%20On%2C%20Off%20%7D%0D%0Adeclare%20function%20computeSomeNumber()%3A%20number%0D%0Aabstract%20class%20A%20%7B%0D%0A%20%20%20%20state%20%3D%20State.On%0D%0A%20%20%20%20protected%20abstract%20bar(n%3A%20number)%3A%20void%0D%0A%20%20%20%20baz()%20%7B%20this.bar(this.state)%20%7D%0D%0A%7D%0D%0A%0D%0Aclass%20B%20extends%20A%20%7B%0D%0A%20%20%20%20bar(n%3A%20number)%20%7B%20%2F*%20stuff%20*%2F%20%7D%0D%0A%7D%0D%0A%0D%0Aclass%20C%20%7B%0D%0A%20%20%20%20state%20%3D%2015%0D%0A%20%20%20%20message%20%3D%20%22string%22%0D%0A%20%20%20%20bar(n%3A%20number)%20%7B%20%2F*%20stuff%20*%2F%20%7D%0D%0A%20%20%20%20baz()%20%7B%20console.log(this.message)%20%7D%0D%0A%20%20%20%20whatever()%20%7B%0D%0A%20%20%20%20%20%20%20%20this.bar(computeSomeNumber())%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Aconst%20inst%3A%20B%20%3D%20new%20C()\" rel=\"nofollow\">nominally typing classes <em>or</em> enums could avoid some much more subtle, yet far more insidious bugs</a>.</p>",
        "createdAt": "2019-01-29T22:33:41Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-458734593",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1OTU5ODIyOQ==",
        "author": {
          "login": "ORESoftware"
        },
        "authorAssociation": "NONE",
        "body": "At first I was slagging this issue, but for example try writing typings for a Promise implementation:\r\n\r\n```typescript\r\ntype ExecutorCallback = (v: any) => void;\r\n\r\ntype PromiseExecutor = (\r\n  resolve: ExecutorCallback,\r\n  reject: ExecutorCallback\r\n) => void;\r\n```\r\n\r\nthe signatures for the two functions are the same - they will both accept `any` as argument. So the danger of course is that the developer can mix and match the two by accident which would be deadly, but would satisfy the structural type system. So now I want nominal types, at least on occasion!\r\n\r\nApologies to @isiahmeadows, I agree with you now, nominal types are nice sometimes when you need to make sure to distinguish between two similar types which might otherwise get confused.\r\n",
        "bodyHTML": "<p dir=\"auto\">At first I was slagging this issue, but for example try writing typings for a Promise implementation:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type ExecutorCallback = (v: any) =&gt; void;\n\ntype PromiseExecutor = (\n  resolve: ExecutorCallback,\n  reject: ExecutorCallback\n) =&gt; void;\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">ExecutorCallback</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">v</span>: <span class=\"pl-smi\">any</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-smi\"><span class=\"pl-k\">void</span></span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">PromiseExecutor</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span>\n  <span class=\"pl-s1\">resolve</span>: <span class=\"pl-smi\">ExecutorCallback</span><span class=\"pl-kos\">,</span>\n  <span class=\"pl-s1\">reject</span>: <span class=\"pl-smi\">ExecutorCallback</span>\n<span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-smi\"><span class=\"pl-k\">void</span></span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">the signatures for the two functions are the same - they will both accept <code class=\"notranslate\">any</code> as argument. So the danger of course is that the developer can mix and match the two by accident which would be deadly, but would satisfy the structural type system. So now I want nominal types, at least on occasion!</p>\n<p dir=\"auto\">Apologies to @isiahmeadows, I agree with you now, nominal types are nice sometimes when you need to make sure to distinguish between two similar types which might otherwise get confused.</p>",
        "createdAt": "2019-02-01T04:03:33Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-459598229",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1OTc3MjIzNg==",
        "author": {
          "login": "ForbesLindesay"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "The other classic case is the two functions:\r\n\r\n```ts\r\nfunction getPoint(latitude: number, longitude: number) {\r\n  return {latitude, longitude};\r\n}\r\nfunction getPoint(longitude: number, latitude: number) {\r\n  return {longitude, latitude};\r\n}\r\n```\r\n\r\nI've genuinely seen both of these in the same code base, and it's so easy to get confused.",
        "bodyHTML": "<p dir=\"auto\">The other classic case is the two functions:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"function getPoint(latitude: number, longitude: number) {\n  return {latitude, longitude};\n}\nfunction getPoint(longitude: number, latitude: number) {\n  return {longitude, latitude};\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">function</span> <span class=\"pl-en\">getPoint</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">latitude</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">longitude</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">return</span> <span class=\"pl-kos\">{</span>latitude<span class=\"pl-kos\">,</span> longitude<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">getPoint</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">longitude</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">latitude</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">return</span> <span class=\"pl-kos\">{</span>longitude<span class=\"pl-kos\">,</span> latitude<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">I've genuinely seen both of these in the same code base, and it's so easy to get confused.</p>",
        "createdAt": "2019-02-01T16:02:44Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-459772236",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 7
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1OTg4OTE3OQ==",
        "author": {
          "login": "ORESoftware"
        },
        "authorAssociation": "NONE",
        "body": "@ForbesLindesay to be fair, even Java would get confused - you'd have to have two different types Number1 and Number2.  And so in TypeScript land you could do:\r\n\r\n![screenshot from 2019-02-01 14-21-45](https://user-images.githubusercontent.com/11139560/52152843-c78f8900-262c-11e9-9139-589203f5e1de.png)\r\n\r\nI think the biggest problem is with vanilla callback functions. When you pass a callback, it's really inconvenient to make it a class or to add unique marker properties to it. For example:\r\n\r\n![screenshot from 2019-02-01 14-30-02](https://user-images.githubusercontent.com/11139560/52153194-e6424f80-262d-11e9-99cf-91c597af3c68.png)\r\n\r\n\r\n\r\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/ForbesLindesay/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ForbesLindesay\">@ForbesLindesay</a> to be fair, even Java would get confused - you'd have to have two different types Number1 and Number2.  And so in TypeScript land you could do:</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://user-images.githubusercontent.com/11139560/52152843-c78f8900-262c-11e9-9139-589203f5e1de.png\"><img src=\"https://user-images.githubusercontent.com/11139560/52152843-c78f8900-262c-11e9-9139-589203f5e1de.png\" alt=\"screenshot from 2019-02-01 14-21-45\" style=\"max-width: 100%;\"></a></p>\n<p dir=\"auto\">I think the biggest problem is with vanilla callback functions. When you pass a callback, it's really inconvenient to make it a class or to add unique marker properties to it. For example:</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://user-images.githubusercontent.com/11139560/52153194-e6424f80-262d-11e9-99cf-91c597af3c68.png\"><img src=\"https://user-images.githubusercontent.com/11139560/52153194-e6424f80-262d-11e9-99cf-91c597af3c68.png\" alt=\"screenshot from 2019-02-01 14-30-02\" style=\"max-width: 100%;\"></a></p>",
        "createdAt": "2019-02-01T22:25:44Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-459889179",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1OTg5MTI0NQ==",
        "author": {
          "login": "lll000111"
        },
        "authorAssociation": "NONE",
        "body": "@ORESoftware I hope this is meant as a joke, right? Anyway, it seems to me that everything has already been said, enough arguments been brought forth. If all that's left here is for the discussion to go completely off the rail we could just leave it and wait and see. Sorry for negativity, but *[eye roll]*, it's getting way too \"fringy\" with every new comment which I see as a sign that all good arguments have already been made. This isn't reddit or a discussion forum.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/ORESoftware/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ORESoftware\">@ORESoftware</a> I hope this is meant as a joke, right? Anyway, it seems to me that everything has already been said, enough arguments been brought forth. If all that's left here is for the discussion to go completely off the rail we could just leave it and wait and see. Sorry for negativity, but <em>[eye roll]</em>, it's getting way too \"fringy\" with every new comment which I see as a sign that all good arguments have already been made. This isn't reddit or a discussion forum.</p>",
        "createdAt": "2019-02-01T22:34:23Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-459891245",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 2
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ1OTg5NDA1OA==",
        "author": {
          "login": "ORESoftware"
        },
        "authorAssociation": "NONE",
        "body": "@lll000111 thanks for that comment\r\n\r\nhttps://github.com/Microsoft/TypeScript/issues/29693",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lll000111/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lll000111\">@lll000111</a> thanks for that comment</p>\n<p dir=\"auto\"><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"405902877\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/29693\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/29693/hovercard\" href=\"https://github.com/microsoft/TypeScript/issues/29693\">#29693</a></p>",
        "createdAt": "2019-02-01T22:46:33Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-459894058",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ2MDE3OTMyOA==",
        "author": {
          "login": "ForbesLindesay"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@ORESoftware the point is that all other options have **massive** runtime overhead. We need a system that is part of the type system, like flow has.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/ORESoftware/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ORESoftware\">@ORESoftware</a> the point is that all other options have <strong>massive</strong> runtime overhead. We need a system that is part of the type system, like flow has.</p>",
        "createdAt": "2019-02-04T09:23:59Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-460179328",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 7
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ2MjU1NTIyNw==",
        "author": {
          "login": "MicahZoltu"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@Chacha-26 were you ever able to get something like what you had working but without the tsignore?  Unfortunately, `tsignore` comments get stripped during declaration file generation, which means you can't use this in a library that will be distributed as JavaScript + declaration files.  See #29866.\r\n\r\nI would like to use your technique, but since I'm building a library I can't.  😢 ",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Chacha-26/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Chacha-26\">@Chacha-26</a> were you ever able to get something like what you had working but without the tsignore?  Unfortunately, <code class=\"notranslate\">tsignore</code> comments get stripped during declaration file generation, which means you can't use this in a library that will be distributed as JavaScript + declaration files.  See <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"409036252\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/29866\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/29866/hovercard\" href=\"https://github.com/microsoft/TypeScript/issues/29866\">#29866</a>.</p>\n<p dir=\"auto\">I would like to use your technique, but since I'm building a library I can't.  😢</p>",
        "createdAt": "2019-02-12T00:31:51Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-462555227",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ2Mjk0NzIwNw==",
        "author": {
          "login": "rozzzly"
        },
        "authorAssociation": "NONE",
        "body": "@lll000111 \r\n\r\n> **This isn't reddit*** or a discussion forum.\r\n\r\nTrue.\r\n\r\n> This isn't reddit or **a discussion forum.**\r\n\r\n🤨 No... That's exactly what this is. GitHub issues are the definitive online _forum_ for which _discussion_ over open source software happens.\r\n\r\nAnd while I agree with you that most of does the critical points have already been made, sitting back and seeing what happens is not a solution. ",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lll000111/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lll000111\">@lll000111</a></p>\n<blockquote>\n<p dir=\"auto\"><strong>This isn't reddit</strong>* or a discussion forum.</p>\n</blockquote>\n<p dir=\"auto\">True.</p>\n<blockquote>\n<p dir=\"auto\">This isn't reddit or <strong>a discussion forum.</strong></p>\n</blockquote>\n<p dir=\"auto\">🤨 No... That's exactly what this is. GitHub issues are the definitive online <em>forum</em> for which <em>discussion</em> over open source software happens.</p>\n<p dir=\"auto\">And while I agree with you that most of does the critical points have already been made, sitting back and seeing what happens is not a solution.</p>",
        "createdAt": "2019-02-12T21:41:52Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-462947207",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 6
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ2Mjk3ODcxOA==",
        "author": {
          "login": "karol-majewski"
        },
        "authorAssociation": "NONE",
        "body": "> Unfortunately, `tsignore` comments get stripped during declaration file generation\r\n\r\n@MicahZoltu Not by default. You must use the `removeComments` flag in order for that to happen.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">Unfortunately, <code class=\"notranslate\">tsignore</code> comments get stripped during declaration file generation</p>\n</blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/MicahZoltu/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/MicahZoltu\">@MicahZoltu</a> Not by default. You must use the <code class=\"notranslate\">removeComments</code> flag in order for that to happen.</p>",
        "createdAt": "2019-02-12T23:12:26Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-462978718",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ2MzI2MDE5MQ==",
        "author": {
          "login": "qm3ster"
        },
        "authorAssociation": "NONE",
        "body": "@rozzzly do you have a proposal or know someone willing to produce one?",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/rozzzly/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/rozzzly\">@rozzzly</a> do you have a proposal or know someone willing to produce one?</p>",
        "createdAt": "2019-02-13T16:12:15Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-463260191",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ2MzQ3MzYwMw==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "Could you all ***please*** keep the noise level down?\r\n\r\nIt's not fun being pinged every 2-3 days because someone random person posted a comment here that's not either a proposal, significant finding, pull request link, or something else similarly important. The initial comment itself has ~250 reactions and 63 separate participants, neither of which are small numbers for GH repos in general.",
        "bodyHTML": "<p dir=\"auto\">Could you all <em><strong>please</strong></em> keep the noise level down?</p>\n<p dir=\"auto\">It's not fun being pinged every 2-3 days because someone random person posted a comment here that's not either a proposal, significant finding, pull request link, or something else similarly important. The initial comment itself has ~250 reactions and 63 separate participants, neither of which are small numbers for GH repos in general.</p>",
        "createdAt": "2019-02-14T03:28:11Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-463473603",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 17
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 6
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ2Mzg2Njk1Ng==",
        "author": {
          "login": "ORESoftware"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows there's a button for that:\r\n\r\n![screenshot from 2019-02-14 17-07-19](https://user-images.githubusercontent.com/11139560/52827786-05ec6580-307b-11e9-8689-4912371f719a.png)\r\n\r\n\r\n",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows there's a button for that:</p>\n<p dir=\"auto\"><a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://user-images.githubusercontent.com/11139560/52827786-05ec6580-307b-11e9-8689-4912371f719a.png\"><img src=\"https://user-images.githubusercontent.com/11139560/52827786-05ec6580-307b-11e9-8689-4912371f719a.png\" alt=\"screenshot from 2019-02-14 17-07-19\" style=\"max-width: 100%;\"></a></p>",
        "createdAt": "2019-02-15T01:07:38Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-463866956",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 7
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 29
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ2ODUwMDk4NQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "just discovered an impossible type which can/may/should be used as a tag marker:\r\n```ts\r\ntype O1 = any extends infer O | any ? O : never;\r\ntype O2 = any extends infer O | any ? O : never;\r\ndeclare var o1: O1;\r\ndeclare var o2: O2;\r\no1 = o2; // error\r\no2 = o1; // error\r\n```",
        "bodyHTML": "<p dir=\"auto\">just discovered an impossible type which can/may/should be used as a tag marker:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type O1 = any extends infer O | any ? O : never;\ntype O2 = any extends infer O | any ? O : never;\ndeclare var o1: O1;\ndeclare var o2: O2;\no1 = o2; // error\no2 = o1; // error\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">O1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">any</span> <span class=\"pl-k\">extends</span> infer <span class=\"pl-smi\">O</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">any</span> ? <span class=\"pl-smi\">O</span> : <span class=\"pl-smi\">never</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">O2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">any</span> <span class=\"pl-k\">extends</span> infer <span class=\"pl-smi\">O</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">any</span> ? <span class=\"pl-smi\">O</span> : <span class=\"pl-smi\">never</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">var</span> <span class=\"pl-s1\">o1</span>: <span class=\"pl-smi\">O1</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">var</span> <span class=\"pl-s1\">o2</span>: <span class=\"pl-smi\">O2</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">o1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">o2</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error</span>\n<span class=\"pl-s1\">o2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">o1</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error</span></pre></div>",
        "createdAt": "2019-03-01T01:01:19Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-468500985",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ2ODUxOTY4OA==",
        "author": {
          "login": "MicahZoltu"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@aleksey-bykov How would you use that for derived types, like number for example?  The following results in no errors:\r\n```typescript\r\ntype UInt8 = number extends infer O | number ? O : never\r\ntype UInt16 = number extends infer O | number ? O : never\r\n\r\nconst a: UInt8 = 5\r\nconst b: UInt16 = 10\r\nconst c: UInt8 = b\r\nconst d: UInt16 = a\r\n```",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Aleksey-Bykov/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Aleksey-Bykov\">@Aleksey-Bykov</a> How would you use that for derived types, like number for example?  The following results in no errors:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type UInt8 = number extends infer O | number ? O : never\ntype UInt16 = number extends infer O | number ? O : never\n\nconst a: UInt8 = 5\nconst b: UInt16 = 10\nconst c: UInt8 = b\nconst d: UInt16 = a\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">UInt8</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-k\">extends</span> infer <span class=\"pl-smi\">O</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">number</span> ? <span class=\"pl-smi\">O</span> : <span class=\"pl-smi\">never</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">UInt16</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-k\">extends</span> infer <span class=\"pl-smi\">O</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">number</span> ? <span class=\"pl-smi\">O</span> : <span class=\"pl-smi\">never</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">a</span>: <span class=\"pl-smi\">UInt8</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">5</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">b</span>: <span class=\"pl-smi\">UInt16</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">10</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">c</span>: <span class=\"pl-smi\">UInt8</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">b</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">d</span>: <span class=\"pl-smi\">UInt16</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">a</span></pre></div>",
        "createdAt": "2019-03-01T02:36:33Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-468519688",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ2ODUzOTMyMQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "```\r\ntype O1 = any extends infer O | any ? O : never;\r\ntype O2 = any extends infer O | any ? O : never;\r\ntype N1= number & O1;\r\ntype N2 = number & O2;\r\ndeclare var n1: N1;\r\ndeclare var n2: N2;\r\nn1 = n2; // error\r\nn2 = n1; // error\r\nn1 + n1; // works\r\n```",
        "bodyHTML": "<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"type O1 = any extends infer O | any ? O : never;\ntype O2 = any extends infer O | any ? O : never;\ntype N1= number &amp; O1;\ntype N2 = number &amp; O2;\ndeclare var n1: N1;\ndeclare var n2: N2;\nn1 = n2; // error\nn2 = n1; // error\nn1 + n1; // works\"><pre class=\"notranslate\"><code class=\"notranslate\">type O1 = any extends infer O | any ? O : never;\ntype O2 = any extends infer O | any ? O : never;\ntype N1= number &amp; O1;\ntype N2 = number &amp; O2;\ndeclare var n1: N1;\ndeclare var n2: N2;\nn1 = n2; // error\nn2 = n1; // error\nn1 + n1; // works\n</code></pre></div>",
        "createdAt": "2019-03-01T04:34:38Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-468539321",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ2ODU1MzM3Nw==",
        "author": {
          "login": "MicahZoltu"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "A bit of fiddling got me this, has great error messages for assigning the wrong type, but you lose the ability to do any math operations (without going through some hell) and similarly lose the ability to assign numbers to anything.  If your need lies in nominally typed strings rather than numbers, this may be a good solution.  For nominal numbers, I think the inability to assign and do math operations hurts too much.\r\n```typescript\r\n// note, the inferred `UInt8` is _not_ the same as the assigned `UInt8` type, but it gets us really nice error messages by shadowing the name\r\ntype UInt8= number & any extends infer UInt8 | any ? UInt8 : never\r\ntype UInt16 = number & any extends infer UInt16 | any ? UInt16 : never\r\nconst a8: UInt8 = 5 as unknown as UInt8 // ugh\r\nconst a16: UInt16 = 10 as unknown as UInt16 // ugh\r\nconst b8: UInt8 = a8 // ok\r\nconst b16: UInt16 = a16 // ok\r\nconst c8: UInt8 = a16 // great! Type 'UInt16' is not assignable to type 'UInt8'. \r\nconst c16: UInt16 = a8 // great! Type 'UInt8' is not assignable to type 'UInt16'.\r\nconst d16: UInt16 = a8 + a16 // great! Operator '+' cannot be applied to types 'UInt8' and 'UInt16'.\r\nconst e8: UInt8 = a8 + b8 // fail: Operator '+' cannot be applied to types 'UInt8' and 'UInt8'.\r\nconst f8: UInt8 = (a8 as unknown as number) + (b8 as unknown as number) as unknown as UInt8 // ugh\r\n```",
        "bodyHTML": "<p dir=\"auto\">A bit of fiddling got me this, has great error messages for assigning the wrong type, but you lose the ability to do any math operations (without going through some hell) and similarly lose the ability to assign numbers to anything.  If your need lies in nominally typed strings rather than numbers, this may be a good solution.  For nominal numbers, I think the inability to assign and do math operations hurts too much.</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// note, the inferred `UInt8` is _not_ the same as the assigned `UInt8` type, but it gets us really nice error messages by shadowing the name\ntype UInt8= number &amp; any extends infer UInt8 | any ? UInt8 : never\ntype UInt16 = number &amp; any extends infer UInt16 | any ? UInt16 : never\nconst a8: UInt8 = 5 as unknown as UInt8 // ugh\nconst a16: UInt16 = 10 as unknown as UInt16 // ugh\nconst b8: UInt8 = a8 // ok\nconst b16: UInt16 = a16 // ok\nconst c8: UInt8 = a16 // great! Type 'UInt16' is not assignable to type 'UInt8'. \nconst c16: UInt16 = a8 // great! Type 'UInt8' is not assignable to type 'UInt16'.\nconst d16: UInt16 = a8 + a16 // great! Operator '+' cannot be applied to types 'UInt8' and 'UInt16'.\nconst e8: UInt8 = a8 + b8 // fail: Operator '+' cannot be applied to types 'UInt8' and 'UInt8'.\nconst f8: UInt8 = (a8 as unknown as number) + (b8 as unknown as number) as unknown as UInt8 // ugh\"><pre class=\"notranslate\"><span class=\"pl-c\">// note, the inferred `UInt8` is _not_ the same as the assigned `UInt8` type, but it gets us really nice error messages by shadowing the name</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">UInt8</span><span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">any</span> <span class=\"pl-k\">extends</span> infer <span class=\"pl-smi\">UInt8</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">any</span> ? <span class=\"pl-smi\">UInt8</span> : <span class=\"pl-smi\">never</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">UInt16</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-smi\">any</span> <span class=\"pl-k\">extends</span> infer <span class=\"pl-smi\">UInt16</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">any</span> ? <span class=\"pl-smi\">UInt16</span> : <span class=\"pl-smi\">never</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">a8</span>: <span class=\"pl-smi\">UInt8</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">5</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">unknown</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">UInt8</span> <span class=\"pl-c\">// ugh</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">a16</span>: <span class=\"pl-smi\">UInt16</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">10</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">unknown</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">UInt16</span> <span class=\"pl-c\">// ugh</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">b8</span>: <span class=\"pl-smi\">UInt8</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">a8</span> <span class=\"pl-c\">// ok</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">b16</span>: <span class=\"pl-smi\">UInt16</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">a16</span> <span class=\"pl-c\">// ok</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">c8</span>: <span class=\"pl-smi\">UInt8</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">a16</span> <span class=\"pl-c\">// great! Type 'UInt16' is not assignable to type 'UInt8'. </span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">c16</span>: <span class=\"pl-smi\">UInt16</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">a8</span> <span class=\"pl-c\">// great! Type 'UInt8' is not assignable to type 'UInt16'.</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">d16</span>: <span class=\"pl-smi\">UInt16</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">a8</span> <span class=\"pl-c1\">+</span> <span class=\"pl-s1\">a16</span> <span class=\"pl-c\">// great! Operator '+' cannot be applied to types 'UInt8' and 'UInt16'.</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">e8</span>: <span class=\"pl-smi\">UInt8</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">a8</span> <span class=\"pl-c1\">+</span> <span class=\"pl-s1\">b8</span> <span class=\"pl-c\">// fail: Operator '+' cannot be applied to types 'UInt8' and 'UInt8'.</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">f8</span>: <span class=\"pl-smi\">UInt8</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">a8</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">unknown</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">+</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">b8</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">unknown</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">)</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">unknown</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">UInt8</span> <span class=\"pl-c\">// ugh</span></pre></div>",
        "createdAt": "2019-03-01T06:01:42Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-468553377",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ2ODU1OTA0NQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "there is a way, look for units of measure here in typescript issues",
        "bodyHTML": "<p dir=\"auto\">there is a way, look for units of measure here in typescript issues</p>",
        "createdAt": "2019-03-01T06:29:40Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-468559045",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ2ODU1OTU5NQ==",
        "author": {
          "login": "MicahZoltu"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Yeah, I have tried every solution proposed in this issue.  Each one comes with caveats of some kind and none of them, IMO, really satisfy the units problem well.  Some of them do _okay_ at it, but none are great (none good enough to actually use in the library I'm building usually because the error messaging is too confusing for the uninitiated user).",
        "bodyHTML": "<p dir=\"auto\">Yeah, I have tried every solution proposed in this issue.  Each one comes with caveats of some kind and none of them, IMO, really satisfy the units problem well.  Some of them do <em>okay</em> at it, but none are great (none good enough to actually use in the library I'm building usually because the error messaging is too confusing for the uninitiated user).</p>",
        "createdAt": "2019-03-01T06:32:48Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-468559595",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ3ODcwNzQ4Ng==",
        "author": {
          "login": "ExE-Boss"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "This would greatly help [AssemblyScript’s portable type declaration](https://github.com/AssemblyScript/assemblyscript/blob/abf3de9076da002ff20a86d8d163017ad85815e0/std/portable/index.d.ts#L19-L29), which is also used for IntelliSense in IDEs.",
        "bodyHTML": "<p dir=\"auto\">This would greatly help <a href=\"https://github.com/AssemblyScript/assemblyscript/blob/abf3de9076da002ff20a86d8d163017ad85815e0/std/portable/index.d.ts#L19-L29\">AssemblyScript’s portable type declaration</a>, which is also used for IntelliSense in IDEs.</p>",
        "createdAt": "2019-04-01T19:11:26Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-478707486",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzY4MjcyNw==",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "Following https://stackoverflow.com/questions/56199492/atomic-type-discrimination-in-typescript\r\nI was able to pull up an example using @zpdDG4gta8XKpMCd impossible type:\r\n```\r\nexport type Kilos<T> = T & { discriminator: any extends infer O | any ? O : never };\r\nexport type Pounds<T> = T & { discriminator: any extends infer O | any ? O : never };\r\n\r\nexport interface MetricWeight {\r\n    value: Kilos<number>\r\n}\r\n\r\nexport interface ImperialWeight {\r\n    value: Pounds<number>\r\n}\r\n\r\nconst wm: MetricWeight = { value: 0 as Kilos<number> }\r\nconst wi: ImperialWeight = { value: 0 as Pounds<number> }\r\n\r\nwm.value = wi.value;                       // Errors, good\r\nwi.value = wi.value * 2;                   // Errors, but it's +/- ok\r\nwi.value = wi.value * 2 as Pounds<number>; // Shouldn't error, good\r\nwm.value = wi.value * 2;                   // Errors, good\r\nconst we: MetricWeight = { value: 0 }      // Errors, good\r\n```\r\n\r\nhowever the following doesn't work as expected:\r\n\r\n```\r\nexport type Discriminator<T> = T & { discriminator: any extends infer O | any ? O : never } \r\n\r\nexport type Kilos<T> = Discriminator<T>;\r\nexport type Pounds<T> = Discriminator<T>;\r\n\r\nexport interface MetricWeight {\r\n    value: Kilos<number>\r\n}\r\n\r\nexport interface ImperialWeight {\r\n    value: Pounds<number>\r\n}\r\n\r\nconst wm: MetricWeight = { value: 0 as Kilos<number> }\r\nconst wi: ImperialWeight = { value: 0 as Pounds<number> }\r\n\r\nwm.value = wi.value;                       // Doesn't error, this is bad\r\nwi.value = wi.value * 2;                   // Errors, but it's +/- ok\r\nwi.value = wi.value * 2 as Pounds<number>; // Shouldn't error, good\r\nwm.value = wi.value * 2;                   // Errors, good\r\nconst we: MetricWeight = { value: 0 }      // Errors, good\r\n```\r\n\r\nLooking for way to make the impossible type shorter, I think that having a syntax for impossible type can be a simple step towards more complete nominal types support...",
        "bodyHTML": "<p dir=\"auto\">Following <a href=\"https://stackoverflow.com/questions/56199492/atomic-type-discrimination-in-typescript\" rel=\"nofollow\">https://stackoverflow.com/questions/56199492/atomic-type-discrimination-in-typescript</a><br>\nI was able to pull up an example using <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/zpdDG4gta8XKpMCd/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/zpdDG4gta8XKpMCd\">@zpdDG4gta8XKpMCd</a> impossible type:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"export type Kilos&lt;T&gt; = T &amp; { discriminator: any extends infer O | any ? O : never };\nexport type Pounds&lt;T&gt; = T &amp; { discriminator: any extends infer O | any ? O : never };\n\nexport interface MetricWeight {\n    value: Kilos&lt;number&gt;\n}\n\nexport interface ImperialWeight {\n    value: Pounds&lt;number&gt;\n}\n\nconst wm: MetricWeight = { value: 0 as Kilos&lt;number&gt; }\nconst wi: ImperialWeight = { value: 0 as Pounds&lt;number&gt; }\n\nwm.value = wi.value;                       // Errors, good\nwi.value = wi.value * 2;                   // Errors, but it's +/- ok\nwi.value = wi.value * 2 as Pounds&lt;number&gt;; // Shouldn't error, good\nwm.value = wi.value * 2;                   // Errors, good\nconst we: MetricWeight = { value: 0 }      // Errors, good\"><pre class=\"notranslate\"><code class=\"notranslate\">export type Kilos&lt;T&gt; = T &amp; { discriminator: any extends infer O | any ? O : never };\nexport type Pounds&lt;T&gt; = T &amp; { discriminator: any extends infer O | any ? O : never };\n\nexport interface MetricWeight {\n    value: Kilos&lt;number&gt;\n}\n\nexport interface ImperialWeight {\n    value: Pounds&lt;number&gt;\n}\n\nconst wm: MetricWeight = { value: 0 as Kilos&lt;number&gt; }\nconst wi: ImperialWeight = { value: 0 as Pounds&lt;number&gt; }\n\nwm.value = wi.value;                       // Errors, good\nwi.value = wi.value * 2;                   // Errors, but it's +/- ok\nwi.value = wi.value * 2 as Pounds&lt;number&gt;; // Shouldn't error, good\nwm.value = wi.value * 2;                   // Errors, good\nconst we: MetricWeight = { value: 0 }      // Errors, good\n</code></pre></div>\n<p dir=\"auto\">however the following doesn't work as expected:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"export type Discriminator&lt;T&gt; = T &amp; { discriminator: any extends infer O | any ? O : never } \n\nexport type Kilos&lt;T&gt; = Discriminator&lt;T&gt;;\nexport type Pounds&lt;T&gt; = Discriminator&lt;T&gt;;\n\nexport interface MetricWeight {\n    value: Kilos&lt;number&gt;\n}\n\nexport interface ImperialWeight {\n    value: Pounds&lt;number&gt;\n}\n\nconst wm: MetricWeight = { value: 0 as Kilos&lt;number&gt; }\nconst wi: ImperialWeight = { value: 0 as Pounds&lt;number&gt; }\n\nwm.value = wi.value;                       // Doesn't error, this is bad\nwi.value = wi.value * 2;                   // Errors, but it's +/- ok\nwi.value = wi.value * 2 as Pounds&lt;number&gt;; // Shouldn't error, good\nwm.value = wi.value * 2;                   // Errors, good\nconst we: MetricWeight = { value: 0 }      // Errors, good\"><pre class=\"notranslate\"><code class=\"notranslate\">export type Discriminator&lt;T&gt; = T &amp; { discriminator: any extends infer O | any ? O : never } \n\nexport type Kilos&lt;T&gt; = Discriminator&lt;T&gt;;\nexport type Pounds&lt;T&gt; = Discriminator&lt;T&gt;;\n\nexport interface MetricWeight {\n    value: Kilos&lt;number&gt;\n}\n\nexport interface ImperialWeight {\n    value: Pounds&lt;number&gt;\n}\n\nconst wm: MetricWeight = { value: 0 as Kilos&lt;number&gt; }\nconst wi: ImperialWeight = { value: 0 as Pounds&lt;number&gt; }\n\nwm.value = wi.value;                       // Doesn't error, this is bad\nwi.value = wi.value * 2;                   // Errors, but it's +/- ok\nwi.value = wi.value * 2 as Pounds&lt;number&gt;; // Shouldn't error, good\nwm.value = wi.value * 2;                   // Errors, good\nconst we: MetricWeight = { value: 0 }      // Errors, good\n</code></pre></div>\n<p dir=\"auto\">Looking for way to make the impossible type shorter, I think that having a syntax for impossible type can be a simple step towards more complete nominal types support...</p>",
        "createdAt": "2019-05-18T14:50:11Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493682727",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzY4NTMzNQ==",
        "author": {
          "login": "ExE-Boss"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "The latter doesn’t work right because you are aliasing both `Kilos<T>` and `Pounds<T>` to `Discriminator<T>`.",
        "bodyHTML": "<p dir=\"auto\">The latter doesn’t work right because you are aliasing both <code class=\"notranslate\">Kilos&lt;T&gt;</code> and <code class=\"notranslate\">Pounds&lt;T&gt;</code> to <code class=\"notranslate\">Discriminator&lt;T&gt;</code>.</p>",
        "createdAt": "2019-05-18T15:27:37Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493685335",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzcwOTk0OQ==",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "@ExE-Boss thank you for your clarification, I hope I don't sound rude, English is not my native language but the reason why it fails is obvious, what's not obvious is how to achieve the opposite behavior. And it seems that there are no constructs in the language that allow to do something like that?",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/ExE-Boss/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ExE-Boss\">@ExE-Boss</a> thank you for your clarification, I hope I don't sound rude, English is not my native language but the reason why it fails is obvious, what's not obvious is how to achieve the opposite behavior. And it seems that there are no constructs in the language that allow to do something like that?</p>",
        "createdAt": "2019-05-18T21:54:05Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493709949",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzcxNTI0MQ==",
        "author": {
          "login": "ExE-Boss"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Yeah, TypeScript doesn’t currently have native support for nominal types.\r\n\r\n---\r\n\r\nI believe that:\r\n```ts\r\n// Signed integers:\r\nnominal type i8 = number;\r\nnominal type i16 = number;\r\nnominal type i32 = number;\r\nnominal type isize = number;\r\n\r\n// Unsigned integers:\r\nnominal type u8 = number;\r\nnominal type u16 = number;\r\nnominal type u32 = number;\r\nnominal type usize = number;\r\n\r\n// IEEE-754 floating point numbers:\r\nnominal type f32 = number;\r\nnominal type f64 = number;\r\n```\r\nwould be a decent syntax for this that would satisfy the AssemblyScript use‑case: https://github.com/AssemblyScript/assemblyscript/issues/390.",
        "bodyHTML": "<p dir=\"auto\">Yeah, TypeScript doesn’t currently have native support for nominal types.</p>\n<hr>\n<p dir=\"auto\">I believe that:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// Signed integers:\nnominal type i8 = number;\nnominal type i16 = number;\nnominal type i32 = number;\nnominal type isize = number;\n\n// Unsigned integers:\nnominal type u8 = number;\nnominal type u16 = number;\nnominal type u32 = number;\nnominal type usize = number;\n\n// IEEE-754 floating point numbers:\nnominal type f32 = number;\nnominal type f64 = number;\"><pre class=\"notranslate\"><span class=\"pl-c\">// Signed integers:</span>\n<span class=\"pl-s1\">nominal</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">i8</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">nominal</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">i16</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">nominal</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">i32</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">nominal</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">isize</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// Unsigned integers:</span>\n<span class=\"pl-s1\">nominal</span><span class=\"pl-kos\"></span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">u8</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">nominal</span><span class=\"pl-kos\"></span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">u16</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">nominal</span><span class=\"pl-kos\"></span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">u32</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">nominal</span><span class=\"pl-kos\"></span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">usize</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// IEEE-754 floating point numbers:</span>\n<span class=\"pl-s1\">nominal</span><span class=\"pl-kos\"></span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">f32</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">nominal</span><span class=\"pl-kos\"></span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">f64</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">would be a decent syntax for this that would satisfy the AssemblyScript use‑case: <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"394108362\" data-permission-text=\"Title is private\" data-url=\"https://github.com/AssemblyScript/assemblyscript/issues/390\" data-hovercard-type=\"issue\" data-hovercard-url=\"/AssemblyScript/assemblyscript/issues/390/hovercard\" href=\"https://github.com/AssemblyScript/assemblyscript/issues/390\">AssemblyScript/assemblyscript#390</a>.</p>",
        "createdAt": "2019-05-18T23:48:56Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493715241",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzcyMzY5OQ==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@ExE-Boss can you explain why TypeScript needs nominal types? Aside from supporting another language like AssemblyScript? Part of the discussion going on in this issue is that not everyone is convinced TS needs nominal types at all.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/ExE-Boss/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ExE-Boss\">@ExE-Boss</a> can you explain why TypeScript needs nominal types? Aside from supporting another language like AssemblyScript? Part of the discussion going on in this issue is that not everyone is convinced TS needs nominal types at all.</p>",
        "createdAt": "2019-05-19T03:25:46Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493723699",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzcyNDQ4Mg==",
        "author": {
          "login": "MicahZoltu"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@SimonMeskens Nominal types allows more programming errors to be caught at compile time instead of runtime.  If, for example, you have nominal types for `Pounds` and `Grams`, you cannot accidentally make the programming error of assigning a `Pounds` to a `Grams`, even though they are both `number` under the hood.  Without nominal types, this error wouldn't be caught until runtime (and then it won't result in any kind of exception, just incorrect data):\r\n```typescript\r\ntype Pounds = number\r\ntype Grams = number\r\nclass Apple {\r\n    constructor(private readonly weight: Grams) { }\r\n}\r\nconst appleWeight = 5 as Pounds\r\nnew Apple(appleWeight)\r\n```\r\n\r\nIf you want the canonical example of how much a mistake like this can cost, you need to look no further than https://en.wikipedia.org/wiki/Mars_Climate_Orbiter#Cause_of_failure (327.6M 1999-USD)\r\n> one piece of ground software supplied by Lockheed Martin produced results in a United States customary unit, contrary to its Software Interface Specification (SIS), while a second system, supplied by NASA, expected those results to be in SI units, in accordance with the SIS. ",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a> Nominal types allows more programming errors to be caught at compile time instead of runtime.  If, for example, you have nominal types for <code class=\"notranslate\">Pounds</code> and <code class=\"notranslate\">Grams</code>, you cannot accidentally make the programming error of assigning a <code class=\"notranslate\">Pounds</code> to a <code class=\"notranslate\">Grams</code>, even though they are both <code class=\"notranslate\">number</code> under the hood.  Without nominal types, this error wouldn't be caught until runtime (and then it won't result in any kind of exception, just incorrect data):</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type Pounds = number\ntype Grams = number\nclass Apple {\n    constructor(private readonly weight: Grams) { }\n}\nconst appleWeight = 5 as Pounds\nnew Apple(appleWeight)\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">Pounds</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Grams</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span>\n<span class=\"pl-k\">class</span> <span class=\"pl-smi\">Apple</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-en\">constructor</span><span class=\"pl-kos\">(</span><span class=\"pl-k\">private</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-s1\">weight</span>: <span class=\"pl-smi\">Grams</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">appleWeight</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">5</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Pounds</span>\n<span class=\"pl-k\">new</span> <span class=\"pl-smi\">Apple</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">appleWeight</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">If you want the canonical example of how much a mistake like this can cost, you need to look no further than <a href=\"https://en.wikipedia.org/wiki/Mars_Climate_Orbiter#Cause_of_failure\" rel=\"nofollow\">https://en.wikipedia.org/wiki/Mars_Climate_Orbiter#Cause_of_failure</a> (327.6M 1999-USD)</p>\n<blockquote>\n<p dir=\"auto\">one piece of ground software supplied by Lockheed Martin produced results in a United States customary unit, contrary to its Software Interface Specification (SIS), while a second system, supplied by NASA, expected those results to be in SI units, in accordance with the SIS.</p>\n</blockquote>",
        "createdAt": "2019-05-19T03:46:49Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493724482",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 10
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 7
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzczNDAzNQ==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "TypeScript is a structural duck-typing language. Such a construct feels alien both to its design principles and JavaScript's, in my own opinion. But this thread is long enough, you can read back up and see all the previous argumentation, I'm not here to rehash the argument. Suffice to say, I'm not convinced by any of the arguments presented in favor. I don't feel like I ever have a use case where I want a type that only has meaning at compile time. Also, note that this would perhaps be the first such feature in the language, it would become with an enormous complexity debt that needs to be justified.",
        "bodyHTML": "<p dir=\"auto\">TypeScript is a structural duck-typing language. Such a construct feels alien both to its design principles and JavaScript's, in my own opinion. But this thread is long enough, you can read back up and see all the previous argumentation, I'm not here to rehash the argument. Suffice to say, I'm not convinced by any of the arguments presented in favor. I don't feel like I ever have a use case where I want a type that only has meaning at compile time. Also, note that this would perhaps be the first such feature in the language, it would become with an enormous complexity debt that needs to be justified.</p>",
        "createdAt": "2019-05-19T07:31:14Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493734035",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 13
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzczNDc3OA==",
        "author": {
          "login": "MicahZoltu"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> I don't feel like I ever have a use case where I want a type that only has meaning at compile time.\r\n\r\nTypeScript's entire type system is compile time only.  None of the type information survives to runtime.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">I don't feel like I ever have a use case where I want a type that only has meaning at compile time.</p>\n</blockquote>\n<p dir=\"auto\">TypeScript's entire type system is compile time only.  None of the type information survives to runtime.</p>",
        "createdAt": "2019-05-19T07:44:22Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493734778",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 10
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5Mzc0ODU5Nw==",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "Again I hope I don't sound rude, English is not my native tongue, @SimonMeskens I spot a flaw in your judgement. Your opinion regarding nominal types sounds like \"I don't need nominal types so you don't need nominal types neither\" which is something that lacks subject for discussion. @SimonMeskens you are free to not use nominal types even if they were in the language, this doesn't mean however that everyone else should be bound by the feeling you have regarding the feature.\r\n\r\nStatic type checking is a formal \"mathematical\" proof that your program is correct. Naturally TypeScript evolves with stricter and stricter type checks introduced in the language, it is logical to go along this path. Most people I know personally, who oppose static type checking actually have no idea what a static type checking is. Most of these people are only fluent in only one language - JavaScript and they fear things they never encountered before leading to some sort of language feature xenophobia that just can't be right. We're not some ancient tribe that should honors traditions to survive without understanding why these traditions should be followed.\r\n\r\nWe have already seen the pain of introduction classes and OOP in JavaScript, argument in the community that JavaScript has its own path and do not introduce these foreign concepts here, do not do this, do not do that. And look where we are now, after those painful decades it's finally pleasant to work with the language, it's finally fast, it's finally cross-platform. And hearing things like \"let's stop here\" doesn't really indulge any motivation.\r\n",
        "bodyHTML": "<p dir=\"auto\">Again I hope I don't sound rude, English is not my native tongue, <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a> I spot a flaw in your judgement. Your opinion regarding nominal types sounds like \"I don't need nominal types so you don't need nominal types neither\" which is something that lacks subject for discussion. <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a> you are free to not use nominal types even if they were in the language, this doesn't mean however that everyone else should be bound by the feeling you have regarding the feature.</p>\n<p dir=\"auto\">Static type checking is a formal \"mathematical\" proof that your program is correct. Naturally TypeScript evolves with stricter and stricter type checks introduced in the language, it is logical to go along this path. Most people I know personally, who oppose static type checking actually have no idea what a static type checking is. Most of these people are only fluent in only one language - JavaScript and they fear things they never encountered before leading to some sort of language feature xenophobia that just can't be right. We're not some ancient tribe that should honors traditions to survive without understanding why these traditions should be followed.</p>\n<p dir=\"auto\">We have already seen the pain of introduction classes and OOP in JavaScript, argument in the community that JavaScript has its own path and do not introduce these foreign concepts here, do not do this, do not do that. And look where we are now, after those painful decades it's finally pleasant to work with the language, it's finally fast, it's finally cross-platform. And hearing things like \"let's stop here\" doesn't really indulge any motivation.</p>",
        "createdAt": "2019-05-19T11:23:09Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493748597",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 6
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5Mzc1MjE4NQ==",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "It turns out that there is another way to introduce the impossible type, as per @jcalz here https://stackoverflow.com/questions/56199492/atomic-type-discrimination-nominal-atomic-types-in-typescript:\r\n\r\n```\r\nexport type Kilos<T> = T & { readonly discriminator: unique symbol };\r\nexport type Pounds<T> = T & { readonly discriminator: unique symbol };\r\n...\r\n```\r\n\r\nHowever there's still an issue with the lack of shorter notation:\r\n\r\n```\r\nexport type Discriminator<T> = ...\r\n```\r\n\r\nAny thoughts to make it cleaner?\r\n\r\n",
        "bodyHTML": "<p dir=\"auto\">It turns out that there is another way to introduce the impossible type, as per <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/jcalz/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jcalz\">@jcalz</a> here <a href=\"https://stackoverflow.com/questions/56199492/atomic-type-discrimination-nominal-atomic-types-in-typescript\" rel=\"nofollow\">https://stackoverflow.com/questions/56199492/atomic-type-discrimination-nominal-atomic-types-in-typescript</a>:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"export type Kilos&lt;T&gt; = T &amp; { readonly discriminator: unique symbol };\nexport type Pounds&lt;T&gt; = T &amp; { readonly discriminator: unique symbol };\n...\"><pre class=\"notranslate\"><code class=\"notranslate\">export type Kilos&lt;T&gt; = T &amp; { readonly discriminator: unique symbol };\nexport type Pounds&lt;T&gt; = T &amp; { readonly discriminator: unique symbol };\n...\n</code></pre></div>\n<p dir=\"auto\">However there's still an issue with the lack of shorter notation:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"export type Discriminator&lt;T&gt; = ...\"><pre class=\"notranslate\"><code class=\"notranslate\">export type Discriminator&lt;T&gt; = ...\n</code></pre></div>\n<p dir=\"auto\">Any thoughts to make it cleaner?</p>",
        "createdAt": "2019-05-19T12:19:04Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493752185",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5Mzc2Njk1OQ==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@lu4 and @MicahZoltu I get that you want this feature, but please don't turn it into some religious argument. Both of you are arguing against a strawman argument that I didn't make for the sake of making me seem incompetent.\r\n\r\nThe argument is quite simple: TypeScript aims to annotate JavaScript with types. Nominal types don't exist in JavaScript, so I don't see how you would introduce them in TypeScript in a manner that fits with the language.\r\n\r\nSo @MicahZoltu turned my argument on its head: \"TypeScript's entire type system is compile time only. None of the type information survives to runtime.\"\r\nObviously yes. TypeScript aims to annotate JavaScript, not the other way round, so what happens at runtime in JavaScript is the truth that TS tries to capture. The whole reason that it gets to erase all types at runtime is because it solely attempts to capture runtime behavior. So in other words, your message is a great argument AGAINST nominal types. Suddenly we lose type safety at runtime, where previously we didn't.\r\n\r\n@lu4's argument is just a pure nonsensical strawman: \"I don't need nominal types so you don't need nominal types neither\"\r\nI don't WANT nominal types, this has nothing to do with need. There's such a thing as complexity. Every new feature introduces drawbacks. In this case, you would introduce fake type safety. The idea of two numbers that are not assignable to each other doesn't exist in JavaScript. So if you make a library in TS using nominal types and then share it with someone that uses it from pure JavaScript, you just created a bunch of potential bugs, because your code is 100% sure that these things don't mix, meanwhile, the userland code is sending you garbage. \r\n\r\nThe response that will now come is probably: \"you don't have to use them\", but I do. For example, JS introduced classes, React started using them and now everyone using React was forced to write classes for years, whether they wanted it or not. The newest hot thing? \"React Hooks\", React without classes. These things matter. If you introduce nominal types, you're forcing me to use them eventually, in some library. \r\n\r\nBtw, lu4, your second paragraph is funny. You claim you want stricter type safety, while advocating for compile-time-only type safety. I'm against nominal types because they are strictly LESS typesafe. I won't even dignify your stupid ad hominem about me being a tribesman that only knows one language with an answer (a cursory click on my profile reveals how silly that notion is), but I'd rather you don't make this personal? There's a lot of people reading this issue and I'm sure they're not amused by you thumping your chest in a github issue.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lu4/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lu4\">@lu4</a> and <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/MicahZoltu/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/MicahZoltu\">@MicahZoltu</a> I get that you want this feature, but please don't turn it into some religious argument. Both of you are arguing against a strawman argument that I didn't make for the sake of making me seem incompetent.</p>\n<p dir=\"auto\">The argument is quite simple: TypeScript aims to annotate JavaScript with types. Nominal types don't exist in JavaScript, so I don't see how you would introduce them in TypeScript in a manner that fits with the language.</p>\n<p dir=\"auto\">So <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/MicahZoltu/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/MicahZoltu\">@MicahZoltu</a> turned my argument on its head: \"TypeScript's entire type system is compile time only. None of the type information survives to runtime.\"<br>\nObviously yes. TypeScript aims to annotate JavaScript, not the other way round, so what happens at runtime in JavaScript is the truth that TS tries to capture. The whole reason that it gets to erase all types at runtime is because it solely attempts to capture runtime behavior. So in other words, your message is a great argument AGAINST nominal types. Suddenly we lose type safety at runtime, where previously we didn't.</p>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lu4/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lu4\">@lu4</a>'s argument is just a pure nonsensical strawman: \"I don't need nominal types so you don't need nominal types neither\"<br>\nI don't WANT nominal types, this has nothing to do with need. There's such a thing as complexity. Every new feature introduces drawbacks. In this case, you would introduce fake type safety. The idea of two numbers that are not assignable to each other doesn't exist in JavaScript. So if you make a library in TS using nominal types and then share it with someone that uses it from pure JavaScript, you just created a bunch of potential bugs, because your code is 100% sure that these things don't mix, meanwhile, the userland code is sending you garbage.</p>\n<p dir=\"auto\">The response that will now come is probably: \"you don't have to use them\", but I do. For example, JS introduced classes, React started using them and now everyone using React was forced to write classes for years, whether they wanted it or not. The newest hot thing? \"React Hooks\", React without classes. These things matter. If you introduce nominal types, you're forcing me to use them eventually, in some library.</p>\n<p dir=\"auto\">Btw, lu4, your second paragraph is funny. You claim you want stricter type safety, while advocating for compile-time-only type safety. I'm against nominal types because they are strictly LESS typesafe. I won't even dignify your stupid ad hominem about me being a tribesman that only knows one language with an answer (a cursory click on my profile reveals how silly that notion is), but I'd rather you don't make this personal? There's a lot of people reading this issue and I'm sure they're not amused by you thumping your chest in a github issue.</p>",
        "createdAt": "2019-05-19T15:31:45Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493766959",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 14
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5Mzc2Nzg0MQ==",
        "author": {
          "login": "aaronjensen"
        },
        "authorAssociation": "NONE",
        "body": "> The idea of two numbers that are not assignable to each other doesn't exist in JavaScript.\r\n\r\nNeither does the idea that a string is not assignable to a number, but TypeScript lets us enforce that.\r\n\r\nAs a though experiment, try reading this:\r\n\r\n> The idea of [a string that cannot be assigned to a number] doesn't exist in JavaScript. So if you make a library in TS [expecting only number arguments] and then share it with someone that uses it from pure JavaScript, you just created a bunch of potential bugs, because your code is 100% sure that [you won't get a string], meanwhile, the userland code is sending you [strings].\r\n\r\n> I'm against nominal types because they are strictly LESS typesafe.\r\n\r\nCould you provide some evidence of this? ",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">The idea of two numbers that are not assignable to each other doesn't exist in JavaScript.</p>\n</blockquote>\n<p dir=\"auto\">Neither does the idea that a string is not assignable to a number, but TypeScript lets us enforce that.</p>\n<p dir=\"auto\">As a though experiment, try reading this:</p>\n<blockquote>\n<p dir=\"auto\">The idea of [a string that cannot be assigned to a number] doesn't exist in JavaScript. So if you make a library in TS [expecting only number arguments] and then share it with someone that uses it from pure JavaScript, you just created a bunch of potential bugs, because your code is 100% sure that [you won't get a string], meanwhile, the userland code is sending you [strings].</p>\n</blockquote>\n<blockquote>\n<p dir=\"auto\">I'm against nominal types because they are strictly LESS typesafe.</p>\n</blockquote>\n<p dir=\"auto\">Could you provide some evidence of this?</p>",
        "createdAt": "2019-05-19T15:43:48Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493767841",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 10
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5Mzc2ODEwOA==",
        "author": {
          "login": "ljharb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@SimonMeskens Nominal types absolutely exist in JavaScript - all language builtins have \"internal slots\" that can be used to brand check, across realms. `typeof x === 'function'` is one such brand check for the `[[Call]]` internal slot (although the other non-primitive builtin brand checks are more cumbersome).\r\n\r\nAdditionally, the stage 3 private class fields feature adds the ability to (ergonomically, because it can also be done with WeakMaps) add brand checks to user-created classes.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a> Nominal types absolutely exist in JavaScript - all language builtins have \"internal slots\" that can be used to brand check, across realms. <code class=\"notranslate\">typeof x === 'function'</code> is one such brand check for the <code class=\"notranslate\">[[Call]]</code> internal slot (although the other non-primitive builtin brand checks are more cumbersome).</p>\n<p dir=\"auto\">Additionally, the stage 3 private class fields feature adds the ability to (ergonomically, because it can also be done with WeakMaps) add brand checks to user-created classes.</p>",
        "createdAt": "2019-05-19T15:47:19Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493768108",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 11
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5Mzc2ODQ5Ng==",
        "author": {
          "login": "mmiszy"
        },
        "authorAssociation": "NONE",
        "body": "@SimonMeskens \r\n> while advocating for compile-time-only type safety\r\n\r\nI believe that Runtime Type Checks are out of the scope of TypeScript. There are multiple libraries doing just that and they're doing it well — see `io-ts` or `typescript-is`.\r\nTypeScript is all about compile-time type safety and it's all that matters.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a></p>\n<blockquote>\n<p dir=\"auto\">while advocating for compile-time-only type safety</p>\n</blockquote>\n<p dir=\"auto\">I believe that Runtime Type Checks are out of the scope of TypeScript. There are multiple libraries doing just that and they're doing it well — see <code class=\"notranslate\">io-ts</code> or <code class=\"notranslate\">typescript-is</code>.<br>\nTypeScript is all about compile-time type safety and it's all that matters.</p>",
        "createdAt": "2019-05-19T15:52:29Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493768496",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 10
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5Mzc2OTQxNQ==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@aaronjensen if you have userland facing code that expects numbers and doesn't check if they're numbers, but instead rely on compile-time errors by TypeScript, then you're using the language wrong.\r\n\r\n@ljharb sure, yes, and I'm fine with TypeScript fully supporting the available JavaScript versions of nominality. It already seems to partly introduce a version of nominality with classes. I'm not particularly against all nominality, just against the idea of introducing a version of nominality that only exists at compile time, as that seems to be against the stated goals of the language. Good comment!\r\n\r\n@mmiszy you seem to be in confusion about the goals of TypeScript as a language. The idea is that it tries to annotate existing JavaScript idioms. As in, the compiler gives you guarantees based on runtime characteristics of your code. Nominal types would allow the compiler to give you compile-time-only guarantees and that would be a bad thing for the language I feel. \r\n\r\nYou're confusing with code emit, no one is talking about code emit.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/aaronjensen/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/aaronjensen\">@aaronjensen</a> if you have userland facing code that expects numbers and doesn't check if they're numbers, but instead rely on compile-time errors by TypeScript, then you're using the language wrong.</p>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/ljharb/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ljharb\">@ljharb</a> sure, yes, and I'm fine with TypeScript fully supporting the available JavaScript versions of nominality. It already seems to partly introduce a version of nominality with classes. I'm not particularly against all nominality, just against the idea of introducing a version of nominality that only exists at compile time, as that seems to be against the stated goals of the language. Good comment!</p>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/mmiszy/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/mmiszy\">@mmiszy</a> you seem to be in confusion about the goals of TypeScript as a language. The idea is that it tries to annotate existing JavaScript idioms. As in, the compiler gives you guarantees based on runtime characteristics of your code. Nominal types would allow the compiler to give you compile-time-only guarantees and that would be a bad thing for the language I feel.</p>\n<p dir=\"auto\">You're confusing with code emit, no one is talking about code emit.</p>",
        "createdAt": "2019-05-19T16:04:14Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493769415",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 14
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5Mzc2OTgwNw==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "Just to make the conversation clearer:\r\n\r\nif you can show me a piece of JavaScript code with certain runtime guarantees that TypeScript isn't able to capture because of a lack of nominality, I'm 100% in favor of a new feature that captures said nominality. If said nominality only exists at compile time, I'm against it.",
        "bodyHTML": "<p dir=\"auto\">Just to make the conversation clearer:</p>\n<p dir=\"auto\">if you can show me a piece of JavaScript code with certain runtime guarantees that TypeScript isn't able to capture because of a lack of nominality, I'm 100% in favor of a new feature that captures said nominality. If said nominality only exists at compile time, I'm against it.</p>",
        "createdAt": "2019-05-19T16:09:35Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493769807",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 12
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5Mzc3MDA1Mg==",
        "author": {
          "login": "jleclanche"
        },
        "authorAssociation": "NONE",
        "body": "I'm not sure what makes you an arbiter of what the goals of Typescript are, Simon, given that regardless of your profile, your previous comments show a lack of understanding of what Typescript even is.\r\nSorry for being raw but I'm getting a bit fed up with notifications on this issue for what amounts to an off-topic discussion, and I doubt I'm the only one... \r\n\r\nEdit: I've blocked Simon to silence these notifications. I encourage people to stop entertaining this altogether.",
        "bodyHTML": "<p dir=\"auto\">I'm not sure what makes you an arbiter of what the goals of Typescript are, Simon, given that regardless of your profile, your previous comments show a lack of understanding of what Typescript even is.<br>\nSorry for being raw but I'm getting a bit fed up with notifications on this issue for what amounts to an off-topic discussion, and I doubt I'm the only one...</p>\n<p dir=\"auto\">Edit: I've blocked Simon to silence these notifications. I encourage people to stop entertaining this altogether.</p>",
        "createdAt": "2019-05-19T16:12:50Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493770052",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 11
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5Mzc3MTA0MQ==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "@jleclanche If you can point me to which parts of my comments are off-topic, I'll be glad to adjust my behavior. If you claim that I have a lack of understanding what TypeScript even is, I'd love it if you could show me where I lack said understanding, otherwise that's just another chest-thumping exercise. \r\n\r\nThe only off-topic comment here is yours and this reply to it. Forgive me for not allowing you to just insult me and letting it slide.\r\n\r\nAs for the arbiter ad hominem, feel free to ping one of the devs and read the wiki. Both will tell you exactly the same goals, because I did get my information directly from those sources. From the wiki:\r\n\r\nGoals:\r\n7. Preserve runtime behavior of all JavaScript code.\r\n9. Use a consistent, fully erasable, structural type system.\r\n\r\nNon-goals (as in, do not want):\r\n3. Apply a sound or \"provably correct\" type system. Instead, strike a balance between correctness and productivity.\r\n5. Add or rely on run-time type information in programs, or emit different code based on the results of the type system. Instead, encourage programming patterns that do not require run-time metadata.\r\n\r\nI'm simply going by these goals and non-goals",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/jleclanche/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jleclanche\">@jleclanche</a> If you can point me to which parts of my comments are off-topic, I'll be glad to adjust my behavior. If you claim that I have a lack of understanding what TypeScript even is, I'd love it if you could show me where I lack said understanding, otherwise that's just another chest-thumping exercise.</p>\n<p dir=\"auto\">The only off-topic comment here is yours and this reply to it. Forgive me for not allowing you to just insult me and letting it slide.</p>\n<p dir=\"auto\">As for the arbiter ad hominem, feel free to ping one of the devs and read the wiki. Both will tell you exactly the same goals, because I did get my information directly from those sources. From the wiki:</p>\n<p dir=\"auto\">Goals:<br>\n7. Preserve runtime behavior of all JavaScript code.<br>\n9. Use a consistent, fully erasable, structural type system.</p>\n<p dir=\"auto\">Non-goals (as in, do not want):<br>\n3. Apply a sound or \"provably correct\" type system. Instead, strike a balance between correctness and productivity.<br>\n5. Add or rely on run-time type information in programs, or emit different code based on the results of the type system. Instead, encourage programming patterns that do not require run-time metadata.</p>\n<p dir=\"auto\">I'm simply going by these goals and non-goals</p>",
        "createdAt": "2019-05-19T16:26:21Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493771041",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 8
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5Mzc4MzYwMQ==",
        "author": {
          "login": "Pauan"
        },
        "authorAssociation": "NONE",
        "body": "The idea that JavaScript is never nominal is simply not true. *Every* class in JavaScript is nominal:\r\n\r\n```js\r\nclass Foo {}\r\n\r\nclass Bar {}\r\n\r\nlet x = new Foo();\r\nlet y = new Bar();\r\n\r\nx instanceof Foo // true\r\nx instanceof Bar // false\r\n\r\ny instanceof Foo // false\r\ny instanceof Bar // true\r\n```\r\n\r\nEven TypeScript treats classes nominally, if they have private properties:\r\n\r\n```ts\r\nclass Foo {\r\n    private name: string;\r\n}\r\n\r\nclass Bar {\r\n    private name: string;\r\n}\r\n\r\nlet x: Foo = new Foo();\r\n\r\n// Error\r\nx = new Bar();\r\n```\r\n\r\nAnd [enums](https://www.typescriptlang.org/docs/handbook/enums.html) (which don't exist in JavaScript, they are *purely* a TypeScript feature) are also nominal:\r\n\r\n```ts\r\nenum Foo {\r\n    Hello = 1\r\n}\r\n\r\nenum Bar {\r\n    Hello = 1\r\n}\r\n\r\nlet x: Foo = Foo.Hello;\r\n\r\n// Error\r\nx = Bar.Hello;\r\n```\r\n\r\nThe idea that TypeScript only copies JavaScript and never adds anything new is not true.\r\n\r\n> @SimonMeskens Suddenly we lose type safety at runtime, where previously we didn't.\r\n\r\nThat's already true with TypeScript today. If you annotate that a function only accepts a `string`, and somebody passes something that isn't a `string`, there is no runtime checking or error.\r\n\r\nTypeScript is not sound, it does not try to enforce runtime safety. It is *purely* a compile-time lint. Nothing more.",
        "bodyHTML": "<p dir=\"auto\">The idea that JavaScript is never nominal is simply not true. <em>Every</em> class in JavaScript is nominal:</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"class Foo {}\n\nclass Bar {}\n\nlet x = new Foo();\nlet y = new Bar();\n\nx instanceof Foo // true\nx instanceof Bar // false\n\ny instanceof Foo // false\ny instanceof Bar // true\"><pre class=\"notranslate\"><span class=\"pl-k\">class</span> <span class=\"pl-v\">Foo</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">class</span> <span class=\"pl-v\">Bar</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Foo</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">y</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-v\">Bar</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-s1\">x</span> <span class=\"pl-k\">instanceof</span> <span class=\"pl-v\">Foo</span> <span class=\"pl-c\">// true</span>\n<span class=\"pl-s1\">x</span> <span class=\"pl-k\">instanceof</span> <span class=\"pl-v\">Bar</span> <span class=\"pl-c\">// false</span>\n\n<span class=\"pl-s1\">y</span> <span class=\"pl-k\">instanceof</span> <span class=\"pl-v\">Foo</span> <span class=\"pl-c\">// false</span>\n<span class=\"pl-s1\">y</span> <span class=\"pl-k\">instanceof</span> <span class=\"pl-v\">Bar</span> <span class=\"pl-c\">// true</span></pre></div>\n<p dir=\"auto\">Even TypeScript treats classes nominally, if they have private properties:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"class Foo {\n    private name: string;\n}\n\nclass Bar {\n    private name: string;\n}\n\nlet x: Foo = new Foo();\n\n// Error\nx = new Bar();\"><pre class=\"notranslate\"><span class=\"pl-k\">class</span> <span class=\"pl-smi\">Foo</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">private</span> <span class=\"pl-c1\">name</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">class</span> <span class=\"pl-smi\">Bar</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">private</span> <span class=\"pl-c1\">name</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">Foo</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Foo</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// Error</span>\n<span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Bar</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">And <a href=\"https://www.typescriptlang.org/docs/handbook/enums.html\" rel=\"nofollow\">enums</a> (which don't exist in JavaScript, they are <em>purely</em> a TypeScript feature) are also nominal:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"enum Foo {\n    Hello = 1\n}\n\nenum Bar {\n    Hello = 1\n}\n\nlet x: Foo = Foo.Hello;\n\n// Error\nx = Bar.Hello;\"><pre class=\"notranslate\"><span class=\"pl-k\">enum</span> <span class=\"pl-smi\">Foo</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">Hello</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">1</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">enum</span> <span class=\"pl-smi\">Bar</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">Hello</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">1</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">Foo</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Foo</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">Hello</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// Error</span>\n<span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Bar</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">Hello</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">The idea that TypeScript only copies JavaScript and never adds anything new is not true.</p>\n<blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a> Suddenly we lose type safety at runtime, where previously we didn't.</p>\n</blockquote>\n<p dir=\"auto\">That's already true with TypeScript today. If you annotate that a function only accepts a <code class=\"notranslate\">string</code>, and somebody passes something that isn't a <code class=\"notranslate\">string</code>, there is no runtime checking or error.</p>\n<p dir=\"auto\">TypeScript is not sound, it does not try to enforce runtime safety. It is <em>purely</em> a compile-time lint. Nothing more.</p>",
        "createdAt": "2019-05-19T19:16:59Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493783601",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 15
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5Mzc4NjA0OQ==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "I had already unsubscribed from this thread and now you pull me in again @Pauan? Jesus. I already addressed both those examples. How disrespectful do you have to be in a public forum to call someone out without even bothering to read what they wrote? \r\n\r\nYes there's examples of nominality in JavaScript (and more might be coming if we get private class fields for example), I already mentioned this and I already mentioned that obviously TypeScript should support those. No, enums isn't a good example, because those are one of the only instances of runtime emit, which is exactly the opposite of what we're talking about, mentioned as a non-goal and it's highly likely if given a do-over that the devs wouldn't add enums again. Enums aren't nominal, they get their identity by tracking a runtime address.\r\n\r\nI also addressed that second issue already, but if you annotate a function to only accept a string, you still have to check if it's a string, that's how JavaScript works, that's how TypeScript works. For userland facing code, do a typeof, for internal use, write a test suite, this is not rocket science. \"Yes, but my unsound codebase introduces compile-time safety features all the time\" is not an argument to make that \"feature\" available in mine too. A function that annotates input as string offers no runtime guarantees that it can only be called with string. You're completely missing the point of TypeScript.\r\n\r\n\"TypeScript is not sound, it does not try to enforce runtime safety. It is purely a compile-time lint. Nothing more.\"\r\n\r\nGood thing literally nobody here argued the opposite. Would you like a novelty hat to put on your strawman? In fact, you just rehashed one of my posts exactly. Now, kindly, I don't know what sort of weird cult is going on in this issue, but if the members could stop repeating the same two strawman points ad nauseam, that would be swell. As mentioned before, people are trying to follow this issue without getting a dozen emails from people that don't read attacking some random dude they don't care about.\r\n\r\nJust let it go. If you want to argue in person, come find me on the TypeScript gitter, but leave this issue be.",
        "bodyHTML": "<p dir=\"auto\">I had already unsubscribed from this thread and now you pull me in again <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Pauan/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Pauan\">@Pauan</a>? Jesus. I already addressed both those examples. How disrespectful do you have to be in a public forum to call someone out without even bothering to read what they wrote?</p>\n<p dir=\"auto\">Yes there's examples of nominality in JavaScript (and more might be coming if we get private class fields for example), I already mentioned this and I already mentioned that obviously TypeScript should support those. No, enums isn't a good example, because those are one of the only instances of runtime emit, which is exactly the opposite of what we're talking about, mentioned as a non-goal and it's highly likely if given a do-over that the devs wouldn't add enums again. Enums aren't nominal, they get their identity by tracking a runtime address.</p>\n<p dir=\"auto\">I also addressed that second issue already, but if you annotate a function to only accept a string, you still have to check if it's a string, that's how JavaScript works, that's how TypeScript works. For userland facing code, do a typeof, for internal use, write a test suite, this is not rocket science. \"Yes, but my unsound codebase introduces compile-time safety features all the time\" is not an argument to make that \"feature\" available in mine too. A function that annotates input as string offers no runtime guarantees that it can only be called with string. You're completely missing the point of TypeScript.</p>\n<p dir=\"auto\">\"TypeScript is not sound, it does not try to enforce runtime safety. It is purely a compile-time lint. Nothing more.\"</p>\n<p dir=\"auto\">Good thing literally nobody here argued the opposite. Would you like a novelty hat to put on your strawman? In fact, you just rehashed one of my posts exactly. Now, kindly, I don't know what sort of weird cult is going on in this issue, but if the members could stop repeating the same two strawman points ad nauseam, that would be swell. As mentioned before, people are trying to follow this issue without getting a dozen emails from people that don't read attacking some random dude they don't care about.</p>\n<p dir=\"auto\">Just let it go. If you want to argue in person, come find me on the TypeScript gitter, but leave this issue be.</p>",
        "createdAt": "2019-05-19T19:46:58Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493786049",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 6
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5Mzc4NjcxMw==",
        "author": {
          "login": "entropitor"
        },
        "authorAssociation": "NONE",
        "body": "@SimonMeskens Your arguments have been answered but you always just find the answer unsatisfying. \r\n\r\nhttps://github.com/microsoft/TypeScript/issues/202#issuecomment-493734035\r\n>TypeScript is a structural duck-typing language. Such a construct feels alien both to its design principles and JavaScript's, in my own opinion.\r\n\r\nSo shouldn't types in general be alien to JavaScript as well? Duck-typing is by definition without types...\r\n\r\nhttps://github.com/microsoft/TypeScript/issues/202#issuecomment-493766959\r\n>>So @MicahZoltu turned my argument on its head: \"TypeScript's entire type system is compile time only. None of the type information survives to runtime.\"\r\n\r\n>Obviously yes. TypeScript aims to annotate JavaScript, not the other way round, so what happens at runtime in JavaScript is the truth that TS tries to capture. The whole reason that it gets to erase all types at runtime is because it solely attempts to capture runtime behavior. \r\n\r\nTypescript had classes before javascript did\r\n\r\n>So in other words, your message is a great argument AGAINST nominal types. Suddenly we lose type safety at runtime, where previously we didn't.\r\n\r\nYou always loose type safety at runtime when you run it with javascript.\r\n\r\n>The response that will now come is probably: \"you don't have to use them\", but I do. For example, JS introduced classes, React started using them and now everyone using React was forced to write classes for years, whether they wanted it or not. The newest hot thing? \"React Hooks\", React without classes. These things matter. If you introduce nominal types, you're forcing me to use them eventually, in some library.\r\n\r\nThat's a fair point but I'd argue that the user-land complexity doesn't increase. If you ever encounter them in the wild, it will be stopping you from doing something that will result in runtime errors.\r\n\r\n>I don't WANT nominal types, this has nothing to do with need. There's such a thing as complexity. Every new feature introduces drawbacks. In this case, you would introduce fake type safety. The idea of two numbers that are not assignable to each other doesn't exist in JavaScript. So if you make a library in TS using nominal types and then share it with someone that uses it from pure JavaScript, you just created a bunch of potential bugs, because your code is 100% sure that these things don't mix, meanwhile, the userland code is sending you garbage.\r\n\r\nAs said, TS already has this with string and numbers instead of numbers and numbers. The fact that there is no way in JS to check is actually the problem nominal types are trying to solve. It's impossible to catch this bug in JS, but can we at least solve it in TS?\r\n\r\n>Btw, lu4, your second paragraph is funny. You claim you want stricter type safety, while advocating for compile-time-only type safety. I'm against nominal types because they are strictly LESS typesafe. I won't even dignify your stupid ad hominem about me being a tribesman that only knows one language with an answer (a cursory click on my profile reveals how silly that notion is), but I'd rather you don't make this personal? There's a lot of people reading this issue and I'm sure they're not amused by you thumping your chest in a github issue.\r\n\r\nOkay so less typesafe, you say?  How exactly? Can you give me an example of a bug that this feature would introduce? Because the bug you mention is already there, but at the moment it's there in JS-land and TS-land. This feature would catch the bug in TS-land. Given that there is no way in JS to check for `gram` vs `pound` or any other nominal type anyway, there is no code you can write to fix this. So TS is only blocking bugs in TS-land and keeping the same amount of bugs in JS-land. So I cannot see how it's less type-safe\r\n\r\nhttps://github.com/microsoft/TypeScript/issues/202#issuecomment-493769415\r\n> @aaronjensen if you have userland facing code that expects numbers and doesn't check if they're numbers, but instead rely on compile-time errors by TypeScript, then you're using the language wrong\r\n\r\nhttps://github.com/SimonMeskens/RPGBC/blame/gh-pages/scripts/assets.js#L184 Are you using the language wrong here by not checking whether game has a scene field? People use typescript so they don't have to check the arguments anymore. If JS-users mis-use the library, it's their problem. Yes, you can still check but that's a style of programming called https://en.wikipedia.org/wiki/Defensive_programming, not everybody needs to follow it, right?",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a> Your arguments have been answered but you always just find the answer unsatisfying.</p>\n<p dir=\"auto\"><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard?comment_id=493734035&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-493734035\">#202 (comment)</a></p>\n<blockquote>\n<p dir=\"auto\">TypeScript is a structural duck-typing language. Such a construct feels alien both to its design principles and JavaScript's, in my own opinion.</p>\n</blockquote>\n<p dir=\"auto\">So shouldn't types in general be alien to JavaScript as well? Duck-typing is by definition without types...</p>\n<p dir=\"auto\"><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard?comment_id=493766959&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-493766959\">#202 (comment)</a></p>\n<blockquote>\n<blockquote>\n<p dir=\"auto\">So <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/MicahZoltu/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/MicahZoltu\">@MicahZoltu</a> turned my argument on its head: \"TypeScript's entire type system is compile time only. None of the type information survives to runtime.\"</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p dir=\"auto\">Obviously yes. TypeScript aims to annotate JavaScript, not the other way round, so what happens at runtime in JavaScript is the truth that TS tries to capture. The whole reason that it gets to erase all types at runtime is because it solely attempts to capture runtime behavior.</p>\n</blockquote>\n<p dir=\"auto\">Typescript had classes before javascript did</p>\n<blockquote>\n<p dir=\"auto\">So in other words, your message is a great argument AGAINST nominal types. Suddenly we lose type safety at runtime, where previously we didn't.</p>\n</blockquote>\n<p dir=\"auto\">You always loose type safety at runtime when you run it with javascript.</p>\n<blockquote>\n<p dir=\"auto\">The response that will now come is probably: \"you don't have to use them\", but I do. For example, JS introduced classes, React started using them and now everyone using React was forced to write classes for years, whether they wanted it or not. The newest hot thing? \"React Hooks\", React without classes. These things matter. If you introduce nominal types, you're forcing me to use them eventually, in some library.</p>\n</blockquote>\n<p dir=\"auto\">That's a fair point but I'd argue that the user-land complexity doesn't increase. If you ever encounter them in the wild, it will be stopping you from doing something that will result in runtime errors.</p>\n<blockquote>\n<p dir=\"auto\">I don't WANT nominal types, this has nothing to do with need. There's such a thing as complexity. Every new feature introduces drawbacks. In this case, you would introduce fake type safety. The idea of two numbers that are not assignable to each other doesn't exist in JavaScript. So if you make a library in TS using nominal types and then share it with someone that uses it from pure JavaScript, you just created a bunch of potential bugs, because your code is 100% sure that these things don't mix, meanwhile, the userland code is sending you garbage.</p>\n</blockquote>\n<p dir=\"auto\">As said, TS already has this with string and numbers instead of numbers and numbers. The fact that there is no way in JS to check is actually the problem nominal types are trying to solve. It's impossible to catch this bug in JS, but can we at least solve it in TS?</p>\n<blockquote>\n<p dir=\"auto\">Btw, lu4, your second paragraph is funny. You claim you want stricter type safety, while advocating for compile-time-only type safety. I'm against nominal types because they are strictly LESS typesafe. I won't even dignify your stupid ad hominem about me being a tribesman that only knows one language with an answer (a cursory click on my profile reveals how silly that notion is), but I'd rather you don't make this personal? There's a lot of people reading this issue and I'm sure they're not amused by you thumping your chest in a github issue.</p>\n</blockquote>\n<p dir=\"auto\">Okay so less typesafe, you say?  How exactly? Can you give me an example of a bug that this feature would introduce? Because the bug you mention is already there, but at the moment it's there in JS-land and TS-land. This feature would catch the bug in TS-land. Given that there is no way in JS to check for <code class=\"notranslate\">gram</code> vs <code class=\"notranslate\">pound</code> or any other nominal type anyway, there is no code you can write to fix this. So TS is only blocking bugs in TS-land and keeping the same amount of bugs in JS-land. So I cannot see how it's less type-safe</p>\n<p dir=\"auto\"><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard?comment_id=493769415&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-493769415\">#202 (comment)</a></p>\n<blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/aaronjensen/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/aaronjensen\">@aaronjensen</a> if you have userland facing code that expects numbers and doesn't check if they're numbers, but instead rely on compile-time errors by TypeScript, then you're using the language wrong</p>\n</blockquote>\n<p dir=\"auto\"><a href=\"https://github.com/SimonMeskens/RPGBC/blame/gh-pages/scripts/assets.js#L184\">https://github.com/SimonMeskens/RPGBC/blame/gh-pages/scripts/assets.js#L184</a> Are you using the language wrong here by not checking whether game has a scene field? People use typescript so they don't have to check the arguments anymore. If JS-users mis-use the library, it's their problem. Yes, you can still check but that's a style of programming called <a href=\"https://en.wikipedia.org/wiki/Defensive_programming\" rel=\"nofollow\">https://en.wikipedia.org/wiki/Defensive_programming</a>, not everybody needs to follow it, right?</p>",
        "createdAt": "2019-05-19T19:56:45Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493786713",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 8
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5Mzc4ODM0OA==",
        "author": {
          "login": "SimonMeskens"
        },
        "authorAssociation": "NONE",
        "body": "\"Duck-typing is by definition without types\"\r\nDuck-typing is by definition a form of typing called structural typing. \r\n\r\n\"Typescript had classes before javascript did\"\r\nThis is not true if my memory serves me correctly. TypeScript classes were based on a W3C draft for JavaScript. The draft changed and that's why TS classes have slightly different syntax now. This was acknowledged as a mistake for the language and because of that, there's now new goals for TypeScript that try to avoid this mistake.\r\n\r\n\"You always loose type safety at runtime when you run it with javascript.\"\r\nIf your TypeScript code annotates runtime guarantees, you don't lose type safety when you erase the types at runtime. \r\n\r\n\"The fact that there is no way in JS to check is actually the problem nominal types are trying to solve.\"\r\nYes and all I'm saying is that that seems to be against the goals of the language. Not my call to make though, sometimes you bend the rules. In my opinion, TypeScript should never do something JavaScript can't. AFAIK, that's also the goal of the project, EXCEPT for a few very specific cases, all of which have runtime emits.\r\n\r\n\"Okay so less typesafe, you say? How exactly?\"\r\nLess typesafe in JS-land. Types exist whether you correctly identify and annotate them or not. This is not true in class-based languages, but like I mentioned earlier, structural type contracts ARE a valid form of types. The JS-contract doesn't have any nominality, so there's no nominality for TS to annotate. Classes on the other hand do seem to have some nominality and TS does try to correctly capture this.\r\n\r\n\"Defensive programming\"\r\nI'm not calling for defensive programming. Feel free to use tests or whatever other mechanism. I just don't think nominal types should be added for the reasons I explained. I don't even mind if you disagree or if this feature makes it in. I just think I'm entitled to argue what I've been arguing without people attacking my person 😉.\r\n\r\n\"not everybody needs to follow it, right?\"\r\nYES, exactly, not everybody needs to follow whatever idea others have. I don't like the idea of adding everything and the kitchen sink to TypeScript. Nominal types feels like it's a feature that requires some very heavy argumentation and I'm not seeing that beyond \"it would be nice\". Feel free to disagree, I made my case without resorting to attacking people and I don't mind people not agreeing.",
        "bodyHTML": "<p dir=\"auto\">\"Duck-typing is by definition without types\"<br>\nDuck-typing is by definition a form of typing called structural typing.</p>\n<p dir=\"auto\">\"Typescript had classes before javascript did\"<br>\nThis is not true if my memory serves me correctly. TypeScript classes were based on a W3C draft for JavaScript. The draft changed and that's why TS classes have slightly different syntax now. This was acknowledged as a mistake for the language and because of that, there's now new goals for TypeScript that try to avoid this mistake.</p>\n<p dir=\"auto\">\"You always loose type safety at runtime when you run it with javascript.\"<br>\nIf your TypeScript code annotates runtime guarantees, you don't lose type safety when you erase the types at runtime.</p>\n<p dir=\"auto\">\"The fact that there is no way in JS to check is actually the problem nominal types are trying to solve.\"<br>\nYes and all I'm saying is that that seems to be against the goals of the language. Not my call to make though, sometimes you bend the rules. In my opinion, TypeScript should never do something JavaScript can't. AFAIK, that's also the goal of the project, EXCEPT for a few very specific cases, all of which have runtime emits.</p>\n<p dir=\"auto\">\"Okay so less typesafe, you say? How exactly?\"<br>\nLess typesafe in JS-land. Types exist whether you correctly identify and annotate them or not. This is not true in class-based languages, but like I mentioned earlier, structural type contracts ARE a valid form of types. The JS-contract doesn't have any nominality, so there's no nominality for TS to annotate. Classes on the other hand do seem to have some nominality and TS does try to correctly capture this.</p>\n<p dir=\"auto\">\"Defensive programming\"<br>\nI'm not calling for defensive programming. Feel free to use tests or whatever other mechanism. I just don't think nominal types should be added for the reasons I explained. I don't even mind if you disagree or if this feature makes it in. I just think I'm entitled to argue what I've been arguing without people attacking my person 😉.</p>\n<p dir=\"auto\">\"not everybody needs to follow it, right?\"<br>\nYES, exactly, not everybody needs to follow whatever idea others have. I don't like the idea of adding everything and the kitchen sink to TypeScript. Nominal types feels like it's a feature that requires some very heavy argumentation and I'm not seeing that beyond \"it would be nice\". Feel free to disagree, I made my case without resorting to attacking people and I don't mind people not agreeing.</p>",
        "createdAt": "2019-05-19T20:19:59Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493788348",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 7
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5Mzc5NzA1MQ==",
        "author": {
          "login": "Pauan"
        },
        "authorAssociation": "NONE",
        "body": "> @SimonMeskens Enums aren't nominal, they get their identity by tracking a runtime address.\r\n\r\nEnums ***are*** nominal. The error is at compile time in the TypeScript compiler. At runtime the enum is structural (in my example both enums would be `1`). There is no runtime checking for enums.\r\n\r\nPlease get your facts straight before you criticize others.\r\n\r\n----\r\n\r\n> @SimonMeskens it's highly likely if given a do-over that the devs wouldn't add enums again\r\n\r\nCitation needed.\r\n\r\n----\r\n\r\n> @SimonMeskens Just let it go. If you want to argue in person, come find me on the TypeScript gitter, but leave this issue be.\r\n\r\nYou're the one constantly arguing and keeping the thread going. I made *one* post. You made many.\r\n\r\n----\r\n\r\n> @SimonMeskens I made my case without resorting to attacking people and I don't mind people not agreeing.\r\n\r\nYou attacked me for making a completely neutral and fact-based post.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a> Enums aren't nominal, they get their identity by tracking a runtime address.</p>\n</blockquote>\n<p dir=\"auto\">Enums <em><strong>are</strong></em> nominal. The error is at compile time in the TypeScript compiler. At runtime the enum is structural (in my example both enums would be <code class=\"notranslate\">1</code>). There is no runtime checking for enums.</p>\n<p dir=\"auto\">Please get your facts straight before you criticize others.</p>\n<hr>\n<blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a> it's highly likely if given a do-over that the devs wouldn't add enums again</p>\n</blockquote>\n<p dir=\"auto\">Citation needed.</p>\n<hr>\n<blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a> Just let it go. If you want to argue in person, come find me on the TypeScript gitter, but leave this issue be.</p>\n</blockquote>\n<p dir=\"auto\">You're the one constantly arguing and keeping the thread going. I made <em>one</em> post. You made many.</p>\n<hr>\n<blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/SimonMeskens/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SimonMeskens\">@SimonMeskens</a> I made my case without resorting to attacking people and I don't mind people not agreeing.</p>\n</blockquote>\n<p dir=\"auto\">You attacked me for making a completely neutral and fact-based post.</p>",
        "createdAt": "2019-05-19T22:22:33Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493797051",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 8
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5Mzc5OTE3Mg==",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "Guys sorry to interrupt but we're burying this issue, let us stop fighting and try to concentrate on more important things, like syntax or ways on how pull up working candidate implementation. I personally liked the @ExE-Boss notation\r\n\r\n```\r\n// Signed integers:\r\nnominal type i8 = number;\r\nnominal type i16 = number;\r\nnominal type i32 = number;\r\nnominal type isize = number;\r\n\r\n// Unsigned integers:\r\nnominal type u8 = number;\r\nnominal type u16 = number;\r\nnominal type u32 = number;\r\nnominal type usize = number;\r\n\r\n// IEEE-754 floating point numbers:\r\nnominal type f32 = number;\r\nnominal type f64 = number;\r\n```\r\n\r\nbut it hides the structure of what a nominal type is, on the other hand the following example gives clear understanding of what nominal type is but it has long tail of copy-pasta and blocks ability to type-alias this copy-pasta:\r\n\r\n```\r\nexport type Kilos<T> = T & { readonly discriminator: unique symbol };\r\nexport type Pounds<T> = T & { readonly discriminator: unique symbol };\r\n...\r\n```\r\n\r\nHere's another concept that looks promising that I was able to pull up:\r\n\r\n```\r\n//     ||||||\r\nexport unique type Nominal<T> = T & { readonly discriminator: unique symbol };\r\n//     ||||||\r\n\r\nexport type Kilos<T> = Nominal<T>\r\nexport type Pounds<T> = Nominal<T>\r\n\r\nexport interface MetricWeight {\r\n    value: Kilos<number>\r\n}\r\n\r\nexport interface ImperialWeight {\r\n    value: Pounds<number>\r\n}\r\n\r\nconst wm: MetricWeight = { value: 0 as Kilos<number> }\r\nconst wi: ImperialWeight = { value: 0 as Pounds<number> }\r\n\r\nwm.value = wi.value;                       // Should error\r\nwi.value = wi.value * 2;                   // Shouldn't error, but it's +/- ok if it does\r\nwi.value = wi.value * 2 as Pounds<number>; // Shouldn't error\r\nwm.value = wi.value * 2;                   // Should error\r\nconst we: MetricWeight = { value: 0 }      // Should error\r\n```\r\n\r\nI think such approach might allow to construct nominal types by hand and also cover broader set of cases. My question is have anyone ever encountered necessity to create unique type aliases?\r\n\r\nAs it stands to me, such notation would allow to create the notion of `unique symbol` itself so it seems very powerful concept...",
        "bodyHTML": "<p dir=\"auto\">Guys sorry to interrupt but we're burying this issue, let us stop fighting and try to concentrate on more important things, like syntax or ways on how pull up working candidate implementation. I personally liked the <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/ExE-Boss/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ExE-Boss\">@ExE-Boss</a> notation</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"// Signed integers:\nnominal type i8 = number;\nnominal type i16 = number;\nnominal type i32 = number;\nnominal type isize = number;\n\n// Unsigned integers:\nnominal type u8 = number;\nnominal type u16 = number;\nnominal type u32 = number;\nnominal type usize = number;\n\n// IEEE-754 floating point numbers:\nnominal type f32 = number;\nnominal type f64 = number;\"><pre class=\"notranslate\"><code class=\"notranslate\">// Signed integers:\nnominal type i8 = number;\nnominal type i16 = number;\nnominal type i32 = number;\nnominal type isize = number;\n\n// Unsigned integers:\nnominal type u8 = number;\nnominal type u16 = number;\nnominal type u32 = number;\nnominal type usize = number;\n\n// IEEE-754 floating point numbers:\nnominal type f32 = number;\nnominal type f64 = number;\n</code></pre></div>\n<p dir=\"auto\">but it hides the structure of what a nominal type is, on the other hand the following example gives clear understanding of what nominal type is but it has long tail of copy-pasta and blocks ability to type-alias this copy-pasta:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"export type Kilos&lt;T&gt; = T &amp; { readonly discriminator: unique symbol };\nexport type Pounds&lt;T&gt; = T &amp; { readonly discriminator: unique symbol };\n...\"><pre class=\"notranslate\"><code class=\"notranslate\">export type Kilos&lt;T&gt; = T &amp; { readonly discriminator: unique symbol };\nexport type Pounds&lt;T&gt; = T &amp; { readonly discriminator: unique symbol };\n...\n</code></pre></div>\n<p dir=\"auto\">Here's another concept that looks promising that I was able to pull up:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"//     ||||||\nexport unique type Nominal&lt;T&gt; = T &amp; { readonly discriminator: unique symbol };\n//     ||||||\n\nexport type Kilos&lt;T&gt; = Nominal&lt;T&gt;\nexport type Pounds&lt;T&gt; = Nominal&lt;T&gt;\n\nexport interface MetricWeight {\n    value: Kilos&lt;number&gt;\n}\n\nexport interface ImperialWeight {\n    value: Pounds&lt;number&gt;\n}\n\nconst wm: MetricWeight = { value: 0 as Kilos&lt;number&gt; }\nconst wi: ImperialWeight = { value: 0 as Pounds&lt;number&gt; }\n\nwm.value = wi.value;                       // Should error\nwi.value = wi.value * 2;                   // Shouldn't error, but it's +/- ok if it does\nwi.value = wi.value * 2 as Pounds&lt;number&gt;; // Shouldn't error\nwm.value = wi.value * 2;                   // Should error\nconst we: MetricWeight = { value: 0 }      // Should error\"><pre class=\"notranslate\"><code class=\"notranslate\">//     ||||||\nexport unique type Nominal&lt;T&gt; = T &amp; { readonly discriminator: unique symbol };\n//     ||||||\n\nexport type Kilos&lt;T&gt; = Nominal&lt;T&gt;\nexport type Pounds&lt;T&gt; = Nominal&lt;T&gt;\n\nexport interface MetricWeight {\n    value: Kilos&lt;number&gt;\n}\n\nexport interface ImperialWeight {\n    value: Pounds&lt;number&gt;\n}\n\nconst wm: MetricWeight = { value: 0 as Kilos&lt;number&gt; }\nconst wi: ImperialWeight = { value: 0 as Pounds&lt;number&gt; }\n\nwm.value = wi.value;                       // Should error\nwi.value = wi.value * 2;                   // Shouldn't error, but it's +/- ok if it does\nwi.value = wi.value * 2 as Pounds&lt;number&gt;; // Shouldn't error\nwm.value = wi.value * 2;                   // Should error\nconst we: MetricWeight = { value: 0 }      // Should error\n</code></pre></div>\n<p dir=\"auto\">I think such approach might allow to construct nominal types by hand and also cover broader set of cases. My question is have anyone ever encountered necessity to create unique type aliases?</p>\n<p dir=\"auto\">As it stands to me, such notation would allow to create the notion of <code class=\"notranslate\">unique symbol</code> itself so it seems very powerful concept...</p>",
        "createdAt": "2019-05-19T22:55:22Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-493799172",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 8
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDEyODg5MQ==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "BTW, the syntax enabling [this proposal of mine](https://github.com/microsoft/TypeScript/issues/202#issuecomment-437306455) was apparently [intentionally carved out for a purpose like that](https://github.com/microsoft/TypeScript/issues/202#issuecomment-437444382), so the solution may end up looking like that.",
        "bodyHTML": "<p dir=\"auto\">BTW, the syntax enabling <a href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-437306455\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">this proposal of mine</a> was apparently <a href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-437444382\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">intentionally carved out for a purpose like that</a>, so the solution may end up looking like that.</p>",
        "createdAt": "2019-05-20T19:58:23Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494128891",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDEzMjgzMA==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "the idea of nominal **numbers** sounds hands down wrong right outside of the box\r\n\r\nnumbers do not need to be nominal\r\n\r\nnumbers need units of measure: #364\r\n\r\n(which are your beloved nominals + algebraic operations)\r\n\r\nillustrative examples:\r\n- https://github.com/microsoft/TypeScript/issues/364#issuecomment-355623349\r\n- https://github.com/microsoft/TypeScript/issues/364#issuecomment-421183822",
        "bodyHTML": "<p dir=\"auto\">the idea of nominal <strong>numbers</strong> sounds hands down wrong right outside of the box</p>\n<p dir=\"auto\">numbers do not need to be nominal</p>\n<p dir=\"auto\">numbers need units of measure: <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"39567277\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/364\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/364/hovercard\" href=\"https://github.com/microsoft/TypeScript/issues/364\">#364</a></p>\n<p dir=\"auto\">(which are your beloved nominals + algebraic operations)</p>\n<p dir=\"auto\">illustrative examples:</p>\n<ul dir=\"auto\">\n<li><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"39567277\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/364\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/364/hovercard?comment_id=355623349&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/364#issuecomment-355623349\">#364 (comment)</a></li>\n<li><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"39567277\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/364\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/364/hovercard?comment_id=421183822&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/364#issuecomment-421183822\">#364 (comment)</a></li>\n</ul>",
        "createdAt": "2019-05-20T20:10:13Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494132830",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDEzNjQyNQ==",
        "author": {
          "login": "jleclanche"
        },
        "authorAssociation": "NONE",
        "body": "Units of measure are a great extension to nominal types imo but I don't think it makes sense to have nominal types and exclude numbers just-because.",
        "bodyHTML": "<p dir=\"auto\">Units of measure are a great extension to nominal types imo but I don't think it makes sense to have nominal types and exclude numbers just-because.</p>",
        "createdAt": "2019-05-20T20:21:46Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494136425",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 7
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDE0ODkzNQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "false in the context of the recent discussion\r\ntrue in the context of other possible uses, like: `type UserId = number & As<'user-id'>`",
        "bodyHTML": "<p dir=\"auto\">false in the context of the recent discussion<br>\ntrue in the context of other possible uses, like: <code class=\"notranslate\">type UserId = number &amp; As&lt;'user-id'&gt;</code></p>",
        "createdAt": "2019-05-20T20:59:18Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494148935",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDE3MzEzOQ==",
        "author": {
          "login": "kbtz"
        },
        "authorAssociation": "NONE",
        "body": "@jleclanche Agreed. Once nominal types are accepted, units of measure might become a simple syntax sugar implementation.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/jleclanche/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jleclanche\">@jleclanche</a> Agreed. Once nominal types are accepted, units of measure might become a simple syntax sugar implementation.</p>",
        "createdAt": "2019-05-20T22:29:50Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494173139",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDE4MzYyNQ==",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows I like your style 🤣 The idea of `unique type` seems to be flying in the air. And there's quite a couple of impressive and view-changing examples you've got there. I think you need to pull them down here because 300+ answers above have lost their significance (I think most people are just scrolling down).\r\n\r\nNow after looking into those examples I don't understand how we were living without `unique type`. It's so expressive and powerful. It feels like the `unique type` is similar to logical `not` operator but on types, you already state that in your examples:\r\n\r\n`string & (unique unknown)` is assignable to `string`, **but not** `never`.\r\n`unknown & (unique string)` is assignable to `string`, **but not** `never`.\r\n\r\nI'm actually asking this with a purpose, why not use `!` as syntax for `unique type`. Logical `not` operator is semantically similar, plus we already have `&` and `|` on types, why not to consider `!`? \r\n\r\nConsider your examples in a new light:\r\n\r\n`string & !unknown` is assignable to `string`, **but not** `never`.\r\n`unknown & !string` is assignable to `string`, **but not** `never`.\r\n\r\n`!A & !B` is assignable to `A & B`, **but is not** equivalent.\r\n\r\nAlso no need for parenthesis thus less code, which is a universal marker for a better architecture...",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows I like your style 🤣 The idea of <code class=\"notranslate\">unique type</code> seems to be flying in the air. And there's quite a couple of impressive and view-changing examples you've got there. I think you need to pull them down here because 300+ answers above have lost their significance (I think most people are just scrolling down).</p>\n<p dir=\"auto\">Now after looking into those examples I don't understand how we were living without <code class=\"notranslate\">unique type</code>. It's so expressive and powerful. It feels like the <code class=\"notranslate\">unique type</code> is similar to logical <code class=\"notranslate\">not</code> operator but on types, you already state that in your examples:</p>\n<p dir=\"auto\"><code class=\"notranslate\">string &amp; (unique unknown)</code> is assignable to <code class=\"notranslate\">string</code>, <strong>but not</strong> <code class=\"notranslate\">never</code>.<br>\n<code class=\"notranslate\">unknown &amp; (unique string)</code> is assignable to <code class=\"notranslate\">string</code>, <strong>but not</strong> <code class=\"notranslate\">never</code>.</p>\n<p dir=\"auto\">I'm actually asking this with a purpose, why not use <code class=\"notranslate\">!</code> as syntax for <code class=\"notranslate\">unique type</code>. Logical <code class=\"notranslate\">not</code> operator is semantically similar, plus we already have <code class=\"notranslate\">&amp;</code> and <code class=\"notranslate\">|</code> on types, why not to consider <code class=\"notranslate\">!</code>?</p>\n<p dir=\"auto\">Consider your examples in a new light:</p>\n<p dir=\"auto\"><code class=\"notranslate\">string &amp; !unknown</code> is assignable to <code class=\"notranslate\">string</code>, <strong>but not</strong> <code class=\"notranslate\">never</code>.<br>\n<code class=\"notranslate\">unknown &amp; !string</code> is assignable to <code class=\"notranslate\">string</code>, <strong>but not</strong> <code class=\"notranslate\">never</code>.</p>\n<p dir=\"auto\"><code class=\"notranslate\">!A &amp; !B</code> is assignable to <code class=\"notranslate\">A &amp; B</code>, <strong>but is not</strong> equivalent.</p>\n<p dir=\"auto\">Also no need for parenthesis thus less code, which is a universal marker for a better architecture...</p>",
        "createdAt": "2019-05-20T23:21:36Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494183625",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDE5MjEzMg==",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "> the idea of nominal **numbers** sounds hands down wrong right outside of the box\r\n> \r\n> numbers do not need to be nominal\r\n> \r\n> numbers need units of measure: #364\r\n> \r\n> (which are your beloved nominals + algebraic operations)\r\n> \r\n> illustrative examples:\r\n> \r\n> * [#364 (comment)](https://github.com/microsoft/TypeScript/issues/364#issuecomment-355623349)\r\n> * [#364 (comment)](https://github.com/microsoft/TypeScript/issues/364#issuecomment-421183822)\r\n\r\nI would argue with this. First, not always you need to allow the use of arithmetic operators on nominal types. Numbers are just one case and even though the JavaScript does not support operator overloading but there are ill cases that should not just work on generic types or numbers. Take speed of light as an example which in some cases should not be allowed to directly multiplied or summed unless a person knows what it's doing. \r\n\r\nEventually both of the terms are similar so it's not just a matter of sense that we put into `unit of measure` or `nominal number` terms. It's about expressivity, flexibility and convenience of a language feature that should be measurably compared between alternatives.\r\n\r\nSo what seems important is not to replicate the sense we put into words we prefer but rather introduce a flexible, expressive and convenient language feature.\r\n\r\nOne more example would require an expectation for forward-compatibility scenario in JavaScript since arithmetical operators are not overloadable in JavaScript (for now) but who knows how it'll go in future. \r\n\r\nSo in this regard a correlated example would be a `Quaternion` which has some ill defined operator behavior. You can multiply quaternion over vector but not vice versa. You can add / subtract quaternions but not multiply them, neither you can add quaternion to vector.\r\n\r\nAlso if we'd  start covering physics of Planck scale we'd find a lot of cases where having a `unit of measure` instead of a `nominal type` would be more harmful. It happens so just because `nominal type` discussed above is measurably more expressive and flexible (cover wider variety of use-cases) than a `unit of measure`, it's not that I just like this or that term better.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">the idea of nominal <strong>numbers</strong> sounds hands down wrong right outside of the box</p>\n<p dir=\"auto\">numbers do not need to be nominal</p>\n<p dir=\"auto\">numbers need units of measure: <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"39567277\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/364\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/364/hovercard\" href=\"https://github.com/microsoft/TypeScript/issues/364\">#364</a></p>\n<p dir=\"auto\">(which are your beloved nominals + algebraic operations)</p>\n<p dir=\"auto\">illustrative examples:</p>\n<ul dir=\"auto\">\n<li><a href=\"https://github.com/microsoft/TypeScript/issues/364#issuecomment-355623349\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/364/hovercard\">#364 (comment)</a></li>\n<li><a href=\"https://github.com/microsoft/TypeScript/issues/364#issuecomment-421183822\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/364/hovercard\">#364 (comment)</a></li>\n</ul>\n</blockquote>\n<p dir=\"auto\">I would argue with this. First, not always you need to allow the use of arithmetic operators on nominal types. Numbers are just one case and even though the JavaScript does not support operator overloading but there are ill cases that should not just work on generic types or numbers. Take speed of light as an example which in some cases should not be allowed to directly multiplied or summed unless a person knows what it's doing.</p>\n<p dir=\"auto\">Eventually both of the terms are similar so it's not just a matter of sense that we put into <code class=\"notranslate\">unit of measure</code> or <code class=\"notranslate\">nominal number</code> terms. It's about expressivity, flexibility and convenience of a language feature that should be measurably compared between alternatives.</p>\n<p dir=\"auto\">So what seems important is not to replicate the sense we put into words we prefer but rather introduce a flexible, expressive and convenient language feature.</p>\n<p dir=\"auto\">One more example would require an expectation for forward-compatibility scenario in JavaScript since arithmetical operators are not overloadable in JavaScript (for now) but who knows how it'll go in future.</p>\n<p dir=\"auto\">So in this regard a correlated example would be a <code class=\"notranslate\">Quaternion</code> which has some ill defined operator behavior. You can multiply quaternion over vector but not vice versa. You can add / subtract quaternions but not multiply them, neither you can add quaternion to vector.</p>\n<p dir=\"auto\">Also if we'd  start covering physics of Planck scale we'd find a lot of cases where having a <code class=\"notranslate\">unit of measure</code> instead of a <code class=\"notranslate\">nominal type</code> would be more harmful. It happens so just because <code class=\"notranslate\">nominal type</code> discussed above is measurably more expressive and flexible (cover wider variety of use-cases) than a <code class=\"notranslate\">unit of measure</code>, it's not that I just like this or that term better.</p>",
        "createdAt": "2019-05-21T00:07:16Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494192132",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDE5MzI5Mg==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "i will argue too\r\n\r\nyou only need numbers because of their properties that come out of arithmetic operations\r\nlike how to get 2 our of 1 and 1\r\n\r\nif you don't care about such operations you don't need numbers at all, any type (including nominal strings and booleans) can fit for that:\r\n\r\n```\r\ntype UserId = number & As<'user-id'>;\r\n// is no different from\r\ntype PersonId = string & As<'person-id'>;\r\n// is no different from\r\ntype EmployeeId = boolean & As<'employee-id'>\r\n// is no different from any other OPAQUE type with no operations defined on it\r\n```\r\n\r\nand how does Planck scale numbers change anything? math is about abstracts no matter how big or small\r\n\r\nand quaternion is not a number, it's a vector (a tuple) of 4 numbers, which is no different from an object with 4 properties\r\n\r\nare we talking still talking about numbers or objects?\r\n\r\nlastly operator overloads are **orthogonal** to nominal types and to units of measure, to say more, they are merely syntactic sugar (can be easily implemented via classes/methods), not sure why you brought them up here",
        "bodyHTML": "<p dir=\"auto\">i will argue too</p>\n<p dir=\"auto\">you only need numbers because of their properties that come out of arithmetic operations<br>\nlike how to get 2 our of 1 and 1</p>\n<p dir=\"auto\">if you don't care about such operations you don't need numbers at all, any type (including nominal strings and booleans) can fit for that:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"type UserId = number &amp; As&lt;'user-id'&gt;;\n// is no different from\ntype PersonId = string &amp; As&lt;'person-id'&gt;;\n// is no different from\ntype EmployeeId = boolean &amp; As&lt;'employee-id'&gt;\n// is no different from any other OPAQUE type with no operations defined on it\"><pre class=\"notranslate\"><code class=\"notranslate\">type UserId = number &amp; As&lt;'user-id'&gt;;\n// is no different from\ntype PersonId = string &amp; As&lt;'person-id'&gt;;\n// is no different from\ntype EmployeeId = boolean &amp; As&lt;'employee-id'&gt;\n// is no different from any other OPAQUE type with no operations defined on it\n</code></pre></div>\n<p dir=\"auto\">and how does Planck scale numbers change anything? math is about abstracts no matter how big or small</p>\n<p dir=\"auto\">and quaternion is not a number, it's a vector (a tuple) of 4 numbers, which is no different from an object with 4 properties</p>\n<p dir=\"auto\">are we talking still talking about numbers or objects?</p>\n<p dir=\"auto\">lastly operator overloads are <strong>orthogonal</strong> to nominal types and to units of measure, to say more, they are merely syntactic sugar (can be easily implemented via classes/methods), not sure why you brought them up here</p>",
        "createdAt": "2019-05-21T00:13:44Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494193292",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDE5NzY4Mw==",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "> if you don't care about such operations you don't need numbers at all\r\n\r\nI don't understand how you came to such conclusion? Also where did this `As<...>` syntax came from? Github seems to erase parts of DOM tree that aren't displayed, so I'm unable to search for it? Also does this `As<...>` syntax supports name spacing? Because otherwise it seems that we can fall into conflict between strings and loose compiler support for such nominals...\r\n\r\n> and how does Planck scale numbers change anything? math is about abstracts no matter how big or small\r\n\r\nThis was just an example that was mend to show that `unique type` covers broader set of cases.\r\nIt's like if we're choosing (Ok, let's be realistic, we're not choosing anything we're just imagining how good it'll be to have this or that feature). Ok, so what we're discussing is two language features and we're trying to figure out which feature is better which feature would be worser. However different people put different meaning into \"better\" or \"worser\" and to actually find truly better one we would have to do some measurements. And in order not to talk in circles saying whose Kung-fu is better, we need to pick some measurable scale and measure which feature is better and which feature is worser. If we'd be able to agree on scale, we'd be able to agree on notion of better and worser feature. \r\n\r\n>and quaternion is not a number, it's a vector (a tuple) of 4 numbers, which is no different from an object with 4 properties\r\n\r\nYes it's object, or array, or ... again I've introduced this example as an attempt to convince you that unique types are better than just unit of measure\r\n\r\nAnd operator overloads also was an example in attempt to convince you that unique types are better than just unit of measure\r\n\r\nNot sure however if operator overloads are really orthogonal to nominal types, I've tried to imagine it and for a second ... fell out into 5-th dimension 😆 ",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">if you don't care about such operations you don't need numbers at all</p>\n</blockquote>\n<p dir=\"auto\">I don't understand how you came to such conclusion? Also where did this <code class=\"notranslate\">As&lt;...&gt;</code> syntax came from? Github seems to erase parts of DOM tree that aren't displayed, so I'm unable to search for it? Also does this <code class=\"notranslate\">As&lt;...&gt;</code> syntax supports name spacing? Because otherwise it seems that we can fall into conflict between strings and loose compiler support for such nominals...</p>\n<blockquote>\n<p dir=\"auto\">and how does Planck scale numbers change anything? math is about abstracts no matter how big or small</p>\n</blockquote>\n<p dir=\"auto\">This was just an example that was mend to show that <code class=\"notranslate\">unique type</code> covers broader set of cases.<br>\nIt's like if we're choosing (Ok, let's be realistic, we're not choosing anything we're just imagining how good it'll be to have this or that feature). Ok, so what we're discussing is two language features and we're trying to figure out which feature is better which feature would be worser. However different people put different meaning into \"better\" or \"worser\" and to actually find truly better one we would have to do some measurements. And in order not to talk in circles saying whose Kung-fu is better, we need to pick some measurable scale and measure which feature is better and which feature is worser. If we'd be able to agree on scale, we'd be able to agree on notion of better and worser feature.</p>\n<blockquote>\n<p dir=\"auto\">and quaternion is not a number, it's a vector (a tuple) of 4 numbers, which is no different from an object with 4 properties</p>\n</blockquote>\n<p dir=\"auto\">Yes it's object, or array, or ... again I've introduced this example as an attempt to convince you that unique types are better than just unit of measure</p>\n<p dir=\"auto\">And operator overloads also was an example in attempt to convince you that unique types are better than just unit of measure</p>\n<p dir=\"auto\">Not sure however if operator overloads are really orthogonal to nominal types, I've tried to imagine it and for a second ... fell out into 5-th dimension 😆</p>",
        "createdAt": "2019-05-21T00:41:12Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494197683",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDE5ODc3OQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "this syntax comes from here and formally described with today's version of typescript:\r\n> https://github.com/microsoft/TypeScript/issues/364#issuecomment-355623349\r\n\r\nnumbers without operations are useless, and so far operations haven't been even slightly touched in the recent conversation until i mentioned units of measure\r\n\r\neverything else (including Planck scale numbers, Quotations, operator overloads) seems not to be directly related to the problem of nominal types",
        "bodyHTML": "<p dir=\"auto\">this syntax comes from here and formally described with today's version of typescript:</p>\n<blockquote>\n<p dir=\"auto\"><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"39567277\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/364\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/364/hovercard?comment_id=355623349&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/364#issuecomment-355623349\">#364 (comment)</a></p>\n</blockquote>\n<p dir=\"auto\">numbers without operations are useless, and so far operations haven't been even slightly touched in the recent conversation until i mentioned units of measure</p>\n<p dir=\"auto\">everything else (including Planck scale numbers, Quotations, operator overloads) seems not to be directly related to the problem of nominal types</p>",
        "createdAt": "2019-05-21T00:48:03Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494198779",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDIwMDU0MA==",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "I can already make numbers without operations using:\r\n\r\n```\r\nexport type Kilos<T> = T & { readonly discriminator: unique symbol };\r\nexport type Pounds<T> = T & { readonly discriminator: unique symbol };\r\n...\r\n```\r\n\r\nI'm grateful that existing syntax already allows me to express thoughts this way. \r\n\r\nI'd just like the snippet to be a little shorter. You  do not find this case useful, I find this case useful, I see that it aligns with my markers of a good architectural decision. Also I see that I can not convince you, so why to bother doing so? I think you have similar thoughts in my regard, right? 😆 ",
        "bodyHTML": "<p dir=\"auto\">I can already make numbers without operations using:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"export type Kilos&lt;T&gt; = T &amp; { readonly discriminator: unique symbol };\nexport type Pounds&lt;T&gt; = T &amp; { readonly discriminator: unique symbol };\n...\"><pre class=\"notranslate\"><code class=\"notranslate\">export type Kilos&lt;T&gt; = T &amp; { readonly discriminator: unique symbol };\nexport type Pounds&lt;T&gt; = T &amp; { readonly discriminator: unique symbol };\n...\n</code></pre></div>\n<p dir=\"auto\">I'm grateful that existing syntax already allows me to express thoughts this way.</p>\n<p dir=\"auto\">I'd just like the snippet to be a little shorter. You  do not find this case useful, I find this case useful, I see that it aligns with my markers of a good architectural decision. Also I see that I can not convince you, so why to bother doing so? I think you have similar thoughts in my regard, right? 😆</p>",
        "createdAt": "2019-05-21T00:59:20Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494200540",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDIwMDc3MQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "right this very example of yours comes to the operations, however it doesn't mention any rule of reduction/conversion of units, but it's shot in the right direction (the answer is unit of measures btw)",
        "bodyHTML": "<p dir=\"auto\">right this very example of yours comes to the operations, however it doesn't mention any rule of reduction/conversion of units, but it's shot in the right direction (the answer is unit of measures btw)</p>",
        "createdAt": "2019-05-21T01:00:44Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494200771",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDIwNjIwMA==",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "Units of measure does not allow me to control where the types are allowed to infer the type of arithmetic operation result where not.\r\n\r\nUnits of measures the way you present them are only applicable to numbers, while nominals describe above can be used with any atomic or complex types.\r\n\r\nUnits of measure in terms of implementation is one big `if (variableType === number) { ... }` in implementation of the language. Why would one need it if you can have nominals to do the same thing for every possible type. It's like what good is to have a phone as an invention that is capable to call specifically only one number (your ex for instance 🤣)? \r\n\r\nThe nominal's would be better if arithmetic operator result inference were possible but since there is no operator overloading in the language, there is no such support, sorry, feature request anyone? 😄. \r\n\r\nSaying that you would never need to use a nominal on any type other than number is similar to saying that you would never need to use a unit of measure. It's an opinion, like yours, like mine, no difference.\r\n\r\nConsider the following example as a stock-market position:\r\n\r\n```typescript\r\nexport type OrderId<T> = T & { readonly discriminator: unique symbol };\r\nexport type PositionId<T> = T & { readonly discriminator: unique symbol };\r\n\r\nexport type BaseAssetAmount<T> = T & { readonly discriminator: unique symbol };\r\nexport type QuoteAssetAmount<T> = T & { readonly discriminator: unique symbol };\r\n\r\nexport class Position {\r\n    public id: PositionId<string>;\r\n    public orderId: OrderId<number>;\r\n\r\n    public price: number;\r\n    public symbol: string;\r\n\r\n    public baseAsset: string;\r\n    public quoteAsset: string;\r\n\r\n    public baseAmount: BaseAssetAmount<number>;\r\n    public quoteAmount: QuoteAssetAmount<number>;\r\n\r\n    public createdTime: number;\r\n    public changedTime: number;\r\n\r\n    public trailing: boolean;\r\n}\r\n```\r\n\r\nBy declaring `baseAmount` and `quoteAmount` as nominal types I'm now sure that compiler wouldn't allow something like:\r\n\r\n```typescript\r\np.baseAmount = p.quoteAmount\r\n```\r\n\r\nwithout explicit permission\r\n\r\n```typescript\r\np.baseAmount = p.quoteAmount * price as BaseAssetAmount<number> // Here in order to succeed  I need to check the operation,\r\n// make sure it is correct (write test potentially) and allow the assign operator to work through explicit type casting.\r\n// Compiler helps to spot potentially thin places...\r\n```\r\n\r\nIt's also easy to find all thin places in the project and make sure they have tests in place",
        "bodyHTML": "<p dir=\"auto\">Units of measure does not allow me to control where the types are allowed to infer the type of arithmetic operation result where not.</p>\n<p dir=\"auto\">Units of measures the way you present them are only applicable to numbers, while nominals describe above can be used with any atomic or complex types.</p>\n<p dir=\"auto\">Units of measure in terms of implementation is one big <code class=\"notranslate\">if (variableType === number) { ... }</code> in implementation of the language. Why would one need it if you can have nominals to do the same thing for every possible type. It's like what good is to have a phone as an invention that is capable to call specifically only one number (your ex for instance 🤣)?</p>\n<p dir=\"auto\">The nominal's would be better if arithmetic operator result inference were possible but since there is no operator overloading in the language, there is no such support, sorry, feature request anyone? 😄.</p>\n<p dir=\"auto\">Saying that you would never need to use a nominal on any type other than number is similar to saying that you would never need to use a unit of measure. It's an opinion, like yours, like mine, no difference.</p>\n<p dir=\"auto\">Consider the following example as a stock-market position:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"export type OrderId&lt;T&gt; = T &amp; { readonly discriminator: unique symbol };\nexport type PositionId&lt;T&gt; = T &amp; { readonly discriminator: unique symbol };\n\nexport type BaseAssetAmount&lt;T&gt; = T &amp; { readonly discriminator: unique symbol };\nexport type QuoteAssetAmount&lt;T&gt; = T &amp; { readonly discriminator: unique symbol };\n\nexport class Position {\n    public id: PositionId&lt;string&gt;;\n    public orderId: OrderId&lt;number&gt;;\n\n    public price: number;\n    public symbol: string;\n\n    public baseAsset: string;\n    public quoteAsset: string;\n\n    public baseAmount: BaseAssetAmount&lt;number&gt;;\n    public quoteAmount: QuoteAssetAmount&lt;number&gt;;\n\n    public createdTime: number;\n    public changedTime: number;\n\n    public trailing: boolean;\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">OrderId</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">PositionId</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">BaseAssetAmount</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">QuoteAssetAmount</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">class</span> <span class=\"pl-smi\">Position</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">public</span> <span class=\"pl-c1\">id</span>: <span class=\"pl-smi\">PositionId</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-k\">public</span> <span class=\"pl-c1\">orderId</span>: <span class=\"pl-smi\">OrderId</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n    <span class=\"pl-k\">public</span> <span class=\"pl-c1\">price</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-k\">public</span> <span class=\"pl-c1\">symbol</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n\n    <span class=\"pl-k\">public</span> <span class=\"pl-c1\">baseAsset</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-k\">public</span> <span class=\"pl-c1\">quoteAsset</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n\n    <span class=\"pl-k\">public</span> <span class=\"pl-c1\">baseAmount</span>: <span class=\"pl-smi\">BaseAssetAmount</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-k\">public</span> <span class=\"pl-c1\">quoteAmount</span>: <span class=\"pl-smi\">QuoteAssetAmount</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n    <span class=\"pl-k\">public</span> <span class=\"pl-c1\">createdTime</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-k\">public</span> <span class=\"pl-c1\">changedTime</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n\n    <span class=\"pl-k\">public</span> <span class=\"pl-c1\">trailing</span>: <span class=\"pl-smi\">boolean</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">By declaring <code class=\"notranslate\">baseAmount</code> and <code class=\"notranslate\">quoteAmount</code> as nominal types I'm now sure that compiler wouldn't allow something like:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"p.baseAmount = p.quoteAmount\"><pre class=\"notranslate\"><span class=\"pl-s1\">p</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">baseAmount</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">p</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">quoteAmount</span></pre></div>\n<p dir=\"auto\">without explicit permission</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"p.baseAmount = p.quoteAmount * price as BaseAssetAmount&lt;number&gt; // Here in order to succeed  I need to check the operation,\n// make sure it is correct (write test potentially) and allow the assign operator to work through explicit type casting.\n// Compiler helps to spot potentially thin places...\"><pre class=\"notranslate\"><span class=\"pl-s1\">p</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">baseAmount</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">p</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">quoteAmount</span> <span class=\"pl-c1\">*</span> <span class=\"pl-s1\">price</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">BaseAssetAmount</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-c\">// Here in order to succeed  I need to check the operation,</span>\n<span class=\"pl-c\">// make sure it is correct (write test potentially) and allow the assign operator to work through explicit type casting.</span>\n<span class=\"pl-c\">// Compiler helps to spot potentially thin places...</span></pre></div>\n<p dir=\"auto\">It's also easy to find all thin places in the project and make sure they have tests in place</p>",
        "createdAt": "2019-05-21T01:33:44Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494206200",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDIxMDU4Ng==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "my point is that units of measure let you write the following without having an explicit cast to `BaseAssetAmount<number>`\r\n```ts\r\np.baseAmount = p.quoteAmount * price; // with units, there is no need in as BaseAssetAmount<number>\r\n```\r\nlet me put it differently, not only there is no need in an explicit cast, but rather, you cannot assign a value unless its unit of measure exactly matches or equivalent to the expected one",
        "bodyHTML": "<p dir=\"auto\">my point is that units of measure let you write the following without having an explicit cast to <code class=\"notranslate\">BaseAssetAmount&lt;number&gt;</code></p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"p.baseAmount = p.quoteAmount * price; // with units, there is no need in as BaseAssetAmount&lt;number&gt;\"><pre class=\"notranslate\"><span class=\"pl-s1\">p</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">baseAmount</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">p</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">quoteAmount</span> <span class=\"pl-c1\">*</span> <span class=\"pl-s1\">price</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// with units, there is no need in as BaseAssetAmount&lt;number&gt;</span></pre></div>\n<p dir=\"auto\">let me put it differently, not only there is no need in an explicit cast, but rather, you cannot assign a value unless its unit of measure exactly matches or equivalent to the expected one</p>",
        "createdAt": "2019-05-21T01:59:17Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494210586",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDIxMTcwNQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "it's granted, nominals are broader than units of measure\r\n\r\nnominals are a good thing where they apply, and there are a lot of use cases for them\r\n\r\nbut when it comes to numbers, instead of plain nominals you'd rather use units of measure\r\n\r\nreasons are:\r\n- the only thing nominals can do is to add a distinction to otherwise identical types, any operations on your own nominals need to be defined/described in your code using classes/methods/functions\r\n- units of measure, on the other hand, can make certain sets of numbers distinct from other set of number AND give you a mechanism of conversion from one set to another BY DEFAULT since all operations are standard and been known for centuries\r\n\r\nmy point is that when it comes to NUMBERS we don't need to reinvent the wheel, we need to admit that numbers are measured and settle with a standard set of operations on them: https://fsharpforfunandprofit.com/posts/units-of-measure/\r\n\r\nthis is what numbers are for and this is what they do\r\n\r\ndescribing a math problem with plain nominals is a poor choice when you can do it with units of measure WHEN IT COMES TO NUMBERS  ",
        "bodyHTML": "<p dir=\"auto\">it's granted, nominals are broader than units of measure</p>\n<p dir=\"auto\">nominals are a good thing where they apply, and there are a lot of use cases for them</p>\n<p dir=\"auto\">but when it comes to numbers, instead of plain nominals you'd rather use units of measure</p>\n<p dir=\"auto\">reasons are:</p>\n<ul dir=\"auto\">\n<li>the only thing nominals can do is to add a distinction to otherwise identical types, any operations on your own nominals need to be defined/described in your code using classes/methods/functions</li>\n<li>units of measure, on the other hand, can make certain sets of numbers distinct from other set of number AND give you a mechanism of conversion from one set to another BY DEFAULT since all operations are standard and been known for centuries</li>\n</ul>\n<p dir=\"auto\">my point is that when it comes to NUMBERS we don't need to reinvent the wheel, we need to admit that numbers are measured and settle with a standard set of operations on them: <a href=\"https://fsharpforfunandprofit.com/posts/units-of-measure/\" rel=\"nofollow\">https://fsharpforfunandprofit.com/posts/units-of-measure/</a></p>\n<p dir=\"auto\">this is what numbers are for and this is what they do</p>\n<p dir=\"auto\">describing a math problem with plain nominals is a poor choice when you can do it with units of measure WHEN IT COMES TO NUMBERS</p>",
        "createdAt": "2019-05-21T02:05:49Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494211705",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDIxMjQxMw==",
        "author": {
          "login": "eliseumds"
        },
        "authorAssociation": "NONE",
        "body": "Another interesting example of the benefit of nominal types (`date.toDateString()` vs `date.toISOString()`): https://twitter.com/WrocTypeScript/status/1032385714015559680",
        "bodyHTML": "<p dir=\"auto\">Another interesting example of the benefit of nominal types (<code class=\"notranslate\">date.toDateString()</code> vs <code class=\"notranslate\">date.toISOString()</code>): <a href=\"https://twitter.com/WrocTypeScript/status/1032385714015559680\" rel=\"nofollow\">https://twitter.com/WrocTypeScript/status/1032385714015559680</a></p>",
        "createdAt": "2019-05-21T02:09:40Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494212413",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDIxNDQwMg==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "@eliseumds in fact, like it was demonstrated in https://github.com/microsoft/TypeScript/issues/364#issuecomment-355623349, TypeScript is flexible enough to let you define your own algebra for your own types and operations whatever they are (measured numbers that we are talking about here is just an example)\r\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/eliseumds/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/eliseumds\">@eliseumds</a> in fact, like it was demonstrated in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"39567277\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/364\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/364/hovercard?comment_id=355623349&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/364#issuecomment-355623349\">#364 (comment)</a>, TypeScript is flexible enough to let you define your own algebra for your own types and operations whatever they are (measured numbers that we are talking about here is just an example)</p>",
        "createdAt": "2019-05-21T02:20:54Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494214402",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDIxNzUwOA==",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "Both proposals are limited by lack of operator overloading in typescript. You multiply your two `In<...>`  values you get `number` as a result. As a side question to think about before I go to sleep, is how to combine these concepts one seems to cancel another. Is there an intersection, a more relaxed version of nominal type that also has unit of measure notion???",
        "bodyHTML": "<p dir=\"auto\">Both proposals are limited by lack of operator overloading in typescript. You multiply your two <code class=\"notranslate\">In&lt;...&gt;</code>  values you get <code class=\"notranslate\">number</code> as a result. As a side question to think about before I go to sleep, is how to combine these concepts one seems to cancel another. Is there an intersection, a more relaxed version of nominal type that also has unit of measure notion???</p>",
        "createdAt": "2019-05-21T02:38:08Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494217508",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDIxOTYyOA==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "sorry for being annoyingly boring...\r\n\r\nwhat you saw is a workaround, it's very limited, unit conversion is done by leveraging the order of precedence of function/method overloads\r\nit's not a viable solution, it's just an experiment (that works up to its limits)\r\n\r\nmany people wish there was a first class support for units of measure like in F#: https://fsharpforfunandprofit.com/posts/units-of-measure/\r\n\r\nto wrap it up, my few points:\r\n- there are no nominals in typescript\r\n- with a few hacks you can do fake nominals in typescript today\r\n- typescript needs a full-fledged officially recognized support for nominals (that's why we are here)\r\n- nominals (fake or true) can be used to simulate units of measure (major use case for any number calculations)\r\n- like we saw with `F#` unit of measure should rather be a native feature of typescript\r\n- nominals have broader scope of use than just numbers\r\n- nominals are good",
        "bodyHTML": "<p dir=\"auto\">sorry for being annoyingly boring...</p>\n<p dir=\"auto\">what you saw is a workaround, it's very limited, unit conversion is done by leveraging the order of precedence of function/method overloads<br>\nit's not a viable solution, it's just an experiment (that works up to its limits)</p>\n<p dir=\"auto\">many people wish there was a first class support for units of measure like in F#: <a href=\"https://fsharpforfunandprofit.com/posts/units-of-measure/\" rel=\"nofollow\">https://fsharpforfunandprofit.com/posts/units-of-measure/</a></p>\n<p dir=\"auto\">to wrap it up, my few points:</p>\n<ul dir=\"auto\">\n<li>there are no nominals in typescript</li>\n<li>with a few hacks you can do fake nominals in typescript today</li>\n<li>typescript needs a full-fledged officially recognized support for nominals (that's why we are here)</li>\n<li>nominals (fake or true) can be used to simulate units of measure (major use case for any number calculations)</li>\n<li>like we saw with <code class=\"notranslate\">F#</code> unit of measure should rather be a native feature of typescript</li>\n<li>nominals have broader scope of use than just numbers</li>\n<li>nominals are good</li>\n</ul>",
        "createdAt": "2019-05-21T02:51:01Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494219628",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDIzMDY4Ng==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "Please move all the unit-of-measure discussion to #364. This is about nominal typing, which although it might *seem* similar, is a wholly different concept altogether. Nominal types can stand on their own and don't need \"converted\" to anything. Units of measure frequently need \"converted\" to other units of measure, and thus cannot generally stand alone.\r\n\r\nTo draw an analogy, units of measure are to nominal types as FP functors are to functions. They *sound* like they overlap, even if you know some of the theory around it, but that's about where the similarities end. Yes, you can make functors out of functions (by making `o.map(f)` equivalent to `x => o(f(x))`), but you can't make a function out of a functor. They also solve subtly different problems: functions abstract, functors generalize abstractions. Similarly, nominal types isolate, units of measure generalizes that isolation.",
        "bodyHTML": "<p dir=\"auto\">Please move all the unit-of-measure discussion to <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"39567277\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/364\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/364/hovercard\" href=\"https://github.com/microsoft/TypeScript/issues/364\">#364</a>. This is about nominal typing, which although it might <em>seem</em> similar, is a wholly different concept altogether. Nominal types can stand on their own and don't need \"converted\" to anything. Units of measure frequently need \"converted\" to other units of measure, and thus cannot generally stand alone.</p>\n<p dir=\"auto\">To draw an analogy, units of measure are to nominal types as FP functors are to functions. They <em>sound</em> like they overlap, even if you know some of the theory around it, but that's about where the similarities end. Yes, you can make functors out of functions (by making <code class=\"notranslate\">o.map(f)</code> equivalent to <code class=\"notranslate\">x =&gt; o(f(x))</code>), but you can't make a function out of a functor. They also solve subtly different problems: functions abstract, functors generalize abstractions. Similarly, nominal types isolate, units of measure generalizes that isolation.</p>",
        "createdAt": "2019-05-21T04:00:56Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494230686",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDIzMzE3MQ==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows i understand that units of measure to nominals is what high-heel shoes are to clothes in general, but the whole reason i brought it up is when i saw this\r\n```\r\nexport type Kilos<T> = Nominal<T>\r\nexport type Pounds<T> = Nominal<T>\r\n```\r\nit's clearly the case for high-heel shoes",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows i understand that units of measure to nominals is what high-heel shoes are to clothes in general, but the whole reason i brought it up is when i saw this</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"export type Kilos&lt;T&gt; = Nominal&lt;T&gt;\nexport type Pounds&lt;T&gt; = Nominal&lt;T&gt;\"><pre class=\"notranslate\"><code class=\"notranslate\">export type Kilos&lt;T&gt; = Nominal&lt;T&gt;\nexport type Pounds&lt;T&gt; = Nominal&lt;T&gt;\n</code></pre></div>\n<p dir=\"auto\">it's clearly the case for high-heel shoes</p>",
        "createdAt": "2019-05-21T04:17:20Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494233171",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDIzNTI4NA==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "besides having nominals all along is not going to help you that much: \r\n- ok you have nominals (yay!) now what? you need to operate on them.. and here is where we strike the wall because nothing is said about operational support, how do you turn NominalA to NominalB, now how about NominalA and NominalB + some rules that need to turn to NominalC or NominalD?\r\n\r\nhaving types along only solves one part of the puzzle",
        "bodyHTML": "<p dir=\"auto\">besides having nominals all along is not going to help you that much:</p>\n<ul dir=\"auto\">\n<li>ok you have nominals (yay!) now what? you need to operate on them.. and here is where we strike the wall because nothing is said about operational support, how do you turn NominalA to NominalB, now how about NominalA and NominalB + some rules that need to turn to NominalC or NominalD?</li>\n</ul>\n<p dir=\"auto\">having types along only solves one part of the puzzle</p>",
        "createdAt": "2019-05-21T04:31:15Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494235284",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDI4OTk1Mw==",
        "author": {
          "login": "iislucas"
        },
        "authorAssociation": "NONE",
        "body": "A common use of nominal types that I often find myself needing is to distinguish between indexes into different tables. In this case there is no desire for operations on the nominal entries (creation and getting indexes are typically controlled by a class). You really don't want to mix up the different indexes, or you'll get undefined objects and all sorts of badness. Having run-time checks is typically not helpful because it should never come up that you mix up your indexes.\r\n\r\nI also agree with @lu4, that we should bring back the discussion to actual proposals - and I might add stop the discussions on it should/should-not happen because I don't/do need it, unless there is actually a *new* point to be added that has not been discussed before - even the indexes suggestion are in my first post. We don't need to correct each others various (mis?)understandings. \r\n\r\nLets get back to the proposals to implement it/close-to-it with the existing tools - that's much more fun :) \r\n\r\nIf I was an admin on this repo, I'd do an aggressive pruning of the discussion to date to try and remove repetitions and narrow the discussion to actual proposals. <hint hint :) >",
        "bodyHTML": "<p dir=\"auto\">A common use of nominal types that I often find myself needing is to distinguish between indexes into different tables. In this case there is no desire for operations on the nominal entries (creation and getting indexes are typically controlled by a class). You really don't want to mix up the different indexes, or you'll get undefined objects and all sorts of badness. Having run-time checks is typically not helpful because it should never come up that you mix up your indexes.</p>\n<p dir=\"auto\">I also agree with <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lu4/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lu4\">@lu4</a>, that we should bring back the discussion to actual proposals - and I might add stop the discussions on it should/should-not happen because I don't/do need it, unless there is actually a <em>new</em> point to be added that has not been discussed before - even the indexes suggestion are in my first post. We don't need to correct each others various (mis?)understandings.</p>\n<p dir=\"auto\">Lets get back to the proposals to implement it/close-to-it with the existing tools - that's much more fun :)</p>\n<p dir=\"auto\">If I was an admin on this repo, I'd do an aggressive pruning of the discussion to date to try and remove repetitions and narrow the discussion to actual proposals. &lt;hint hint :) &gt;</p>",
        "createdAt": "2019-05-21T08:18:41Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494289953",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 6
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDMxMzAzMQ==",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows essentially I guess the question is over if nominal types (as you describe them) is sufficiently useful to deserve implementation, or if the effort should be saved for doing units of measure fully, especially if it might prevent a worse implementation of the latter. Essentially, if nominal types are needed if we had UOM seems pretty on-topic to me.\r\nMyself I'd prefer nominal types, if done, to be completely opaque by default, which handles the indexer case, then explicitly to add back in any operations or methods that apply, including relations to other types, which let's you implement your own units as a library. That would be the opposite: nominal types making UOM redundant.",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows essentially I guess the question is over if nominal types (as you describe them) is sufficiently useful to deserve implementation, or if the effort should be saved for doing units of measure fully, especially if it might prevent a worse implementation of the latter. Essentially, if nominal types are needed if we had UOM seems pretty on-topic to me.<br>\nMyself I'd prefer nominal types, if done, to be completely opaque by default, which handles the indexer case, then explicitly to add back in any operations or methods that apply, including relations to other types, which let's you implement your own units as a library. That would be the opposite: nominal types making UOM redundant.</p>",
        "createdAt": "2019-05-21T09:24:44Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494313031",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDMyMTE4Ng==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@simonbuchan \r\n\r\n> @isiahmeadows essentially I guess the question is over if nominal types (as you describe them) is sufficiently useful to deserve implementation, or if the effort should be saved for doing units of measure fully, especially if it might prevent a worse implementation of the latter. Essentially, if nominal types are needed if we had UOM seems pretty on-topic to me.\r\n\r\nI was referring to a large segment of discussion that was about the necessity of units of measure and very heavily conflating nominal typing with it. My comment was itself targeted towards a few specific commenters over the past couple days who I wanted to avoid directly singling out.\r\n\r\n> Myself I'd prefer nominal types, if done, to be completely opaque by default, which handles the indexer case, then explicitly to add back in any operations or methods that apply, including relations to other types, which let's you implement your own units as a library. That would be the opposite: nominal types making UOM redundant.\r\n\r\n[I do agree with you that opaque-by-default is ideal for nominal types](https://github.com/microsoft/TypeScript/issues/202#issuecomment-437306455), but I'm not sure they would make for an effective replacement. You *can* of course derive units of measure *from* them, but it'd get boilerplatey in a hurry.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/simonbuchan/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/simonbuchan\">@simonbuchan</a></p>\n<blockquote>\n<p dir=\"auto\">@isiahmeadows essentially I guess the question is over if nominal types (as you describe them) is sufficiently useful to deserve implementation, or if the effort should be saved for doing units of measure fully, especially if it might prevent a worse implementation of the latter. Essentially, if nominal types are needed if we had UOM seems pretty on-topic to me.</p>\n</blockquote>\n<p dir=\"auto\">I was referring to a large segment of discussion that was about the necessity of units of measure and very heavily conflating nominal typing with it. My comment was itself targeted towards a few specific commenters over the past couple days who I wanted to avoid directly singling out.</p>\n<blockquote>\n<p dir=\"auto\">Myself I'd prefer nominal types, if done, to be completely opaque by default, which handles the indexer case, then explicitly to add back in any operations or methods that apply, including relations to other types, which let's you implement your own units as a library. That would be the opposite: nominal types making UOM redundant.</p>\n</blockquote>\n<p dir=\"auto\"><a href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-437306455\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">I do agree with you that opaque-by-default is ideal for nominal types</a>, but I'm not sure they would make for an effective replacement. You <em>can</em> of course derive units of measure <em>from</em> them, but it'd get boilerplatey in a hurry.</p>",
        "createdAt": "2019-05-21T09:47:44Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494321186",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDM0NDgyMw==",
        "author": {
          "login": "iislucas"
        },
        "authorAssociation": "NONE",
        "body": "I've updated my initial example to make it a bit clearer; and changed from `extends` syntax to something more like a type declaration. ",
        "bodyHTML": "<p dir=\"auto\">I've updated my initial example to make it a bit clearer; and changed from <code class=\"notranslate\">extends</code> syntax to something more like a type declaration.</p>",
        "createdAt": "2019-05-21T11:03:45Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494344823",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDM0NzA2OA==",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "So what do you think about `!` syntax suggested above, the notion of `unique type` is semantically close to `not` operator already? I.e. instead of having:\r\n\r\n`string & (unique unknown)` is assignable to string, **but not** never.\r\n`unknown & (unique string)` is assignable to string, **but not** never.\r\n\r\nto have \r\n\r\n`string & !unknown` is assignable to string, **but not** never.\r\n`unknown & !string` is assignable to string, **but not** never.\r\n\r\n`!A & !B` is assignable to `A & B`, but is not equivalent.\r\n\r\n?\r\n",
        "bodyHTML": "<p dir=\"auto\">So what do you think about <code class=\"notranslate\">!</code> syntax suggested above, the notion of <code class=\"notranslate\">unique type</code> is semantically close to <code class=\"notranslate\">not</code> operator already? I.e. instead of having:</p>\n<p dir=\"auto\"><code class=\"notranslate\">string &amp; (unique unknown)</code> is assignable to string, <strong>but not</strong> never.<br>\n<code class=\"notranslate\">unknown &amp; (unique string)</code> is assignable to string, <strong>but not</strong> never.</p>\n<p dir=\"auto\">to have</p>\n<p dir=\"auto\"><code class=\"notranslate\">string &amp; !unknown</code> is assignable to string, <strong>but not</strong> never.<br>\n<code class=\"notranslate\">unknown &amp; !string</code> is assignable to string, <strong>but not</strong> never.</p>\n<p dir=\"auto\"><code class=\"notranslate\">!A &amp; !B</code> is assignable to <code class=\"notranslate\">A &amp; B</code>, but is not equivalent.</p>\n<p dir=\"auto\">?</p>",
        "createdAt": "2019-05-21T11:10:53Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494347068",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDM1MDM5OQ==",
        "author": {
          "login": "MartinJohns"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I think people are focusing too much on the Units of Measurement or syntax aspect, while completely ignoring the more glaring issues (that have been mentioned before):\r\n\r\n- Package `AwesomeDep` declares a nominal type `SuperNominal`\r\n- Package `Foo` depends on `AwesomeDep` version 1.1 and re-exports `SuperNominal`\r\n- Package `Bar` depends on `AwesomeDep` version 1.2 and also re-exports `SuperNominal`\r\n\r\nHow to handle this case? Most likely they are the same, but that is not given. The logical approach would be to declare these two `SuperNominal` types (from `Foo` and from `Bar`) as incompatible, but that could result in a very bad user experience. Assuming they're the same type based on some kind of criteria (e.g. initial declaring package name + minor version) could lead to unwanted bugs as well.",
        "bodyHTML": "<p dir=\"auto\">I think people are focusing too much on the Units of Measurement or syntax aspect, while completely ignoring the more glaring issues (that have been mentioned before):</p>\n<ul dir=\"auto\">\n<li>Package <code class=\"notranslate\">AwesomeDep</code> declares a nominal type <code class=\"notranslate\">SuperNominal</code></li>\n<li>Package <code class=\"notranslate\">Foo</code> depends on <code class=\"notranslate\">AwesomeDep</code> version 1.1 and re-exports <code class=\"notranslate\">SuperNominal</code></li>\n<li>Package <code class=\"notranslate\">Bar</code> depends on <code class=\"notranslate\">AwesomeDep</code> version 1.2 and also re-exports <code class=\"notranslate\">SuperNominal</code></li>\n</ul>\n<p dir=\"auto\">How to handle this case? Most likely they are the same, but that is not given. The logical approach would be to declare these two <code class=\"notranslate\">SuperNominal</code> types (from <code class=\"notranslate\">Foo</code> and from <code class=\"notranslate\">Bar</code>) as incompatible, but that could result in a very bad user experience. Assuming they're the same type based on some kind of criteria (e.g. initial declaring package name + minor version) could lead to unwanted bugs as well.</p>",
        "createdAt": "2019-05-21T11:23:28Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494350399",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDM1NzQwNQ==",
        "author": {
          "login": "iislucas"
        },
        "authorAssociation": "NONE",
        "body": "@MartinJohns : I think that is an issue, and goes far beyond questions of nominal types. It's hard to handle many related versions of the same package that might have shared representations. In fact it's already an common issue (e.g. https://github.com/redux-observable/redux-observable/issues/569). If the types underlying two packages are different, but the two copies have to share objects, then bad things happen. This is already the case when two packages share global variables for example. So I don't quite see how nominals change that problem. Can you elaborate a bit more clearly how you see typescript code referencing the two sub-packages? In the meantime I'll take a guess... \r\n\r\nI think you're suggesting that introducing Nominals would (arguably correctly, but sometimes annoyingly and confusingly) introduce type-errors that would make `Foo` and `Bar` unable to share objects without explicit type conversations. For that, I do think the error messages would want to reference the lines where the type is introduced so that you can tell that `Foo.AwsemeDep.nominal_type_thing` is not the same as `Bar.AwsemeDep.nominal_type_thing`. \r\n\r\nThere are a few ways that types from dependent modules are shared e.g. in Standard ML. If you need to import two packages and force a sharing of names, one might introduce a top-level explicit type sharing statement. The right time to do that might be at import time:  \r\n\r\n```\r\nimport * as foo from 'foo';\r\nimport * as bar from 'bar';\r\nsharing foo.nominal_type_thing as bar.nominal_type_thing;\r\n```",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/MartinJohns/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/MartinJohns\">@MartinJohns</a> : I think that is an issue, and goes far beyond questions of nominal types. It's hard to handle many related versions of the same package that might have shared representations. In fact it's already an common issue (e.g. <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"355992908\" data-permission-text=\"Title is private\" data-url=\"https://github.com/redux-observable/redux-observable/issues/569\" data-hovercard-type=\"issue\" data-hovercard-url=\"/redux-observable/redux-observable/issues/569/hovercard\" href=\"https://github.com/redux-observable/redux-observable/issues/569\">redux-observable/redux-observable#569</a>). If the types underlying two packages are different, but the two copies have to share objects, then bad things happen. This is already the case when two packages share global variables for example. So I don't quite see how nominals change that problem. Can you elaborate a bit more clearly how you see typescript code referencing the two sub-packages? In the meantime I'll take a guess...</p>\n<p dir=\"auto\">I think you're suggesting that introducing Nominals would (arguably correctly, but sometimes annoyingly and confusingly) introduce type-errors that would make <code class=\"notranslate\">Foo</code> and <code class=\"notranslate\">Bar</code> unable to share objects without explicit type conversations. For that, I do think the error messages would want to reference the lines where the type is introduced so that you can tell that <code class=\"notranslate\">Foo.AwsemeDep.nominal_type_thing</code> is not the same as <code class=\"notranslate\">Bar.AwsemeDep.nominal_type_thing</code>.</p>\n<p dir=\"auto\">There are a few ways that types from dependent modules are shared e.g. in Standard ML. If you need to import two packages and force a sharing of names, one might introduce a top-level explicit type sharing statement. The right time to do that might be at import time:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"import * as foo from 'foo';\nimport * as bar from 'bar';\nsharing foo.nominal_type_thing as bar.nominal_type_thing;\"><pre class=\"notranslate\"><code class=\"notranslate\">import * as foo from 'foo';\nimport * as bar from 'bar';\nsharing foo.nominal_type_thing as bar.nominal_type_thing;\n</code></pre></div>",
        "createdAt": "2019-05-21T11:48:27Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494357405",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDM1ODEyNQ==",
        "author": {
          "login": "iislucas"
        },
        "authorAssociation": "NONE",
        "body": "@lu4: I worry that ! is already used in typescript for ignoring undefined. But the context looks quite different so maybe its ok. I guess I think that `nominal` or `unique` will not be used so often that it deserves a one character abbreviation. Thoughts? ",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lu4/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lu4\">@lu4</a>: I worry that ! is already used in typescript for ignoring undefined. But the context looks quite different so maybe its ok. I guess I think that <code class=\"notranslate\">nominal</code> or <code class=\"notranslate\">unique</code> will not be used so often that it deserves a one character abbreviation. Thoughts?</p>",
        "createdAt": "2019-05-21T11:50:48Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494358125",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDM2NDU2Nw==",
        "author": {
          "login": "zpdDG4gta8XKpMCd"
        },
        "authorAssociation": "NONE",
        "body": "@MartinJohns versioning of nominals was discussed extensively like 2 month ago in this very thread, you can dig it up easily",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/MartinJohns/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/MartinJohns\">@MartinJohns</a> versioning of nominals was discussed extensively like 2 month ago in this very thread, you can dig it up easily</p>",
        "createdAt": "2019-05-21T12:11:24Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494364567",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDM4NjAyNw==",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "@MartinJohns well, even though the example seems unhealthy but the concern seems valid. From what I see one way to handle the case is:\r\n\r\n```typescript\r\nexport type SuperNominal<T> = version1.SuperNominal<T> | version2.SuperNominal<T>;\r\n```",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/MartinJohns/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/MartinJohns\">@MartinJohns</a> well, even though the example seems unhealthy but the concern seems valid. From what I see one way to handle the case is:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"export type SuperNominal&lt;T&gt; = version1.SuperNominal&lt;T&gt; | version2.SuperNominal&lt;T&gt;;\"><pre class=\"notranslate\"><span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">SuperNominal</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">version1</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">SuperNominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-c1\">|</span> <span class=\"pl-s1\">version2</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">SuperNominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span></pre></div>",
        "createdAt": "2019-05-21T13:15:33Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494386027",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDM4ODUzOQ==",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "@iislucas I hear you, one more food for thought is `unique unique type` yields to `unique type`?",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/iislucas/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/iislucas\">@iislucas</a> I hear you, one more food for thought is <code class=\"notranslate\">unique unique type</code> yields to <code class=\"notranslate\">unique type</code>?</p>",
        "createdAt": "2019-05-21T13:22:14Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494388539",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDQxMTg3OQ==",
        "author": {
          "login": "iislucas"
        },
        "authorAssociation": "NONE",
        "body": "@lu4 hrm... good question... I think so, but that might also be an argument for treating nominal declarations more like the `interface` or `type` keyword like I did in my original post, and that way you don't have to worry about interaction in type expressions.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lu4/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lu4\">@lu4</a> hrm... good question... I think so, but that might also be an argument for treating nominal declarations more like the <code class=\"notranslate\">interface</code> or <code class=\"notranslate\">type</code> keyword like I did in my original post, and that way you don't have to worry about interaction in type expressions.</p>",
        "createdAt": "2019-05-21T14:19:53Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494411879",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NDU2MTk0Mw==",
        "author": null,
        "authorAssociation": "NONE",
        "body": "@lu4\r\n> Also does this As<...> syntax supports name spacing? Because otherwise it seems that we can fall into conflict between strings and loose compiler support for such nominals...\r\n\r\nFeel free to use a urn for your brand tag.\r\n\r\n@martinjohns \r\n...possibly including a version number or UUID.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lu4/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lu4\">@lu4</a></p>\n<blockquote>\n<p dir=\"auto\">Also does this As&lt;...&gt; syntax supports name spacing? Because otherwise it seems that we can fall into conflict between strings and loose compiler support for such nominals...</p>\n</blockquote>\n<p dir=\"auto\">Feel free to use a urn for your brand tag.</p>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/MartinJohns/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/MartinJohns\">@MartinJohns</a><br>\n...possibly including a version number or UUID.</p>",
        "createdAt": "2019-05-21T21:16:42Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-494561943",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5ODIwMTMzNQ==",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "FWIW this is the final version I ended up with:\r\n\r\nedit: fixed to take care of typescript restrictions on private fields in definition files: https://github.com/spion/branded-types\r\n\r\n```typescript\r\nexport type Branded<T, Brand> = {\r\n  new (): {\r\n    \"  value\": any\r\n    \"  kind\": Brand\r\n  }\r\n  brand<Cls extends Branded<T, Brand>>(this: Cls, t: T): InstanceType<Cls>\r\n  unbrand<Cls extends Branded<T, Brand>>(this: Cls, b: InstanceType<Cls>): T\r\n}\r\n\r\nexport function Branded<T, Brand>() {\r\n  return class Type {\r\n    constructor() { throw new TypeError('Cannot instantiate branded types'); }\r\n    \"  value\": Type\r\n    \"  kind\": Brand\r\n    static brand<Cls extends typeof Type>(this: Cls, t: T) {\r\n      return (t as any) as InstanceType<Cls>\r\n    }\r\n    static unbrand<Cls extends typeof Type>(this: Cls, b: InstanceType<Cls>) {\r\n      return (b as any) as T\r\n    }\r\n    static Type: Type\r\n  } as Branded<T, Brand>\r\n}\r\n```\r\n\r\nUsage example:\r\n\r\n```typescript\r\nclass OrderId extends Branded<string, 'mypkgname.OrderId'>() {}\r\n\r\nlet x = OrderId.brand('someUuid')\r\nlet y = 'someString';\r\nlet b1 = y == x;\r\nlet b2 = y == OrderId.unbrand(x)\r\n\r\nlet m: Map<OrderId, string> = new Map;\r\n\r\nm.set(y, '1')\r\nm.set(x, '2')\r\n```\r\n\r\n* Not nominal, so packages in different places in the filesystem still compatible\r\n* Nice error messages e.g. the equality comparison has\r\n  ```\r\n  This condition will always return 'false' since \r\n  the types 'string' and 'OrderId' have no overlap.\r\n  ```\r\n  and the map insertion has the error:\r\n  ```\r\n  Argument of type 'string' is not assignable to parameter of type 'OrderId'.\r\n  ```\r\n* No runtime overhead. Despite all the class machinery, the converted values have NO runtime representation. The conversion functions do nothing except return the same value. The machinery is there only for the nice errors and API.\r\n* No built-in string/number operators allowed. If for example you try to concat two OrderIds with `+`, it's not going to work. You have to use an explicit cast to the source type via e.g. `String(brandedVal)` or `Number(brandedVal)` etc, then perform the operation",
        "bodyHTML": "<p dir=\"auto\">FWIW this is the final version I ended up with:</p>\n<p dir=\"auto\">edit: fixed to take care of typescript restrictions on private fields in definition files: <a href=\"https://github.com/spion/branded-types\">https://github.com/spion/branded-types</a></p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"export type Branded&lt;T, Brand&gt; = {\n  new (): {\n    &quot;  value&quot;: any\n    &quot;  kind&quot;: Brand\n  }\n  brand&lt;Cls extends Branded&lt;T, Brand&gt;&gt;(this: Cls, t: T): InstanceType&lt;Cls&gt;\n  unbrand&lt;Cls extends Branded&lt;T, Brand&gt;&gt;(this: Cls, b: InstanceType&lt;Cls&gt;): T\n}\n\nexport function Branded&lt;T, Brand&gt;() {\n  return class Type {\n    constructor() { throw new TypeError('Cannot instantiate branded types'); }\n    &quot;  value&quot;: Type\n    &quot;  kind&quot;: Brand\n    static brand&lt;Cls extends typeof Type&gt;(this: Cls, t: T) {\n      return (t as any) as InstanceType&lt;Cls&gt;\n    }\n    static unbrand&lt;Cls extends typeof Type&gt;(this: Cls, b: InstanceType&lt;Cls&gt;) {\n      return (b as any) as T\n    }\n    static Type: Type\n  } as Branded&lt;T, Brand&gt;\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Branded</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">new</span> <span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>: <span class=\"pl-kos\">{</span>\n    <span class=\"pl-s\">\"  value\"</span>: <span class=\"pl-smi\">any</span>\n    <span class=\"pl-s\">\"  kind\"</span>: <span class=\"pl-smi\">Brand</span>\n  <span class=\"pl-kos\">}</span>\n  <span class=\"pl-c1\">brand</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">Cls</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Branded</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-c1\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">this</span>: <span class=\"pl-smi\">Cls</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">t</span>: <span class=\"pl-smi\">T</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">InstanceType</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Cls</span><span class=\"pl-kos\">&gt;</span>\n  <span class=\"pl-c1\">unbrand</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">Cls</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Branded</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-c1\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">this</span>: <span class=\"pl-smi\">Cls</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">b</span>: <span class=\"pl-smi\">InstanceType</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Cls</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">T</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">function</span> <span class=\"pl-smi\">Branded</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-c1\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">return</span> <span class=\"pl-k\">class</span> <span class=\"pl-smi\">Type</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-en\">constructor</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">TypeError</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'Cannot instantiate branded types'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-kos\">}</span>\n    <span class=\"pl-s\">\"  value\"</span>: <span class=\"pl-smi\">Type</span>\n    <span class=\"pl-s\">\"  kind\"</span>: <span class=\"pl-smi\">Brand</span>\n    <span class=\"pl-k\">static</span> <span class=\"pl-en\">brand</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">Cls</span> <span class=\"pl-k\">extends</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Type</span><span class=\"pl-c1\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">this</span>: <span class=\"pl-smi\">Cls</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">t</span>: <span class=\"pl-smi\">T</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n      <span class=\"pl-k\">return</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">t</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">any</span><span class=\"pl-kos\">)</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">InstanceType</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Cls</span><span class=\"pl-kos\">&gt;</span>\n    <span class=\"pl-kos\">}</span>\n    <span class=\"pl-k\">static</span> <span class=\"pl-en\">unbrand</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">Cls</span> <span class=\"pl-k\">extends</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Type</span><span class=\"pl-c1\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-smi\">this</span>: <span class=\"pl-smi\">Cls</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">b</span>: <span class=\"pl-smi\">InstanceType</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">Cls</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n      <span class=\"pl-k\">return</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">b</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">any</span><span class=\"pl-kos\">)</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">T</span>\n    <span class=\"pl-kos\">}</span>\n    <span class=\"pl-k\">static</span> <span class=\"pl-c1\">Type</span>: <span class=\"pl-smi\">Type</span>\n  <span class=\"pl-kos\">}</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Branded</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">Brand</span><span class=\"pl-kos\">&gt;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">Usage example:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"class OrderId extends Branded&lt;string, 'mypkgname.OrderId'&gt;() {}\n\nlet x = OrderId.brand('someUuid')\nlet y = 'someString';\nlet b1 = y == x;\nlet b2 = y == OrderId.unbrand(x)\n\nlet m: Map&lt;OrderId, string&gt; = new Map;\n\nm.set(y, '1')\nm.set(x, '2')\"><pre class=\"notranslate\"><span class=\"pl-k\">class</span> <span class=\"pl-smi\">OrderId</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Branded</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'mypkgname.OrderId'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">OrderId</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">brand</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'someUuid'</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">y</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'someString'</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">b1</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">y</span> <span class=\"pl-c1\">==</span> <span class=\"pl-s1\">x</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">b2</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">y</span> <span class=\"pl-c1\">==</span> <span class=\"pl-smi\">OrderId</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">unbrand</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span><span class=\"pl-kos\">)</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">m</span>: <span class=\"pl-smi\">Map</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">OrderId</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">string</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Map</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-s1\">m</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">set</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">y</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'1'</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-s1\">m</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">set</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'2'</span><span class=\"pl-kos\">)</span></pre></div>\n<ul dir=\"auto\">\n<li>Not nominal, so packages in different places in the filesystem still compatible</li>\n<li>Nice error messages e.g. the equality comparison has\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"This condition will always return 'false' since \nthe types 'string' and 'OrderId' have no overlap.\"><pre class=\"notranslate\"><code class=\"notranslate\">This condition will always return 'false' since \nthe types 'string' and 'OrderId' have no overlap.\n</code></pre></div>\nand the map insertion has the error:\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Argument of type 'string' is not assignable to parameter of type 'OrderId'.\"><pre class=\"notranslate\"><code class=\"notranslate\">Argument of type 'string' is not assignable to parameter of type 'OrderId'.\n</code></pre></div>\n</li>\n<li>No runtime overhead. Despite all the class machinery, the converted values have NO runtime representation. The conversion functions do nothing except return the same value. The machinery is there only for the nice errors and API.</li>\n<li>No built-in string/number operators allowed. If for example you try to concat two OrderIds with <code class=\"notranslate\">+</code>, it's not going to work. You have to use an explicit cast to the source type via e.g. <code class=\"notranslate\">String(brandedVal)</code> or <code class=\"notranslate\">Number(brandedVal)</code> etc, then perform the operation</li>\n</ul>",
        "createdAt": "2019-06-03T10:24:17Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-498201335",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 8
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5ODIwNTA0MA==",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "Here's my real-world use case based on discussion above:\r\n\r\n```typescript\r\nexport type OpenOrder = OpenOrderExternalDependency & { readonly $discriminator: unique symbol };\r\nexport type OpenOrderIdOf<T> = T & { readonly $discriminator: unique symbol };\r\n\r\nexport type MarketPrice<T> = T & { readonly $discriminator: unique symbol };\r\n\r\nexport type PositionIdOf<T> = T & { readonly $discriminator: unique symbol };\r\nexport type PositionSymbolOf<T> = T & { readonly $discriminator: unique symbol };\r\nexport type PositionProfitAccured<T> = T & { readonly $discriminator: unique symbol };\r\nexport type PositionProfitCurrent<T> = T & { readonly $discriminator: unique symbol };\r\n\r\nexport type SellSidePrice<T> = T & { readonly $discriminator: unique symbol };\r\nexport type SellSideQuantity<T> = T & { readonly $discriminator: unique symbol };\r\nexport type SellSideStopPrice<T> = T & { readonly $discriminator: unique symbol };\r\nexport type SellSideLimitPrice<T> = T & { readonly $discriminator: unique symbol };\r\n\r\nexport type BuySidePrice<T> = T & { readonly $discriminator: unique symbol };\r\nexport type BuySideQuantity<T> = T & { readonly $discriminator: unique symbol };\r\nexport type BuySideStopPrice<T> = T & { readonly $discriminator: unique symbol };\r\nexport type BuySideLimitPrice<T> = T & { readonly $discriminator: unique symbol };\r\n\r\nexport interface BuySide {\r\n    id: PositionIdOf<string>;\r\n\r\n    side: 'BUY';\r\n\r\n    symbol: PositionSymbolOf<string>;\r\n\r\n    price: BuySidePrice<number>;\r\n    marketPrice: MarketPrice<number>;\r\n    \r\n    profitAccured: PositionProfitAccured<number>;\r\n    profitCurrent: PositionProfitCurrent<number>;\r\n\r\n    stop: BuySideStopPrice<number>;\r\n    limit?: BuySideLimitPrice<number>;\r\n\r\n    createdTime: number;\r\n    changedTime: number;\r\n}\r\n\r\nexport interface SellSide {\r\n    id: PositionIdOf<string>;\r\n\r\n    side: 'SELL';\r\n\r\n    symbol: PositionSymbolOf<string>;\r\n\r\n    price: SellSidePrice<number>;\r\n    marketPrice: MarketPrice<number>;\r\n\r\n    profitAccured: PositionProfitAccured<number>;\r\n    profitCurrent: PositionProfitCurrent<number>;\r\n\r\n    stop: SellSideStopPrice<number>;\r\n    limit?: SellSideLimitPrice<number>;\r\n\r\n    createdTime: number;\r\n    changedTime: number;\r\n}\r\n\r\nexport type Position = BuySide | SellSide;\r\n```\r\nAs you note I distinguish the `price` and other fields by Type, it helps to make sure to conduct all possible checks before assigning the value into the field which protects everyone who uses the type from incidental values being put into field. Also we get nice type inference through typescript typeguard on `side` field. Also the syntax serves as a `label for developer` helping to distinguish different kinds of numbers. After using this approach for a little while it feels like using raw atomic types without nominal label is somehow similar to crating magic constants in code and not assigning them into variable. I was walking across one piece of code I've written several months ago (without nominal types, just raw `number`'s), and it took me quite a significant deal of time to figure out how to actually use them, I needed to do some deeper dive into code to figure out what they mean.\r\n\r\nSo nominal types make you even more lazy 😆 and you would not like your previous code after using them for a while...\r\n\r\nAnd lastly this syntax allows for implicit graceful down-cast. I.e. you can perform any mathematical operation on two distinct nominal numbers but the result would down-cast into ordinary number which would be blocked in attempt to assign the value into field protected by nominal type, which I think is super great...\r\n\r\nThis approach had saved me at least a dozen gray hairs already with the errors I was able to detect at compile time. Plus I'm ok with the way it looks already to use it in real project, thanks everyone to point out the syntax...",
        "bodyHTML": "<p dir=\"auto\">Here's my real-world use case based on discussion above:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"export type OpenOrder = OpenOrderExternalDependency &amp; { readonly $discriminator: unique symbol };\nexport type OpenOrderIdOf&lt;T&gt; = T &amp; { readonly $discriminator: unique symbol };\n\nexport type MarketPrice&lt;T&gt; = T &amp; { readonly $discriminator: unique symbol };\n\nexport type PositionIdOf&lt;T&gt; = T &amp; { readonly $discriminator: unique symbol };\nexport type PositionSymbolOf&lt;T&gt; = T &amp; { readonly $discriminator: unique symbol };\nexport type PositionProfitAccured&lt;T&gt; = T &amp; { readonly $discriminator: unique symbol };\nexport type PositionProfitCurrent&lt;T&gt; = T &amp; { readonly $discriminator: unique symbol };\n\nexport type SellSidePrice&lt;T&gt; = T &amp; { readonly $discriminator: unique symbol };\nexport type SellSideQuantity&lt;T&gt; = T &amp; { readonly $discriminator: unique symbol };\nexport type SellSideStopPrice&lt;T&gt; = T &amp; { readonly $discriminator: unique symbol };\nexport type SellSideLimitPrice&lt;T&gt; = T &amp; { readonly $discriminator: unique symbol };\n\nexport type BuySidePrice&lt;T&gt; = T &amp; { readonly $discriminator: unique symbol };\nexport type BuySideQuantity&lt;T&gt; = T &amp; { readonly $discriminator: unique symbol };\nexport type BuySideStopPrice&lt;T&gt; = T &amp; { readonly $discriminator: unique symbol };\nexport type BuySideLimitPrice&lt;T&gt; = T &amp; { readonly $discriminator: unique symbol };\n\nexport interface BuySide {\n    id: PositionIdOf&lt;string&gt;;\n\n    side: 'BUY';\n\n    symbol: PositionSymbolOf&lt;string&gt;;\n\n    price: BuySidePrice&lt;number&gt;;\n    marketPrice: MarketPrice&lt;number&gt;;\n    \n    profitAccured: PositionProfitAccured&lt;number&gt;;\n    profitCurrent: PositionProfitCurrent&lt;number&gt;;\n\n    stop: BuySideStopPrice&lt;number&gt;;\n    limit?: BuySideLimitPrice&lt;number&gt;;\n\n    createdTime: number;\n    changedTime: number;\n}\n\nexport interface SellSide {\n    id: PositionIdOf&lt;string&gt;;\n\n    side: 'SELL';\n\n    symbol: PositionSymbolOf&lt;string&gt;;\n\n    price: SellSidePrice&lt;number&gt;;\n    marketPrice: MarketPrice&lt;number&gt;;\n\n    profitAccured: PositionProfitAccured&lt;number&gt;;\n    profitCurrent: PositionProfitCurrent&lt;number&gt;;\n\n    stop: SellSideStopPrice&lt;number&gt;;\n    limit?: SellSideLimitPrice&lt;number&gt;;\n\n    createdTime: number;\n    changedTime: number;\n}\n\nexport type Position = BuySide | SellSide;\"><pre class=\"notranslate\"><span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">OpenOrder</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">OpenOrderExternalDependency</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">$discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">OpenOrderIdOf</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">$discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">MarketPrice</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">$discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">PositionIdOf</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">$discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">PositionSymbolOf</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">$discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">PositionProfitAccured</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">$discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">PositionProfitCurrent</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">$discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">SellSidePrice</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">$discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">SellSideQuantity</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">$discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">SellSideStopPrice</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">$discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">SellSideLimitPrice</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">$discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">BuySidePrice</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">$discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">BuySideQuantity</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">$discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">BuySideStopPrice</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">$discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">BuySideLimitPrice</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">$discriminator</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">BuySide</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">id</span>: <span class=\"pl-smi\">PositionIdOf</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n    <span class=\"pl-c1\">side</span>: <span class=\"pl-s\">'BUY'</span><span class=\"pl-kos\">;</span>\n\n    <span class=\"pl-c1\">symbol</span>: <span class=\"pl-smi\">PositionSymbolOf</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n    <span class=\"pl-c1\">price</span>: <span class=\"pl-smi\">BuySidePrice</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-c1\">marketPrice</span>: <span class=\"pl-smi\">MarketPrice</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n    \n    <span class=\"pl-c1\">profitAccured</span>: <span class=\"pl-smi\">PositionProfitAccured</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-c1\">profitCurrent</span>: <span class=\"pl-smi\">PositionProfitCurrent</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n    <span class=\"pl-c1\">stop</span>: <span class=\"pl-smi\">BuySideStopPrice</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-c1\">limit</span>?: <span class=\"pl-smi\">BuySideLimitPrice</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n    <span class=\"pl-c1\">createdTime</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-c1\">changedTime</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">SellSide</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c1\">id</span>: <span class=\"pl-smi\">PositionIdOf</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n    <span class=\"pl-c1\">side</span>: <span class=\"pl-s\">'SELL'</span><span class=\"pl-kos\">;</span>\n\n    <span class=\"pl-c1\">symbol</span>: <span class=\"pl-smi\">PositionSymbolOf</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n    <span class=\"pl-c1\">price</span>: <span class=\"pl-smi\">SellSidePrice</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-c1\">marketPrice</span>: <span class=\"pl-smi\">MarketPrice</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n    <span class=\"pl-c1\">profitAccured</span>: <span class=\"pl-smi\">PositionProfitAccured</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-c1\">profitCurrent</span>: <span class=\"pl-smi\">PositionProfitCurrent</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n    <span class=\"pl-c1\">stop</span>: <span class=\"pl-smi\">SellSideStopPrice</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-c1\">limit</span>?: <span class=\"pl-smi\">SellSideLimitPrice</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n    <span class=\"pl-c1\">createdTime</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-c1\">changedTime</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Position</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">BuySide</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">SellSide</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">As you note I distinguish the <code class=\"notranslate\">price</code> and other fields by Type, it helps to make sure to conduct all possible checks before assigning the value into the field which protects everyone who uses the type from incidental values being put into field. Also we get nice type inference through typescript typeguard on <code class=\"notranslate\">side</code> field. Also the syntax serves as a <code class=\"notranslate\">label for developer</code> helping to distinguish different kinds of numbers. After using this approach for a little while it feels like using raw atomic types without nominal label is somehow similar to crating magic constants in code and not assigning them into variable. I was walking across one piece of code I've written several months ago (without nominal types, just raw <code class=\"notranslate\">number</code>'s), and it took me quite a significant deal of time to figure out how to actually use them, I needed to do some deeper dive into code to figure out what they mean.</p>\n<p dir=\"auto\">So nominal types make you even more lazy 😆 and you would not like your previous code after using them for a while...</p>\n<p dir=\"auto\">And lastly this syntax allows for implicit graceful down-cast. I.e. you can perform any mathematical operation on two distinct nominal numbers but the result would down-cast into ordinary number which would be blocked in attempt to assign the value into field protected by nominal type, which I think is super great...</p>\n<p dir=\"auto\">This approach had saved me at least a dozen gray hairs already with the errors I was able to detect at compile time. Plus I'm ok with the way it looks already to use it in real project, thanks everyone to point out the syntax...</p>",
        "createdAt": "2019-06-03T10:37:22Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-498205040",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 16
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDQ5ODM1OTQ5Mw==",
        "author": {
          "login": "iislucas"
        },
        "authorAssociation": "NONE",
        "body": "@spion that looks really good to me. Nice! ",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/spion/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/spion\">@spion</a> that looks really good to me. Nice!</p>",
        "createdAt": "2019-06-03T17:52:42Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-498359493",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUxMTA4ODI3OQ==",
        "author": {
          "login": "xiaoxiangmoe"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "this is my code gen function:\r\n\r\nhttps://gist.github.com/xiaoxiangmoe/bf5294336f15d0d040db20b178f5a2c8\r\n\r\n```ts\r\nnamespace _opaque{declare const opaque_key_0:unique symbol;export interface t0{[opaque_key_0]:0};declare const opaque_key_1:unique symbol;export interface t1{[opaque_key_1]:0}} /* prettier-ignore */ // tslint:disable-line\r\n\r\nexport interface ID extends _opaque.t0 {}\r\n\r\nexport interface ID1 extends _opaque.t1 {}\r\n\r\nexport namespace ID {\r\n  // @ts-ignore\r\n  export function fromString(id: string): ID;\r\n  export function fromString(id: string) {\r\n    return id;\r\n  }\r\n\r\n  // @ts-ignore\r\n  export function toString(id: ID): string;\r\n  export function toString(id: string) {\r\n    return id;\r\n  }\r\n\r\n\r\n  // @ts-ignore\r\n  export function compare(a: ID, b: ID): -1 | 0 | 1;\r\n  export function compare(a: string, b: string) {\r\n    return a.localeCompare(b);\r\n  }\r\n\r\n  export function equal(a: ID, b: ID) {\r\n    return a === b;\r\n  }\r\n}\r\n\r\n\r\ndeclare let id0: ID;\r\ndeclare let id1: ID1;\r\n\r\nid0 = id1; // Error: Property '[opaque_key_0]' is missing in type 'ID1' but required in type 'ID'.\r\n\r\n```\r\n",
        "bodyHTML": "<p dir=\"auto\">this is my code gen function:</p>\n<p dir=\"auto\"><a href=\"https://gist.github.com/xiaoxiangmoe/bf5294336f15d0d040db20b178f5a2c8\">https://gist.github.com/xiaoxiangmoe/bf5294336f15d0d040db20b178f5a2c8</a></p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"namespace _opaque{declare const opaque_key_0:unique symbol;export interface t0{[opaque_key_0]:0};declare const opaque_key_1:unique symbol;export interface t1{[opaque_key_1]:0}} /* prettier-ignore */ // tslint:disable-line\n\nexport interface ID extends _opaque.t0 {}\n\nexport interface ID1 extends _opaque.t1 {}\n\nexport namespace ID {\n  // @ts-ignore\n  export function fromString(id: string): ID;\n  export function fromString(id: string) {\n    return id;\n  }\n\n  // @ts-ignore\n  export function toString(id: ID): string;\n  export function toString(id: string) {\n    return id;\n  }\n\n\n  // @ts-ignore\n  export function compare(a: ID, b: ID): -1 | 0 | 1;\n  export function compare(a: string, b: string) {\n    return a.localeCompare(b);\n  }\n\n  export function equal(a: ID, b: ID) {\n    return a === b;\n  }\n}\n\n\ndeclare let id0: ID;\ndeclare let id1: ID1;\n\nid0 = id1; // Error: Property '[opaque_key_0]' is missing in type 'ID1' but required in type 'ID'.\n\"><pre class=\"notranslate\"><span class=\"pl-k\">namespace</span> <span class=\"pl-s1\">_opaque</span><span class=\"pl-kos\">{</span><span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">opaque_key_0</span>:<span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">;</span><span class=\"pl-k\">export</span> <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">t0</span><span class=\"pl-kos\">{</span><span class=\"pl-kos\">[</span><span class=\"pl-s1\">opaque_key_0</span><span class=\"pl-kos\">]</span>:<span class=\"pl-c1\">0</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span><span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">opaque_key_1</span>:<span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">;</span><span class=\"pl-k\">export</span> <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">t1</span><span class=\"pl-kos\">{</span><span class=\"pl-kos\">[</span><span class=\"pl-s1\">opaque_key_1</span><span class=\"pl-kos\">]</span>:<span class=\"pl-c1\">0</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">}</span> <span class=\"pl-c\">/* prettier-ignore */</span> <span class=\"pl-c\">// tslint:disable-line</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">ID</span> <span class=\"pl-k\">extends</span> <span class=\"pl-s1\">_opaque</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">t0</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">interface</span> <span class=\"pl-smi\">ID1</span> <span class=\"pl-k\">extends</span> <span class=\"pl-s1\">_opaque</span><span class=\"pl-kos\">.</span><span class=\"pl-smi\">t1</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">namespace</span> <span class=\"pl-smi\">ID</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c\">// <span class=\"pl-k\">@ts</span>-ignore</span>\n  <span class=\"pl-k\">export</span> <span class=\"pl-k\">function</span> <span class=\"pl-s1\">fromString</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">id</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">ID</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-k\">export</span> <span class=\"pl-k\">function</span> <span class=\"pl-en\">fromString</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">id</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-s1\">id</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-kos\">}</span>\n\n  <span class=\"pl-c\">// <span class=\"pl-k\">@ts</span>-ignore</span>\n  <span class=\"pl-k\">export</span> <span class=\"pl-k\">function</span> <span class=\"pl-s1\">toString</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">id</span>: <span class=\"pl-smi\">ID</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-k\">export</span> <span class=\"pl-k\">function</span> <span class=\"pl-en\">toString</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">id</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-s1\">id</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-kos\">}</span>\n\n\n  <span class=\"pl-c\">// <span class=\"pl-k\">@ts</span>-ignore</span>\n  <span class=\"pl-k\">export</span> <span class=\"pl-k\">function</span> <span class=\"pl-s1\">compare</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">a</span>: <span class=\"pl-smi\">ID</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">b</span>: <span class=\"pl-smi\">ID</span><span class=\"pl-kos\">)</span>: <span class=\"pl-c1\">-</span><span class=\"pl-c1\">1</span> <span class=\"pl-c1\">|</span> <span class=\"pl-c1\">0</span> <span class=\"pl-c1\">|</span> <span class=\"pl-c1\">1</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-k\">export</span> <span class=\"pl-k\">function</span> <span class=\"pl-en\">compare</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">a</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">b</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-s1\">a</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">localeCompare</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">b</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-kos\">}</span>\n\n  <span class=\"pl-k\">export</span> <span class=\"pl-k\">function</span> <span class=\"pl-en\">equal</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">a</span>: <span class=\"pl-smi\">ID</span><span class=\"pl-kos\">,</span> <span class=\"pl-s1\">b</span>: <span class=\"pl-smi\">ID</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-s1\">a</span> <span class=\"pl-c1\">===</span> <span class=\"pl-s1\">b</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span>\n\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">let</span> <span class=\"pl-s1\">id0</span>: <span class=\"pl-smi\">ID</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">let</span> <span class=\"pl-s1\">id1</span>: <span class=\"pl-smi\">ID1</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-s1\">id0</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">id1</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// Error: Property '[opaque_key_0]' is missing in type 'ID1' but required in type 'ID'.</span></pre></div>",
        "createdAt": "2019-07-13T04:46:08Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-511088279",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "UnlabeledEvent",
        "createdAt": "2019-08-23T21:40:55Z",
        "actor": {
          "login": "RyanCavanaugh"
        },
        "label": {
          "id": "MDU6TGFiZWwxMTQyMDE4MzM=",
          "name": "Needs Proposal",
          "color": "556b75"
        }
      },
      {
        "__typename": "LabeledEvent",
        "createdAt": "2019-08-23T21:40:55Z",
        "actor": {
          "login": "RyanCavanaugh"
        },
        "label": {
          "id": "MDU6TGFiZWwxMTc2MzA1NjA=",
          "name": "In Discussion",
          "color": "556b75"
        }
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUyNzU1NjU1Mg==",
        "author": {
          "login": "artalar"
        },
        "authorAssociation": "NONE",
        "body": "Awesome! It will so helpful for refinement types in https://github.com/rtcad/rtcad/blob/master/src/__tests__/index.ts",
        "bodyHTML": "<p dir=\"auto\">Awesome! It will so helpful for refinement types in <a href=\"https://github.com/rtcad/rtcad/blob/master/src/__tests__/index.ts\">https://github.com/rtcad/rtcad/blob/master/src/__tests__/index.ts</a></p>",
        "createdAt": "2019-09-03T17:23:29Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-527556552",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDUzNjMzNDc2Nw==",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "Ok, I've came to another way to declare a nominal type, it allows somewhat little more comfortable declaration, though two declarations per type are necessary:\r\n\r\n```\r\nexport type Unique<T> = T & { readonly '': unique symbol };\r\n\r\nexport enum DbProto { }\r\nexport type DbContext = Unique<DbProto>;\r\n\r\nexport enum BatchProto { }\r\nexport type BatchContext = Unique<BatchProto>;\r\n```\r\n\r\nUse cases:\r\n\r\n```\r\nenum EnumType { }\r\n\r\nvar x: EnumType = 1; // Not fails => not typesafe\r\nvar y: Unique<EnumType> = 1; // Fails => typesafe\r\nvar z: Unique<EnumType> = 1 as Unique<EnumType>; // More or less ok since the user has provided the proof that he knows what he is doing\r\ny = z; // Ok, typesafe\r\ny = y + z; // Fails, typesafe\r\ny += 1; // Fails, typesafe\r\ny += z; // Fails, typesafe\r\n\r\nHowever:\r\ny++; // Not fails => not typesafe!\r\n```\r\n\r\nAlso it is possible to declare only the `EnumType` and use `Unique<EnumType>` everywhere, like so:\r\n\r\n```\r\nexport type Unique<T> = T & { readonly '': unique symbol };\r\n\r\nexport enum DbProto { }\r\nexport enum BatchProto { }\r\n\r\nvar x: Unique<DbProto> = 1 as Unique<DbProto>\r\n\r\n```\r\n",
        "bodyHTML": "<p dir=\"auto\">Ok, I've came to another way to declare a nominal type, it allows somewhat little more comfortable declaration, though two declarations per type are necessary:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"export type Unique&lt;T&gt; = T &amp; { readonly '': unique symbol };\n\nexport enum DbProto { }\nexport type DbContext = Unique&lt;DbProto&gt;;\n\nexport enum BatchProto { }\nexport type BatchContext = Unique&lt;BatchProto&gt;;\"><pre class=\"notranslate\"><code class=\"notranslate\">export type Unique&lt;T&gt; = T &amp; { readonly '': unique symbol };\n\nexport enum DbProto { }\nexport type DbContext = Unique&lt;DbProto&gt;;\n\nexport enum BatchProto { }\nexport type BatchContext = Unique&lt;BatchProto&gt;;\n</code></pre></div>\n<p dir=\"auto\">Use cases:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"enum EnumType { }\n\nvar x: EnumType = 1; // Not fails =&gt; not typesafe\nvar y: Unique&lt;EnumType&gt; = 1; // Fails =&gt; typesafe\nvar z: Unique&lt;EnumType&gt; = 1 as Unique&lt;EnumType&gt;; // More or less ok since the user has provided the proof that he knows what he is doing\ny = z; // Ok, typesafe\ny = y + z; // Fails, typesafe\ny += 1; // Fails, typesafe\ny += z; // Fails, typesafe\n\nHowever:\ny++; // Not fails =&gt; not typesafe!\"><pre class=\"notranslate\"><code class=\"notranslate\">enum EnumType { }\n\nvar x: EnumType = 1; // Not fails =&gt; not typesafe\nvar y: Unique&lt;EnumType&gt; = 1; // Fails =&gt; typesafe\nvar z: Unique&lt;EnumType&gt; = 1 as Unique&lt;EnumType&gt;; // More or less ok since the user has provided the proof that he knows what he is doing\ny = z; // Ok, typesafe\ny = y + z; // Fails, typesafe\ny += 1; // Fails, typesafe\ny += z; // Fails, typesafe\n\nHowever:\ny++; // Not fails =&gt; not typesafe!\n</code></pre></div>\n<p dir=\"auto\">Also it is possible to declare only the <code class=\"notranslate\">EnumType</code> and use <code class=\"notranslate\">Unique&lt;EnumType&gt;</code> everywhere, like so:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"export type Unique&lt;T&gt; = T &amp; { readonly '': unique symbol };\n\nexport enum DbProto { }\nexport enum BatchProto { }\n\nvar x: Unique&lt;DbProto&gt; = 1 as Unique&lt;DbProto&gt;\n\"><pre class=\"notranslate\"><code class=\"notranslate\">export type Unique&lt;T&gt; = T &amp; { readonly '': unique symbol };\n\nexport enum DbProto { }\nexport enum BatchProto { }\n\nvar x: Unique&lt;DbProto&gt; = 1 as Unique&lt;DbProto&gt;\n\n</code></pre></div>",
        "createdAt": "2019-09-29T19:48:25Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-536334767",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 2
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDU0ODA2MzUxOQ==",
        "author": {
          "login": "BobNobrain"
        },
        "authorAssociation": "NONE",
        "body": "For all the cases above, it seems like we can use something like \"narrowing\" mechanism for primitive types. The case is that we need to have types like `Guid` that are represented with a `string` but indeed are subtypes of it. But since such a type includes too many values to enumerate in union type (possibly even an infinite amount of values), we just need another way to tell the compiler that our `Guid` type is a subtype of `string`, for example, like this:\r\n\r\n```ts\r\ntype Guid extends string; // AFAIK, this will not break any existing syntax\r\n```\r\n\r\nSo the compiler knows that every type that extends `string` is just its another subtype, and all of these subtypes are not assignable to each other by default. Consider this example:\r\n\r\n```ts\r\ntype A extends string;\r\ntype B extends string;\r\n\r\ndeclare let a: A;\r\ndeclare let b: B;\r\ndeclare let s: string;\r\n\r\ns = a; // ok\r\ns = b; // ok\r\na = s; // error; need to use typecast\r\na = s as a; // ok\r\na = b; // error;\r\na = b as a; // error, '... neither type sufficiently overlaps with the other ...'\r\n```\r\n\r\nThis also can be enhanced with more advanced subtyping, like `type A extends string; type B extends A;`, and `type C extends B, A` (meaning that C is a subset of intersection of A and B).\r\n\r\nIndeed, this is still a kind of nominal typing, since the compiler knows nothing about `Guid` internal structure and therefore it has to resolve subtypes using their names. But it seems to create an isolated subset of types with no interference with any existing ones that are structurally compared, so I consider this to be easier to implement.\r\n",
        "bodyHTML": "<p dir=\"auto\">For all the cases above, it seems like we can use something like \"narrowing\" mechanism for primitive types. The case is that we need to have types like <code class=\"notranslate\">Guid</code> that are represented with a <code class=\"notranslate\">string</code> but indeed are subtypes of it. But since such a type includes too many values to enumerate in union type (possibly even an infinite amount of values), we just need another way to tell the compiler that our <code class=\"notranslate\">Guid</code> type is a subtype of <code class=\"notranslate\">string</code>, for example, like this:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type Guid extends string; // AFAIK, this will not break any existing syntax\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">Guid</span> <span class=\"pl-s1\">extends</span> <span class=\"pl-s1\">string</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// AFAIK, this will not break any existing syntax</span></pre></div>\n<p dir=\"auto\">So the compiler knows that every type that extends <code class=\"notranslate\">string</code> is just its another subtype, and all of these subtypes are not assignable to each other by default. Consider this example:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type A extends string;\ntype B extends string;\n\ndeclare let a: A;\ndeclare let b: B;\ndeclare let s: string;\n\ns = a; // ok\ns = b; // ok\na = s; // error; need to use typecast\na = s as a; // ok\na = b; // error;\na = b as a; // error, '... neither type sufficiently overlaps with the other ...'\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">A</span> <span class=\"pl-s1\">extends</span> <span class=\"pl-s1\">string</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">B</span> <span class=\"pl-s1\">extends</span> <span class=\"pl-s1\">string</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">let</span> <span class=\"pl-s1\">a</span>: <span class=\"pl-smi\">A</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">let</span> <span class=\"pl-s1\">b</span>: <span class=\"pl-smi\">B</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">let</span> <span class=\"pl-s1\">s</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-s1\">s</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">a</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// ok</span>\n<span class=\"pl-s1\">s</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">b</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// ok</span>\n<span class=\"pl-s1\">a</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">s</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error; need to use typecast</span>\n<span class=\"pl-s1\">a</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">s</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">a</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// ok</span>\n<span class=\"pl-s1\">a</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">b</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error;</span>\n<span class=\"pl-s1\">a</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">b</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">a</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// error, '... neither type sufficiently overlaps with the other ...'</span></pre></div>\n<p dir=\"auto\">This also can be enhanced with more advanced subtyping, like <code class=\"notranslate\">type A extends string; type B extends A;</code>, and <code class=\"notranslate\">type C extends B, A</code> (meaning that C is a subset of intersection of A and B).</p>\n<p dir=\"auto\">Indeed, this is still a kind of nominal typing, since the compiler knows nothing about <code class=\"notranslate\">Guid</code> internal structure and therefore it has to resolve subtypes using their names. But it seems to create an isolated subset of types with no interference with any existing ones that are structurally compared, so I consider this to be easier to implement.</p>",
        "createdAt": "2019-10-30T18:56:45Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-548063519",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 17
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 4
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDU3MDgyNzQxOQ==",
        "author": {
          "login": "unional"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "In case it is useful in this discussion, I learn that there are at least two flavor of nominal types.\r\nI expose those types in https://github.com/unional/type-plus \r\nThey are described by Drew Colthorp in this article: https://spin.atomicobject.com/2018/01/15/typescript-flexible-nominal-typing/#comment-604580\r\n",
        "bodyHTML": "<p dir=\"auto\">In case it is useful in this discussion, I learn that there are at least two flavor of nominal types.<br>\nI expose those types in <a href=\"https://github.com/unional/type-plus\">https://github.com/unional/type-plus</a><br>\nThey are described by Drew Colthorp in this article: <a href=\"https://spin.atomicobject.com/2018/01/15/typescript-flexible-nominal-typing/#comment-604580\" rel=\"nofollow\">https://spin.atomicobject.com/2018/01/15/typescript-flexible-nominal-typing/#comment-604580</a></p>",
        "createdAt": "2020-01-04T23:03:36Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-570827419",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDU3MDg0MjkxMQ==",
        "author": {
          "login": "MaxGraey"
        },
        "authorAssociation": "NONE",
        "body": "How about `newtype` similar to Haskell?\r\n```haskell\r\nnewtype f32 = number;\r\nnewtype f64 = f32;\r\n```\r\nor (with avoiding extra keyword reservation)\r\n```ts\r\ntype f32 = new number;\r\ntype f64 = new f32;\r\n```",
        "bodyHTML": "<p dir=\"auto\">How about <code class=\"notranslate\">newtype</code> similar to Haskell?</p>\n<div class=\"highlight highlight-source-haskell notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"newtype f32 = number;\nnewtype f64 = f32;\"><pre class=\"notranslate\"><span class=\"pl-k\">newtype</span> <span class=\"pl-smi\">f32</span> <span class=\"pl-k\">=</span> number;\n<span class=\"pl-k\">newtype</span> <span class=\"pl-smi\">f64</span> <span class=\"pl-k\">=</span> f32;</pre></div>\n<p dir=\"auto\">or (with avoiding extra keyword reservation)</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type f32 = new number;\ntype f64 = new f32;\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">f32</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">f64</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">f32</span><span class=\"pl-kos\">;</span></pre></div>",
        "createdAt": "2020-01-05T03:05:15Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-570842911",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 50
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDU4MzcwOTAyNg==",
        "author": {
          "login": "omidkrad"
        },
        "authorAssociation": "NONE",
        "body": "My workaround for this currently is to use a marker interface like [this](https://github.com/ccxt/ccxt/pull/5700/files).\r\n\r\n```typescript\r\ninterface TickerSymbol extends String {}\r\n```\r\n\r\nThe only problem is that when I want to use it as a index key, I have to cast it to `string`.\r\n\r\n```typescript\r\ninterface TickerSymbol extends String {}\r\nvar symbol: TickerSymbol = 'MSFT';\r\n// declare var tickers: {[symbol: TickerSymbol]: any}; // Error: index key must be string or number\r\ndeclare var tickers: {[symbol: string]: any};\r\n// tickers[symbol]; // Type 'TickerSymbol' cannot be used as an index type\r\ntickers[symbol as string]; // OK\r\n```\r\n\r\nHowever, JavaScript seems to be fine with index type of `String` (with capital S).\r\n\r\n```typescript\r\nvar obj = { one: 1 }\r\nvar key = new String('one');\r\nobj[key]; // TypeScript Error: Type 'String' cannot be used as an index type.\r\n// but JS gives expected output:\r\n// 1\r\n```",
        "bodyHTML": "<p dir=\"auto\">My workaround for this currently is to use a marker interface like <a href=\"https://github.com/ccxt/ccxt/pull/5700/files\">this</a>.</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"interface TickerSymbol extends String {}\"><pre class=\"notranslate\"><span class=\"pl-k\">interface</span> <span class=\"pl-smi\">TickerSymbol</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">String</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">The only problem is that when I want to use it as a index key, I have to cast it to <code class=\"notranslate\">string</code>.</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"interface TickerSymbol extends String {}\nvar symbol: TickerSymbol = 'MSFT';\n// declare var tickers: {[symbol: TickerSymbol]: any}; // Error: index key must be string or number\ndeclare var tickers: {[symbol: string]: any};\n// tickers[symbol]; // Type 'TickerSymbol' cannot be used as an index type\ntickers[symbol as string]; // OK\"><pre class=\"notranslate\"><span class=\"pl-k\">interface</span> <span class=\"pl-smi\">TickerSymbol</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">String</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">var</span> <span class=\"pl-s1\">symbol</span>: <span class=\"pl-smi\">TickerSymbol</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'MSFT'</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-c\">// declare var tickers: {[symbol: TickerSymbol]: any}; // Error: index key must be string or number</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">var</span> <span class=\"pl-s1\">tickers</span>: <span class=\"pl-kos\">{</span><span class=\"pl-kos\">[</span><span class=\"pl-s1\">symbol</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">any</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-c\">// tickers[symbol]; // Type 'TickerSymbol' cannot be used as an index type</span>\n<span class=\"pl-s1\">tickers</span><span class=\"pl-kos\">[</span><span class=\"pl-s1\">symbol</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">string</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// OK</span></pre></div>\n<p dir=\"auto\">However, JavaScript seems to be fine with index type of <code class=\"notranslate\">String</code> (with capital S).</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"var obj = { one: 1 }\nvar key = new String('one');\nobj[key]; // TypeScript Error: Type 'String' cannot be used as an index type.\n// but JS gives expected output:\n// 1\"><pre class=\"notranslate\"><span class=\"pl-k\">var</span> <span class=\"pl-s1\">obj</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">one</span>: <span class=\"pl-c1\">1</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">var</span> <span class=\"pl-s1\">key</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">String</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'one'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-s1\">obj</span><span class=\"pl-kos\">[</span><span class=\"pl-s1\">key</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// TypeScript Error: Type 'String' cannot be used as an index type.</span>\n<span class=\"pl-c\">// but JS gives expected output:</span>\n<span class=\"pl-c\">// 1</span></pre></div>",
        "createdAt": "2020-02-08T06:39:42Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-583709026",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDU5MDA3NzkyOA==",
        "author": {
          "login": "whzx5byb"
        },
        "authorAssociation": "NONE",
        "body": "Using `typeof X` where X is a symbol constant is better than `unique symbol`.\r\n\r\nConsider this code: \r\n\r\n    export type Nominal<T, U extends string> = T & { [K in U]: unique symbol };\r\n\r\n    type Foo = Nominal<Object, 'Foo'>;\r\n    let foo: Foo = { Foo: Symbol() };  // should have an error here, but succeed.\r\n    \r\n\r\nA better solution:\r\n\r\n    const UniqueSymbol = Symbol();\r\n    export type Nominal<T, U extends string> = T & { [K in U]: typeof UniqueSymbol };\r\n\r\n    type Bar = Nominal<Object, 'Bar'>;\r\n    let bar: Bar = { Bar: Symbol() }; \r\n\r\nThe constant symbol `UniqueSymbol` could be hidden in an external module which only exposes `Nominal` as a helper type.",
        "bodyHTML": "<p dir=\"auto\">Using <code class=\"notranslate\">typeof X</code> where X is a symbol constant is better than <code class=\"notranslate\">unique symbol</code>.</p>\n<p dir=\"auto\">Consider this code:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"export type Nominal&lt;T, U extends string&gt; = T &amp; { [K in U]: unique symbol };\n\ntype Foo = Nominal&lt;Object, 'Foo'&gt;;\nlet foo: Foo = { Foo: Symbol() };  // should have an error here, but succeed.\"><pre class=\"notranslate\"><code class=\"notranslate\">export type Nominal&lt;T, U extends string&gt; = T &amp; { [K in U]: unique symbol };\n\ntype Foo = Nominal&lt;Object, 'Foo'&gt;;\nlet foo: Foo = { Foo: Symbol() };  // should have an error here, but succeed.\n</code></pre></div>\n<p dir=\"auto\">A better solution:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"const UniqueSymbol = Symbol();\nexport type Nominal&lt;T, U extends string&gt; = T &amp; { [K in U]: typeof UniqueSymbol };\n\ntype Bar = Nominal&lt;Object, 'Bar'&gt;;\nlet bar: Bar = { Bar: Symbol() }; \"><pre class=\"notranslate\"><code class=\"notranslate\">const UniqueSymbol = Symbol();\nexport type Nominal&lt;T, U extends string&gt; = T &amp; { [K in U]: typeof UniqueSymbol };\n\ntype Bar = Nominal&lt;Object, 'Bar'&gt;;\nlet bar: Bar = { Bar: Symbol() }; \n</code></pre></div>\n<p dir=\"auto\">The constant symbol <code class=\"notranslate\">UniqueSymbol</code> could be hidden in an external module which only exposes <code class=\"notranslate\">Nominal</code> as a helper type.</p>",
        "createdAt": "2020-02-23T15:06:57Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-590077928",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDU5MDA4MzA2OA==",
        "author": {
          "login": "ljharb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "That doesn’t work for types that aren’t symbols, like if i want a “FooID” string type to be unique (yet be recognized as a string)",
        "bodyHTML": "<p dir=\"auto\">That doesn’t work for types that aren’t symbols, like if i want a “FooID” string type to be unique (yet be recognized as a string)</p>",
        "createdAt": "2020-02-23T15:53:49Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-590083068",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDU5MTI2MDAzNg==",
        "author": {
          "login": "pauldraper"
        },
        "authorAssociation": "NONE",
        "body": "@lu4 points out that TypeScript already has nominal typing in symbols and enums.\r\n\r\nPerhaps someone familiar with those could describe if the same approach could be used for other nominal types.\r\n\r\nLanguage-wise [newtype-like proposal](https://github.com/microsoft/TypeScript/issues/202#issuecomment-570842911) seems straightforward.\r\n\r\n```ts\r\ntype meters = new number;\r\ntype width = new meters;\r\n\r\ntype thing = { a: string };\r\ntype otherthing = new thing;\r\n```",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lu4/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lu4\">@lu4</a> points out that TypeScript already has nominal typing in symbols and enums.</p>\n<p dir=\"auto\">Perhaps someone familiar with those could describe if the same approach could be used for other nominal types.</p>\n<p dir=\"auto\">Language-wise <a href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-570842911\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">newtype-like proposal</a> seems straightforward.</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type meters = new number;\ntype width = new meters;\n\ntype thing = { a: string };\ntype otherthing = new thing;\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">meters</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">width</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">meters</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">thing</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">a</span>: <span class=\"pl-smi\">string</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">otherthing</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">thing</span><span class=\"pl-kos\">;</span></pre></div>",
        "createdAt": "2020-02-26T06:18:00Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-591260036",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDU5MTM5MTQxNw==",
        "author": {
          "login": "kristiandupont"
        },
        "authorAssociation": "NONE",
        "body": "For what it's worth, this used to be very important to me but I found once I let my OCD calm down, the hacks that exist work really well. Especially because I ended up using \"flavoring\" instead of \"branding\" (https://spin.atomicobject.com/2018/01/15/typescript-flexible-nominal-typing/). I imagine an official solution would give me semantics closer to branding.",
        "bodyHTML": "<p dir=\"auto\">For what it's worth, this used to be very important to me but I found once I let my OCD calm down, the hacks that exist work really well. Especially because I ended up using \"flavoring\" instead of \"branding\" (<a href=\"https://spin.atomicobject.com/2018/01/15/typescript-flexible-nominal-typing/\" rel=\"nofollow\">https://spin.atomicobject.com/2018/01/15/typescript-flexible-nominal-typing/</a>). I imagine an official solution would give me semantics closer to branding.</p>",
        "createdAt": "2020-02-26T12:01:52Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-591391417",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 12
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDU5MTQyMDY4NA==",
        "author": {
          "login": "ExE-Boss"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "There’s also somewhat nominal typing for classes with private fields (both hard and soft private):\r\n\r\n```ts\r\ndeclare class FooHardPrivate {\r\n\t#private;\r\n}\r\n\r\n// https://github.com/sandersn/downlevel-dts result:\r\ndeclare class FooSoftPrivate {\r\n\tprivate \"#private\";\r\n}\r\n```\r\n\r\nSee [**TypeScript FAQ** § **When and why are classes nominal?**](https://github.com/microsoft/TypeScript/wiki/FAQ#when-and-why-are-classes-nominal) for details.",
        "bodyHTML": "<p dir=\"auto\">There’s also somewhat nominal typing for classes with private fields (both hard and soft private):</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"declare class FooHardPrivate {\n\t#private;\n}\n\n// https://github.com/sandersn/downlevel-dts result:\ndeclare class FooSoftPrivate {\n\tprivate &quot;#private&quot;;\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">declare</span> <span class=\"pl-k\">class</span> <span class=\"pl-smi\">FooHardPrivate</span> <span class=\"pl-kos\">{</span>\n\t#private<span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-c\">// https://github.com/sandersn/downlevel-dts result:</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">class</span> <span class=\"pl-smi\">FooSoftPrivate</span> <span class=\"pl-kos\">{</span>\n\t<span class=\"pl-k\">private</span> <span class=\"pl-s\">\"#private\"</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">See <a href=\"https://github.com/microsoft/TypeScript/wiki/FAQ#when-and-why-are-classes-nominal\"><strong>TypeScript FAQ</strong> § <strong>When and why are classes nominal?</strong></a> for details.</p>",
        "createdAt": "2020-02-26T13:17:17Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-591420684",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 6
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY0NTg0MjU5Ng==",
        "author": {
          "login": "ryasmi"
        },
        "authorAssociation": "NONE",
        "body": "I've been working on a collection of validation rules and branded types which have been making this easier for us. Sharing it here in case it's useful to anyone.\r\nhttps://github.com/ryansmith94/rulr",
        "bodyHTML": "<p dir=\"auto\">I've been working on a collection of validation rules and branded types which have been making this easier for us. Sharing it here in case it's useful to anyone.<br>\n<a href=\"https://github.com/ryansmith94/rulr\">https://github.com/ryansmith94/rulr</a></p>",
        "createdAt": "2020-06-18T07:44:16Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-645842596",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY4MjQ5NTIwOA==",
        "author": {
          "login": "dbartholomae"
        },
        "authorAssociation": "NONE",
        "body": "Would love to see some progress on this, and happy to help. If I understood the discussion in #38510 correctly, there needs to be some more design thinking on where this would lead TypeScript? @DanielRosenwasser maybe you could chip in with a short update?\r\nI'm happy to help with design proposals and implementation work, but I haven't contributed to TypeScript yet and this seems like it is more a question on overall vision where what we need most is a decision from the TypeScript team how to move forward.",
        "bodyHTML": "<p dir=\"auto\">Would love to see some progress on this, and happy to help. If I understood the discussion in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"616914856\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/38510\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/38510/hovercard\" href=\"https://github.com/microsoft/TypeScript/issues/38510\">#38510</a> correctly, there needs to be some more design thinking on where this would lead TypeScript? <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/DanielRosenwasser/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/DanielRosenwasser\">@DanielRosenwasser</a> maybe you could chip in with a short update?<br>\nI'm happy to help with design proposals and implementation work, but I haven't contributed to TypeScript yet and this seems like it is more a question on overall vision where what we need most is a decision from the TypeScript team how to move forward.</p>",
        "createdAt": "2020-08-28T12:21:23Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-682495208",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 7
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY4Njk4NzkyNA==",
        "author": {
          "login": "DanielRosenwasser"
        },
        "authorAssociation": "MEMBER",
        "body": "@dbartholomae I'll repost my response from https://github.com/microsoft/TypeScript/issues/38510#issuecomment-631188003\r\n\r\n> I guess I'll give some context on where my mind is with nominality. There are a lot of different ideas people have in mind when they ask about nominal types, including\r\n> \r\n> * \"Traditional\" declaration-based nominality (e.g. what you see in most OO languages)\r\n> * Opaque types (types whose contents are entirely unknown outside)\r\n> * Distinct aliases (single-member `struct`s in C/C++/C#, `newtype` in Haskell, inline classes in Kotlin)\r\n> * Units of measure (a way to encode dimensional analysis into the language)\r\n> \r\n> There are shades between some of these (e.g. [placeholder type declarations](https://github.com/microsoft/TypeScript/issues/31894) - kind of variant of opaque types that fall back to an implementation type), and then there are different directions that blend each of these together.\r\n> \r\n> @RyanCavanaugh had a great analogy about this where 3 kids are asking their parents for a pet. One wants a dog, one wants a cat, one wants a fish. They ask their parents \"when are we getting a pet!?\" Clearly they all agree they want a pet, but each wants a different pet!\r\n> \r\n> Do I like branded types? I do! Branded types achieves something like distinct aliases, and fits the bill for what most users are looking for. But I don't think that's the right way to think about it. There's more design space to be fleshed out with plenty of known tradeoffs, and nothing giving me a sense that we need to rush a solution ASAP.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/dbartholomae/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/dbartholomae\">@dbartholomae</a> I'll repost my response from <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"616914856\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/38510\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/38510/hovercard?comment_id=631188003&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/38510#issuecomment-631188003\">#38510 (comment)</a></p>\n<blockquote>\n<p dir=\"auto\">I guess I'll give some context on where my mind is with nominality. There are a lot of different ideas people have in mind when they ask about nominal types, including</p>\n<ul dir=\"auto\">\n<li>\"Traditional\" declaration-based nominality (e.g. what you see in most OO languages)</li>\n<li>Opaque types (types whose contents are entirely unknown outside)</li>\n<li>Distinct aliases (single-member <code class=\"notranslate\">struct</code>s in C/C++/C#, <code class=\"notranslate\">newtype</code> in Haskell, inline classes in Kotlin)</li>\n<li>Units of measure (a way to encode dimensional analysis into the language)</li>\n</ul>\n<p dir=\"auto\">There are shades between some of these (e.g. <a href=\"https://github.com/microsoft/TypeScript/issues/31894\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/31894/hovercard\">placeholder type declarations</a> - kind of variant of opaque types that fall back to an implementation type), and then there are different directions that blend each of these together.</p>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/RyanCavanaugh/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/RyanCavanaugh\">@RyanCavanaugh</a> had a great analogy about this where 3 kids are asking their parents for a pet. One wants a dog, one wants a cat, one wants a fish. They ask their parents \"when are we getting a pet!?\" Clearly they all agree they want a pet, but each wants a different pet!</p>\n<p dir=\"auto\">Do I like branded types? I do! Branded types achieves something like distinct aliases, and fits the bill for what most users are looking for. But I don't think that's the right way to think about it. There's more design space to be fleshed out with plenty of known tradeoffs, and nothing giving me a sense that we need to rush a solution ASAP.</p>\n</blockquote>",
        "createdAt": "2020-09-04T08:05:42Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-686987924",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 10
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY4NzE5NDM0Ng==",
        "author": {
          "login": "dbartholomae"
        },
        "authorAssociation": "NONE",
        "body": "@DanielRosenwasser Thanks! So what's the best way forward here? I could e. g. set up a proposal for nominal types covering mainly the \"traditional\" declaration-based nominality with its application for units of measure. It would help though to get some insights into the usual process for proposals or at least an example proposal that I could build upon, as contributing.md only refers to code so far.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/DanielRosenwasser/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/DanielRosenwasser\">@DanielRosenwasser</a> Thanks! So what's the best way forward here? I could e. g. set up a proposal for nominal types covering mainly the \"traditional\" declaration-based nominality with its application for units of measure. It would help though to get some insights into the usual process for proposals or at least an example proposal that I could build upon, as contributing.md only refers to code so far.</p>",
        "createdAt": "2020-09-04T14:48:53Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-687194346",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDY5NTkxMjc4NQ==",
        "author": {
          "login": "pauldraper"
        },
        "authorAssociation": "NONE",
        "body": "A. It's possible today to get nominal types and the TS codebase itself uses them. It's a frequent need.\r\n\r\nBut there are a lot of implementations. TS could help a lot of programmers by having a good implementation, similar to when it made `Partial<T>` which replaced 12,135 previous implementations of varying quality.\r\n\r\nB. No one has suggested opaque types, and TS is certainly already different from the usual OO nominative types. Units/dimensional types are special-cased and insufficient for the requested scope.\r\n\r\nSo the clear answer to me is Haskell newtype.\r\n\r\n```ts\r\ntype Meters = new number;\r\ntype MetersSq = new number;\r\n```\r\n\r\nIt'd be functionally equivalent to\r\n\r\n```ts\r\nnamespace Meters {\r\n  export const TYPE = Symbol()\r\n}\r\ntype Meters = number & { type: typeof Meters.TYPE };\r\n\r\nnamespace MetersSq {\r\n  export const TYPE = Symbol()\r\n}\r\ntype MetersSq = number & { type: typeof MetersSq.TYPE };\r\n```\r\n\r\nbut with a more reasonable syntax and less room for user error.",
        "bodyHTML": "<p dir=\"auto\">A. It's possible today to get nominal types and the TS codebase itself uses them. It's a frequent need.</p>\n<p dir=\"auto\">But there are a lot of implementations. TS could help a lot of programmers by having a good implementation, similar to when it made <code class=\"notranslate\">Partial&lt;T&gt;</code> which replaced 12,135 previous implementations of varying quality.</p>\n<p dir=\"auto\">B. No one has suggested opaque types, and TS is certainly already different from the usual OO nominative types. Units/dimensional types are special-cased and insufficient for the requested scope.</p>\n<p dir=\"auto\">So the clear answer to me is Haskell newtype.</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type Meters = new number;\ntype MetersSq = new number;\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">Meters</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">MetersSq</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">It'd be functionally equivalent to</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"namespace Meters {\n  export const TYPE = Symbol()\n}\ntype Meters = number &amp; { type: typeof Meters.TYPE };\n\nnamespace MetersSq {\n  export const TYPE = Symbol()\n}\ntype MetersSq = number &amp; { type: typeof MetersSq.TYPE };\"><pre class=\"notranslate\"><span class=\"pl-k\">namespace</span> <span class=\"pl-smi\">Meters</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">export</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">TYPE</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Symbol</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Meters</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">type</span>: <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">Meters</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">TYPE</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">namespace</span> <span class=\"pl-smi\">MetersSq</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">export</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">TYPE</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Symbol</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">MetersSq</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">type</span>: <span class=\"pl-k\">typeof</span> <span class=\"pl-smi\">MetersSq</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">TYPE</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">but with a more reasonable syntax and less room for user error.</p>",
        "createdAt": "2020-09-21T05:48:36Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-695912785",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 35
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDcwMzUxMTUzMg==",
        "author": {
          "login": "chillitom"
        },
        "authorAssociation": "NONE",
        "body": "> ```ts\r\n> type Meters = new number;\r\n> type MetersSq = new number;\r\n> ```\r\n\r\nThis is nice, how would one go about instantiating one of these types?\r\n\r\n```ts\r\nlet meters = 3 as Meters;  // explicit cast?\r\nlet meters: Meters = 3;  // inferred?\r\n```\r\n\r\none cool thing could be to allow the declaration of custom literal suffixes (F# has limited support for this).\r\n\r\n> ```ts\r\n> type Meters = new number with suffix 'm';\r\n> let meters = 3m;\r\n>\r\n> type CssString = new string with suffix 'css'\r\n> let css = \"body { display: none; }\"css\r\n> ```\r\n\r\nProbably there are all kinds of issues with this syntax but hopefully the idea is clear.",
        "bodyHTML": "<blockquote>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type Meters = new number;\ntype MetersSq = new number;\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">Meters</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">MetersSq</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">number</span><span class=\"pl-kos\">;</span></pre></div>\n</blockquote>\n<p dir=\"auto\">This is nice, how would one go about instantiating one of these types?</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"let meters = 3 as Meters;  // explicit cast?\nlet meters: Meters = 3;  // inferred?\"><pre class=\"notranslate\"><span class=\"pl-k\">let</span> <span class=\"pl-s1\">meters</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">3</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Meters</span><span class=\"pl-kos\">;</span>  <span class=\"pl-c\">// explicit cast?</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">meters</span>: <span class=\"pl-smi\">Meters</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">3</span><span class=\"pl-kos\">;</span>  <span class=\"pl-c\">// inferred?</span></pre></div>\n<p dir=\"auto\">one cool thing could be to allow the declaration of custom literal suffixes (F# has limited support for this).</p>\n<blockquote>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type Meters = new number with suffix 'm';\nlet meters = 3m;\n\ntype CssString = new string with suffix 'css'\nlet css = &quot;body { display: none; }&quot;css\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">Meters</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-s1\">number</span> <span class=\"pl-k\">with</span> <span class=\"pl-s1\">suffix</span> <span class=\"pl-s\">'m'</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">meters</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">3</span><span class=\"pl-s1\">m</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">CssString</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-s1\">string</span> <span class=\"pl-k\">with</span> <span class=\"pl-s1\">suffix</span> <span class=\"pl-s\">'css'</span>\n<span class=\"pl-k\">let</span> <span class=\"pl-s1\">css</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">\"body { display: none; }\"</span><span class=\"pl-kos\"></span><span class=\"pl-s1\">css</span></pre></div>\n</blockquote>\n<p dir=\"auto\">Probably there are all kinds of issues with this syntax but hopefully the idea is clear.</p>",
        "createdAt": "2020-10-05T09:20:42Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-703511532",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 13
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDcwMzY4OTg1NA==",
        "author": {
          "login": "pauldraper"
        },
        "authorAssociation": "NONE",
        "body": "> This is nice, how would one go about instantiating one of these types?\r\n\r\nFor simplicity, I'd choose equivalent behavior of the example that works today.\r\n\r\n```ts\r\nlet meters = 3 as Meters;\r\n```\r\n\r\n[Playground](https://www.typescriptlang.org/play?#code/HYQwtgpgzgDiDGEAEBZCAXCAnKSDeAUEkhAB4wD2W6S8FwUNAKgJoAKAokgLxIDKATzAAjCgBsAFAEoCAXwLoBMZGkw4eSYAFcR2JADJ8SRcoBcxpRAoAzVBmxQAdK05JZAbgIFQkWAhX2OHwAjvhEJORUNHQMzOxcvIIi4tJyCpZ2alAhGtq6WAZGJhDmxTaZDiHO8W6eBGIYSJBZGgDMSCC4qg511lrA8OgAlvQdWBAgEgDuQwAm6AAW5t04ADRICxBDAOYL6MuBUFIHWTmExMTj6FpYwEgz8wtIAFQbW7s0nRVBwZ7yBCBxpNmg51iCcFIeLxwVBPEA)\r\n\r\nThe fact that this is already obtainable in the TS type system is hopefully a good sign for feasibility of implementation.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">This is nice, how would one go about instantiating one of these types?</p>\n</blockquote>\n<p dir=\"auto\">For simplicity, I'd choose equivalent behavior of the example that works today.</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"let meters = 3 as Meters;\"><pre class=\"notranslate\"><span class=\"pl-k\">let</span> <span class=\"pl-s1\">meters</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">3</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Meters</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\"><a href=\"https://www.typescriptlang.org/play?#code/HYQwtgpgzgDiDGEAEBZCAXCAnKSDeAUEkhAB4wD2W6S8FwUNAKgJoAKAokgLxIDKATzAAjCgBsAFAEoCAXwLoBMZGkw4eSYAFcR2JADJ8SRcoBcxpRAoAzVBmxQAdK05JZAbgIFQkWAhX2OHwAjvhEJORUNHQMzOxcvIIi4tJyCpZ2alAhGtq6WAZGJhDmxTaZDiHO8W6eBGIYSJBZGgDMSCC4qg511lrA8OgAlvQdWBAgEgDuQwAm6AAW5t04ADRICxBDAOYL6MuBUFIHWTmExMTj6FpYwEgz8wtIAFQbW7s0nRVBwZ7yBCBxpNmg51iCcFIeLxwVBPEA\" rel=\"nofollow\">Playground</a></p>\n<p dir=\"auto\">The fact that this is already obtainable in the TS type system is hopefully a good sign for feasibility of implementation.</p>",
        "createdAt": "2020-10-05T15:01:05Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-703689854",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDcwNDE3NTM0OA==",
        "author": {
          "login": "Ciantic"
        },
        "authorAssociation": "NONE",
        "body": "It would be nice to have the least controversial implementation with `as Meters`, it's readable enough and it's used already with other types. \r\n\r\nI'm pretty sure the F#-like suffixes aren't good fit for TypeScript, because they have high collision probability with future JavaScript syntax.\r\n\r\nMaybe we should open new issue using @pauldraper's suggestion of `new type`, because this issue seems to be about so many things. In order to get *something* done we need a simple proposal and that seems to fit the bill.",
        "bodyHTML": "<p dir=\"auto\">It would be nice to have the least controversial implementation with <code class=\"notranslate\">as Meters</code>, it's readable enough and it's used already with other types.</p>\n<p dir=\"auto\">I'm pretty sure the F#-like suffixes aren't good fit for TypeScript, because they have high collision probability with future JavaScript syntax.</p>\n<p dir=\"auto\">Maybe we should open new issue using <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/pauldraper/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/pauldraper\">@pauldraper</a>'s suggestion of <code class=\"notranslate\">new type</code>, because this issue seems to be about so many things. In order to get <em>something</em> done we need a simple proposal and that seems to fit the bill.</p>",
        "createdAt": "2020-10-06T10:21:30Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-704175348",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDcwNDE3NzM0MQ==",
        "author": {
          "login": "MaxGraey"
        },
        "authorAssociation": "NONE",
        "body": "I totally agree with `new type`. Btw it was suggested [here](https://github.com/microsoft/TypeScript/issues/202#issuecomment-570842911)",
        "bodyHTML": "<p dir=\"auto\">I totally agree with <code class=\"notranslate\">new type</code>. Btw it was suggested <a href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-570842911\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard\">here</a></p>",
        "createdAt": "2020-10-06T10:25:46Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-704177341",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDcwNjEwNzA5OA==",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "I've noticed that one good idea was lost during this long discussion. It was introduced by @isiahmeadows the details are here https://github.com/microsoft/TypeScript/issues/202#issuecomment-437306455\r\n\r\nSummarizing: If you'll look deeper into semantics of how nominal types are introduced now, you would see that it is a combination of your subject type and the impossible type i.e. \r\n\r\n```\r\nexport type Kilos<T> = T & { readonly '': unique symbol }; // T & Impossible type\r\nexport type Pounds<T> = T & { readonly '': unique symbol }; // T & Impossible type\r\n```\r\n\r\nWhat's interesting to me here is the fact that we're using logical operation on two types, i.e. the subject type and the impossible type. So the reason why it's interesting to me is that that an example above performs a logical operation on two types. I would like to emphasise: **a strict logical operation** (in terms of mathematical logic) on two types. But what is this impossible type is? I mean what is it in terms of mathematical logic? How the impossible type is constructed using terms of mathematical logic?\r\n\r\nIt can be seen that the notion of `new type` or `unique type` comes from current `unique symbol` part that the impossible type is mostly consists of. The question is what this `unique` part is doing to `symbol` that makes it special. How it can be expressed in terms of mathematical logic. So as it seems to me (here https://github.com/microsoft/TypeScript/issues/202#issuecomment-494183625) the `unique` part alternates the type i.e. it is `logical not` or `!` operation on type.\r\n\r\nSo the nominal type:\r\n\r\n```\r\nexport type Kilos<T> = T & { readonly '': unique symbol }; // T & Impossible type\r\n```\r\n\r\nin it's nature can be expressed something like:\r\n\r\n```\r\nexport type Kilos<T> = T & !unknown; // T & Impossible type\r\n```\r\nor even\r\n```\r\nexport type Kilos<T> = !T;\r\n```\r\n\r\nThe notion of `not type` opens view for much wider perspective . In fact so wide that I can't even suggest another example of it 😄 \r\n\r\nBut what seems important is that in mathematical logic, the three operators `&`, `|` and `!` form basic logical operators through which it is possible to express any logical expression. On the other hand it is interesting how the suggested above `new` which implies instance construction for types correlates with `logical not` on types. Interesting how these terms are similar and different under subject perspective.",
        "bodyHTML": "<p dir=\"auto\">I've noticed that one good idea was lost during this long discussion. It was introduced by @isiahmeadows the details are here <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard?comment_id=437306455&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-437306455\">#202 (comment)</a></p>\n<p dir=\"auto\">Summarizing: If you'll look deeper into semantics of how nominal types are introduced now, you would see that it is a combination of your subject type and the impossible type i.e.</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"export type Kilos&lt;T&gt; = T &amp; { readonly '': unique symbol }; // T &amp; Impossible type\nexport type Pounds&lt;T&gt; = T &amp; { readonly '': unique symbol }; // T &amp; Impossible type\"><pre class=\"notranslate\"><code class=\"notranslate\">export type Kilos&lt;T&gt; = T &amp; { readonly '': unique symbol }; // T &amp; Impossible type\nexport type Pounds&lt;T&gt; = T &amp; { readonly '': unique symbol }; // T &amp; Impossible type\n</code></pre></div>\n<p dir=\"auto\">What's interesting to me here is the fact that we're using logical operation on two types, i.e. the subject type and the impossible type. So the reason why it's interesting to me is that that an example above performs a logical operation on two types. I would like to emphasise: <strong>a strict logical operation</strong> (in terms of mathematical logic) on two types. But what is this impossible type is? I mean what is it in terms of mathematical logic? How the impossible type is constructed using terms of mathematical logic?</p>\n<p dir=\"auto\">It can be seen that the notion of <code class=\"notranslate\">new type</code> or <code class=\"notranslate\">unique type</code> comes from current <code class=\"notranslate\">unique symbol</code> part that the impossible type is mostly consists of. The question is what this <code class=\"notranslate\">unique</code> part is doing to <code class=\"notranslate\">symbol</code> that makes it special. How it can be expressed in terms of mathematical logic. So as it seems to me (here <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"38467435\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/202\" data-hovercard-type=\"issue\" data-hovercard-url=\"/microsoft/TypeScript/issues/202/hovercard?comment_id=494183625&amp;comment_type=issue_comment\" href=\"https://github.com/microsoft/TypeScript/issues/202#issuecomment-494183625\">#202 (comment)</a>) the <code class=\"notranslate\">unique</code> part alternates the type i.e. it is <code class=\"notranslate\">logical not</code> or <code class=\"notranslate\">!</code> operation on type.</p>\n<p dir=\"auto\">So the nominal type:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"export type Kilos&lt;T&gt; = T &amp; { readonly '': unique symbol }; // T &amp; Impossible type\"><pre class=\"notranslate\"><code class=\"notranslate\">export type Kilos&lt;T&gt; = T &amp; { readonly '': unique symbol }; // T &amp; Impossible type\n</code></pre></div>\n<p dir=\"auto\">in it's nature can be expressed something like:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"export type Kilos&lt;T&gt; = T &amp; !unknown; // T &amp; Impossible type\"><pre class=\"notranslate\"><code class=\"notranslate\">export type Kilos&lt;T&gt; = T &amp; !unknown; // T &amp; Impossible type\n</code></pre></div>\n<p dir=\"auto\">or even</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"export type Kilos&lt;T&gt; = !T;\"><pre class=\"notranslate\"><code class=\"notranslate\">export type Kilos&lt;T&gt; = !T;\n</code></pre></div>\n<p dir=\"auto\">The notion of <code class=\"notranslate\">not type</code> opens view for much wider perspective . In fact so wide that I can't even suggest another example of it 😄</p>\n<p dir=\"auto\">But what seems important is that in mathematical logic, the three operators <code class=\"notranslate\">&amp;</code>, <code class=\"notranslate\">|</code> and <code class=\"notranslate\">!</code> form basic logical operators through which it is possible to express any logical expression. On the other hand it is interesting how the suggested above <code class=\"notranslate\">new</code> which implies instance construction for types correlates with <code class=\"notranslate\">logical not</code> on types. Interesting how these terms are similar and different under subject perspective.</p>",
        "createdAt": "2020-10-09T10:38:55Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-706107098",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDcwNjQ0MjY3OQ==",
        "author": {
          "login": "pauldraper"
        },
        "authorAssociation": "NONE",
        "body": "@lu4 I don't believe that is accurate. `{ readonly '': unique symbol }` is not an \"impossible type\".\r\n\r\nThe intersection of that and `number` is impossible, yes. But that's not relevant. What's relevant is that there is a unique identity to the type, namely `unique symbol` .",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lu4/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lu4\">@lu4</a> I don't believe that is accurate. <code class=\"notranslate\">{ readonly '': unique symbol }</code> is not an \"impossible type\".</p>\n<p dir=\"auto\">The intersection of that and <code class=\"notranslate\">number</code> is impossible, yes. But that's not relevant. What's relevant is that there is a unique identity to the type, namely <code class=\"notranslate\">unique symbol</code> .</p>",
        "createdAt": "2020-10-09T23:28:56Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-706442679",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDcwODI1NDkzNA==",
        "author": {
          "login": "dead-claudia"
        },
        "authorAssociation": "NONE",
        "body": "@lu4 There's two issues with your proposed replacements, though:\r\n\r\n1. It falls apart the moment you need to do `not NominalType`. Mine doesn't.\r\n2. `not unknown` once [this pull request gets merged](https://github.com/microsoft/TypeScript/pull/29317) will evaluate to `never`, and so `T & never` gets similarly reduced to just `T` and so yeah, that trick won't actually work.\r\n\r\n-----\r\n\r\nI did find a pull request very similar to my proposal (though very subtly different in control flow narrowing rules if I understand correctly): https://github.com/microsoft/TypeScript/pull/33038",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lu4/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lu4\">@lu4</a> There's two issues with your proposed replacements, though:</p>\n<ol dir=\"auto\">\n<li>It falls apart the moment you need to do <code class=\"notranslate\">not NominalType</code>. Mine doesn't.</li>\n<li><code class=\"notranslate\">not unknown</code> once <a href=\"https://github.com/microsoft/TypeScript/pull/29317\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/microsoft/TypeScript/pull/29317/hovercard\">this pull request gets merged</a> will evaluate to <code class=\"notranslate\">never</code>, and so <code class=\"notranslate\">T &amp; never</code> gets similarly reduced to just <code class=\"notranslate\">T</code> and so yeah, that trick won't actually work.</li>\n</ol>\n<hr>\n<p dir=\"auto\">I did find a pull request very similar to my proposal (though very subtly different in control flow narrowing rules if I understand correctly): <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"484275578\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/33038\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/microsoft/TypeScript/pull/33038/hovercard\" href=\"https://github.com/microsoft/TypeScript/pull/33038\">#33038</a></p>",
        "createdAt": "2020-10-14T08:43:28Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-708254934",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDcyNzExODQyMA==",
        "author": {
          "login": "ExE-Boss"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@isiahmeadows\r\n\r\n`T & never` is `never`.",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows</p>\n<p dir=\"auto\"><code class=\"notranslate\">T &amp; never</code> is <code class=\"notranslate\">never</code>.</p>",
        "createdAt": "2020-11-14T01:48:02Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-727118420",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDcyNzE5MDA4OQ==",
        "author": {
          "login": "Shinigami92"
        },
        "authorAssociation": "NONE",
        "body": "Don't know if this was anytime posted here in the last 500 comments,\r\nbut I found this: https://github.com/andnp/SimplyTyped/blob/master/src/types/utils.ts#L30-L41\r\nAnd it's really handy and useful\r\nOnly problem I encountered was using with `Partial`/`DeepPartial`",
        "bodyHTML": "<p dir=\"auto\">Don't know if this was anytime posted here in the last 500 comments,<br>\nbut I found this: <a href=\"https://github.com/andnp/SimplyTyped/blob/master/src/types/utils.ts#L30-L41\">https://github.com/andnp/SimplyTyped/blob/master/src/types/utils.ts#L30-L41</a><br>\nAnd it's really handy and useful<br>\nOnly problem I encountered was using with <code class=\"notranslate\">Partial</code>/<code class=\"notranslate\">DeepPartial</code></p>",
        "createdAt": "2020-11-14T11:11:28Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-727190089",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 7
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDczNTQwMDg1Nw==",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "@isiahmeadows My point was to spark imagination with that post (probably my own in the first place) to draw a parallel between incompatible concepts and to summarize my previous thoughts in one place. I see now that #29317 covers this topic in greater detail and from much practical standpoint, thanks! @pauldraper Nomenclature noted, thank you too. Also `not NominalType` makes a lot of sense but apparently requires language-level support for nominal types, I don't see how `not (Type & { readonly '': unique symbol })` can yield anything meaningful in regard to `not NominalType`. Then how can `not (Type & { readonly '': unique symbol })` take away that unique identity assigned by unique symbol. What does `not (Type & { readonly '': unique symbol })` actually means?",
        "bodyHTML": "<p dir=\"auto\">@isiahmeadows My point was to spark imagination with that post (probably my own in the first place) to draw a parallel between incompatible concepts and to summarize my previous thoughts in one place. I see now that <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"397176111\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/29317\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/microsoft/TypeScript/pull/29317/hovercard\" href=\"https://github.com/microsoft/TypeScript/pull/29317\">#29317</a> covers this topic in greater detail and from much practical standpoint, thanks! <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/pauldraper/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/pauldraper\">@pauldraper</a> Nomenclature noted, thank you too. Also <code class=\"notranslate\">not NominalType</code> makes a lot of sense but apparently requires language-level support for nominal types, I don't see how <code class=\"notranslate\">not (Type &amp; { readonly '': unique symbol })</code> can yield anything meaningful in regard to <code class=\"notranslate\">not NominalType</code>. Then how can <code class=\"notranslate\">not (Type &amp; { readonly '': unique symbol })</code> take away that unique identity assigned by unique symbol. What does <code class=\"notranslate\">not (Type &amp; { readonly '': unique symbol })</code> actually means?</p>",
        "createdAt": "2020-11-29T14:11:06Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-735400857",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDgxMTI0Njc2OA==",
        "author": {
          "login": "Duckers"
        },
        "authorAssociation": "NONE",
        "body": "While we are waiting for this feature, I think I've found a pretty decent work-around using current typescript features.\r\n\r\nAfter trying a lot of different suggestions (with limited success), I wrote this:\r\n\r\n```ts\r\nexport declare class OpaqueString<T extends string> extends String {\r\n    /** This helps typescript distinguish different opaque string types. */\r\n    protected readonly __opaqueString: T\r\n    /** This object is already a string, but calling this makes method\r\n     * makes typescript recognize it as such. */\r\n    toString(): string\r\n}\r\n```\r\n\r\nThen, to make an opaque string type:\r\n```ts\r\nexport type Email = OpaqueString<\"Email\">\r\nexport function Email(value: string): Email {\r\n     // ... you can do any desired validation here to make sure value is actually worthy of the type\r\n     return value as any as Email\r\n}\r\n```\r\n\r\nThis actually works in all contexts I have tested:\r\n* Comparison through `===`, serialization/deserialization etc works as expected (at runtime, an `Email` is literally a string)\r\n* TypeScript prevents implicit casting between strings and opaque strings, and between different opaque types\r\n* Use the constructor function (e.g. `Email()`) to cast a string to an opaque string of a specific type. \r\n* Use `.toString()` to cast back to string (since this is already a built-in function on `String`)\r\n* The entire interface of `String` is available on the type (e.g. `.substr()`) since we are extending `String`\r\n* Making the type brand `protected` makes sure we don't have a leaky interface with type-unsafe props.\r\n* This approach does not trigger weird errors like \"'Email'  can not be assigned to 'undefined'\" that I've struggled with with other suggestions",
        "bodyHTML": "<p dir=\"auto\">While we are waiting for this feature, I think I've found a pretty decent work-around using current typescript features.</p>\n<p dir=\"auto\">After trying a lot of different suggestions (with limited success), I wrote this:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"export declare class OpaqueString&lt;T extends string&gt; extends String {\n    /** This helps typescript distinguish different opaque string types. */\n    protected readonly __opaqueString: T\n    /** This object is already a string, but calling this makes method\n     * makes typescript recognize it as such. */\n    toString(): string\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">export</span> <span class=\"pl-k\">declare</span> <span class=\"pl-k\">class</span> <span class=\"pl-smi\">OpaqueString</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">string</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">String</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-c\">/** This helps typescript distinguish different opaque string types. */</span>\n    <span class=\"pl-k\">protected</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">__opaqueString</span>: <span class=\"pl-smi\">T</span>\n    <span class=\"pl-c\">/** This object is already a string, but calling this makes method</span>\n<span class=\"pl-c\">     * makes typescript recognize it as such. */</span>\n    <span class=\"pl-c1\">toString</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">string</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">Then, to make an opaque string type:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"export type Email = OpaqueString&lt;&quot;Email&quot;&gt;\nexport function Email(value: string): Email {\n     // ... you can do any desired validation here to make sure value is actually worthy of the type\n     return value as any as Email\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Email</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">OpaqueString</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">\"Email\"</span><span class=\"pl-kos\">&gt;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">function</span> <span class=\"pl-smi\">Email</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">value</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">Email</span> <span class=\"pl-kos\">{</span>\n     <span class=\"pl-c\">// ... you can do any desired validation here to make sure value is actually worthy of the type</span>\n     <span class=\"pl-k\">return</span> <span class=\"pl-s1\">value</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">any</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Email</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">This actually works in all contexts I have tested:</p>\n<ul dir=\"auto\">\n<li>Comparison through <code class=\"notranslate\">===</code>, serialization/deserialization etc works as expected (at runtime, an <code class=\"notranslate\">Email</code> is literally a string)</li>\n<li>TypeScript prevents implicit casting between strings and opaque strings, and between different opaque types</li>\n<li>Use the constructor function (e.g. <code class=\"notranslate\">Email()</code>) to cast a string to an opaque string of a specific type.</li>\n<li>Use <code class=\"notranslate\">.toString()</code> to cast back to string (since this is already a built-in function on <code class=\"notranslate\">String</code>)</li>\n<li>The entire interface of <code class=\"notranslate\">String</code> is available on the type (e.g. <code class=\"notranslate\">.substr()</code>) since we are extending <code class=\"notranslate\">String</code></li>\n<li>Making the type brand <code class=\"notranslate\">protected</code> makes sure we don't have a leaky interface with type-unsafe props.</li>\n<li>This approach does not trigger weird errors like \"'Email'  can not be assigned to 'undefined'\" that I've struggled with with other suggestions</li>\n</ul>",
        "createdAt": "2021-03-31T16:50:25Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-811246768",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 20
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 4
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDgxMjUzOTE0NA==",
        "author": {
          "login": "iislucas"
        },
        "authorAssociation": "NONE",
        "body": "And if you want a version that completely removes any runtime code, compiling to JS that simply doesn't have types, then you can do this: \r\n\r\n```ts\r\ninterface OpaqueString<T extends string> extends String {\r\n  readonly __opaqueString: T;\r\n}\r\n\r\ntype Email = OpaqueString<'email'>;\r\ntype Id = OpaqueString<'id'>;\r\n\r\nconst some_id = ('foo' as never as Id);  // slightly verbose casting.\r\nconst some_email = ('foo' as never as Email);  // slightly verbose casting.\r\nconst x = some_email.toString(); // x is a string, but pay with a function call.\r\nconst y = some_email as never as string; // explicit conversion.\r\n\r\nsome_id === some_email ? console.log(true) : console.log(false);  // type error, yay!\r\nsome_email = 'a'; // type error, yay!\r\n```\r\n\r\nThis basically swaps the identity function call `Email` with the \"as never as\" typecast, maybe at the expense of readability. ",
        "bodyHTML": "<p dir=\"auto\">And if you want a version that completely removes any runtime code, compiling to JS that simply doesn't have types, then you can do this:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"interface OpaqueString&lt;T extends string&gt; extends String {\n  readonly __opaqueString: T;\n}\n\ntype Email = OpaqueString&lt;'email'&gt;;\ntype Id = OpaqueString&lt;'id'&gt;;\n\nconst some_id = ('foo' as never as Id);  // slightly verbose casting.\nconst some_email = ('foo' as never as Email);  // slightly verbose casting.\nconst x = some_email.toString(); // x is a string, but pay with a function call.\nconst y = some_email as never as string; // explicit conversion.\n\nsome_id === some_email ? console.log(true) : console.log(false);  // type error, yay!\nsome_email = 'a'; // type error, yay!\"><pre class=\"notranslate\"><span class=\"pl-k\">interface</span> <span class=\"pl-smi\">OpaqueString</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">string</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">String</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">__opaqueString</span>: <span class=\"pl-smi\">T</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Email</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">OpaqueString</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'email'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Id</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">OpaqueString</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'id'</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">some_id</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span><span class=\"pl-s\">'foo'</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">never</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Id</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>  <span class=\"pl-c\">// slightly verbose casting.</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">some_email</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span><span class=\"pl-s\">'foo'</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">never</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Email</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>  <span class=\"pl-c\">// slightly verbose casting.</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">x</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">some_email</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">toString</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// x is a string, but pay with a function call.</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">y</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">some_email</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">never</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// explicit conversion.</span>\n\n<span class=\"pl-s1\">some_id</span> <span class=\"pl-c1\">===</span> <span class=\"pl-s1\">some_email</span> ? <span class=\"pl-smi\">console</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">true</span><span class=\"pl-kos\">)</span> : <span class=\"pl-smi\">console</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">false</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>  <span class=\"pl-c\">// type error, yay!</span>\n<span class=\"pl-s1\">some_email</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'a'</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// type error, yay!</span></pre></div>\n<p dir=\"auto\">This basically swaps the identity function call <code class=\"notranslate\">Email</code> with the \"as never as\" typecast, maybe at the expense of readability.</p>",
        "createdAt": "2021-04-02T13:49:40Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-812539144",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDgxMjY2MDkzMg==",
        "author": {
          "login": "unional"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I have shared in this thread before, there are many libraries provide this support.\r\ne.g. from `type-plus` I wrote:\r\nhttps://github.com/unional/type-plus#nominal-type\r\n",
        "bodyHTML": "<p dir=\"auto\">I have shared in this thread before, there are many libraries provide this support.<br>\ne.g. from <code class=\"notranslate\">type-plus</code> I wrote:<br>\n<a href=\"https://github.com/unional/type-plus#nominal-type\">https://github.com/unional/type-plus#nominal-type</a></p>",
        "createdAt": "2021-04-02T18:44:08Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-812660932",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDgyNjY0Mjc5Mw==",
        "author": {
          "login": "SRachamim"
        },
        "authorAssociation": "NONE",
        "body": "The best implementation of `newtypes` in _TypeScript_: [newtype-ts](https://github.com/gcanti/newtype-ts)",
        "bodyHTML": "<p dir=\"auto\">The best implementation of <code class=\"notranslate\">newtypes</code> in <em>TypeScript</em>: <a href=\"https://github.com/gcanti/newtype-ts\">newtype-ts</a></p>",
        "createdAt": "2021-04-26T08:50:34Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-826642793",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDgyOTI1Njk0Mw==",
        "author": {
          "login": "bendman"
        },
        "authorAssociation": "NONE",
        "body": "What about this solution? It uses the `unique symbol` technique, doesn't generate any runtime code, allows nominal interfaces and nominal basic types, doesn't require a unique string ID to be treated as unique, but allows unique string IDs to be passed to make error messages more readable.\r\n\r\n```ts\r\ntype Nominal<Name extends string, Tag, Type = {}> = Type & {\r\n    readonly __tuid__: { name: Name, tag: Tag};\r\n};\r\n\r\ninterface User extends Nominal<'user', {readonly id: unique symbol}> {\r\n  id: Nominal<'userid', {readonly id: unique symbol}, string>\r\n}\r\ninterface Post extends Nominal<'post', {readonly id: unique symbol}> {\r\n  id: Nominal<'postid', { readonly id: unique symbol }, string>\r\n}\r\n\r\nlet publishPostByPostID = (postId: Post['id']) => {\r\n    console.log(postId.toUpperCase()); // we still get string method intellisense on postId\r\n};\r\n\r\nconst user = { id: 'hello', name: 'Ben' } as unknown as User; // We can cast as the type going through `unknown`\r\npublishPostByPostID(user.id); // This should cause an error\r\npublishPostByPostID('some id' as Post['id']); // We need to pass the specific type in this case\r\n```\r\n[Playground](https://www.typescriptlang.org/play?removeComments=true#code/C4TwDgpgBAcg9gWwJYDsCGAbAPDNDoQAewEKAJgM5QXABOqA5gDRQAqazb40AvFAN4BfAHxQ+rblABkAgFBQFUWhDRk4KDCCgB9bcACuSMroBcAqOnxnc+FsA5n2DQQG5Zr2bNQlaAMzQAxtAAqhQQtFBEJORU8Mjo2ADk+mG0iSz8yqrqmlBGZvooSACO+tAUIAgARnAYInIK+bCIqJhYiUbpAllqGlpNhSVl1JU1dSw09CgMwu5eKD7+QVAACnA0kcSklM3xbYlg68BdmSq9uQNFpeWjtfX88nlk1i0J7Z0ZSmc5-c9Qg9cRtValBBBM6IxZoJPBgIMAoGB9FUMEgKAALNY0ABCIExwAAkgARMRQAAUhxo+L+eIA2h0yIkALoASjEogeiigAXUFFqEAAdBg4AxyUcqfzgHBgmBILQAMJoMKk5nMlxQAD06qgAHdysAkBgMFAGHDqBDplB8MA0XAyHkFhBDajSGEoOoEWKyO43LJuSgNilwiT+E8zIk0Y6hV1LBAw1jSIlQVBFf8UABrFBwbUoZNUULhNWaqAAdWgATQOfLGxT1ugoEgxrgjCg1tocH0DDRUAABoUM1mUN3ZIjkaiMUccXiiaTA7R+UZVRqtaw0ajqDb9Bg7eXA8mc+E27Rh0iUei8ZOxYTSYlefgnomU7T6UzF0XSxYIBA7ZKEYqqLXqEgAIkF8JAAhbSRUBbVcqCrCAgA)\r\n\r\nThis could potentially be made much easier to use, but currently TS doesn't allow using `unique symbol` types inside of generics, so they need to be made at each declaration point.",
        "bodyHTML": "<p dir=\"auto\">What about this solution? It uses the <code class=\"notranslate\">unique symbol</code> technique, doesn't generate any runtime code, allows nominal interfaces and nominal basic types, doesn't require a unique string ID to be treated as unique, but allows unique string IDs to be passed to make error messages more readable.</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"type Nominal&lt;Name extends string, Tag, Type = {}&gt; = Type &amp; {\n    readonly __tuid__: { name: Name, tag: Tag};\n};\n\ninterface User extends Nominal&lt;'user', {readonly id: unique symbol}&gt; {\n  id: Nominal&lt;'userid', {readonly id: unique symbol}, string&gt;\n}\ninterface Post extends Nominal&lt;'post', {readonly id: unique symbol}&gt; {\n  id: Nominal&lt;'postid', { readonly id: unique symbol }, string&gt;\n}\n\nlet publishPostByPostID = (postId: Post['id']) =&gt; {\n    console.log(postId.toUpperCase()); // we still get string method intellisense on postId\n};\n\nconst user = { id: 'hello', name: 'Ben' } as unknown as User; // We can cast as the type going through `unknown`\npublishPostByPostID(user.id); // This should cause an error\npublishPostByPostID('some id' as Post['id']); // We need to pass the specific type in this case\"><pre class=\"notranslate\"><span class=\"pl-k\">type</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">Name</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">Tag</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">Type</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Type</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">__tuid__</span>: <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">name</span>: <span class=\"pl-smi\">Name</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">tag</span>: <span class=\"pl-smi\">Tag</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">User</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'user'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span><span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">id</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c1\">id</span>: <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'userid'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span><span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">id</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">string</span><span class=\"pl-kos\">&gt;</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">interface</span> <span class=\"pl-smi\">Post</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'post'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span><span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">id</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c1\">id</span>: <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'postid'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-c1\">id</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">string</span><span class=\"pl-kos\">&gt;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">let</span> <span class=\"pl-en\">publishPostByPostID</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">postId</span>: <span class=\"pl-smi\">Post</span><span class=\"pl-kos\">[</span><span class=\"pl-s\">'id'</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-smi\">console</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">postId</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">toUpperCase</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// we still get string method intellisense on postId</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">user</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">id</span>: <span class=\"pl-s\">'hello'</span><span class=\"pl-kos\">,</span> <span class=\"pl-c1\">name</span>: <span class=\"pl-s\">'Ben'</span> <span class=\"pl-kos\">}</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">unknown</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">User</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// We can cast as the type going through `unknown`</span>\n<span class=\"pl-en\">publishPostByPostID</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">user</span><span class=\"pl-kos\">.</span><span class=\"pl-c1\">id</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// This should cause an error</span>\n<span class=\"pl-en\">publishPostByPostID</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'some id'</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Post</span><span class=\"pl-kos\">[</span><span class=\"pl-s\">'id'</span><span class=\"pl-kos\">]</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// We need to pass the specific type in this case</span></pre></div>\n<p dir=\"auto\"><a href=\"https://www.typescriptlang.org/play?removeComments=true#code/C4TwDgpgBAcg9gWwJYDsCGAbAPDNDoQAewEKAJgM5QXABOqA5gDRQAqazb40AvFAN4BfAHxQ+rblABkAgFBQFUWhDRk4KDCCgB9bcACuSMroBcAqOnxnc+FsA5n2DQQG5Zr2bNQlaAMzQAxtAAqhQQtFBEJORU8Mjo2ADk+mG0iSz8yqrqmlBGZvooSACO+tAUIAgARnAYInIK+bCIqJhYiUbpAllqGlpNhSVl1JU1dSw09CgMwu5eKD7+QVAACnA0kcSklM3xbYlg68BdmSq9uQNFpeWjtfX88nlk1i0J7Z0ZSmc5-c9Qg9cRtValBBBM6IxZoJPBgIMAoGB9FUMEgKAALNY0ABCIExwAAkgARMRQAAUhxo+L+eIA2h0yIkALoASjEogeiigAXUFFqEAAdBg4AxyUcqfzgHBgmBILQAMJoMKk5nMlxQAD06qgAHdysAkBgMFAGHDqBDplB8MA0XAyHkFhBDajSGEoOoEWKyO43LJuSgNilwiT+E8zIk0Y6hV1LBAw1jSIlQVBFf8UABrFBwbUoZNUULhNWaqAAdWgATQOfLGxT1ugoEgxrgjCg1tocH0DDRUAABoUM1mUN3ZIjkaiMUccXiiaTA7R+UZVRqtaw0ajqDb9Bg7eXA8mc+E27Rh0iUei8ZOxYTSYlefgnomU7T6UzF0XSxYIBA7ZKEYqqLXqEgAIkF8JAAhbSRUBbVcqCrCAgA\" rel=\"nofollow\">Playground</a></p>\n<p dir=\"auto\">This could potentially be made much easier to use, but currently TS doesn't allow using <code class=\"notranslate\">unique symbol</code> types inside of generics, so they need to be made at each declaration point.</p>",
        "createdAt": "2021-04-29T13:53:24Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-829256943",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDgzNTkwMTQwMQ==",
        "author": {
          "login": "DustinJSilk"
        },
        "authorAssociation": "NONE",
        "body": "This has been open since 2014. How can we create a strong type that doesn't require an extra key which is hard to omit later on.\r\n\r\nMy use case is that I want to 'tag' certain types so that I can recognise them in a type conditional later on. The problem then comes when the original document needs to be cleaned of all these extra keys.",
        "bodyHTML": "<p dir=\"auto\">This has been open since 2014. How can we create a strong type that doesn't require an extra key which is hard to omit later on.</p>\n<p dir=\"auto\">My use case is that I want to 'tag' certain types so that I can recognise them in a type conditional later on. The problem then comes when the original document needs to be cleaned of all these extra keys.</p>",
        "createdAt": "2021-05-09T21:54:09Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-835901401",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "MDEyOklzc3VlQ29tbWVudDgzNjYwMDA5Nw==",
        "author": {
          "login": "KristjanTammekivi"
        },
        "authorAssociation": "NONE",
        "body": "I'd say discussion has lead to a nice place with the syntax.\r\nSome things that I haven't seen discussed yet (although this is a long thread, I might've missed them while skimming but I still think it wouldn't hurt to summarize)\r\n\r\n1) How does `type UserId = new number;` interact with `extends` keyword? I assume UserId extends number (and all other nominal types will extend their parent types).\r\n2) Can you create nominal types from nominal types?\r\n```typescript\r\n  type UUID  = new string;\r\n  type MessageId = new UUID;\r\n```\r\nAll in all it seems to me that discussion around is reaching an end. I did notice that nominal types aren't in the 2021 first half roadmap but I assume that was just for the sake of being realistic?",
        "bodyHTML": "<p dir=\"auto\">I'd say discussion has lead to a nice place with the syntax.<br>\nSome things that I haven't seen discussed yet (although this is a long thread, I might've missed them while skimming but I still think it wouldn't hurt to summarize)</p>\n<ol dir=\"auto\">\n<li>How does <code class=\"notranslate\">type UserId = new number;</code> interact with <code class=\"notranslate\">extends</code> keyword? I assume UserId extends number (and all other nominal types will extend their parent types).</li>\n<li>Can you create nominal types from nominal types?</li>\n</ol>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"  type UUID  = new string;\n  type MessageId = new UUID;\"><pre class=\"notranslate\">  <span class=\"pl-k\">type</span> <span class=\"pl-smi\">UUID</span>  <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n  <span class=\"pl-k\">type</span> <span class=\"pl-smi\">MessageId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">UUID</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">All in all it seems to me that discussion around is reaching an end. I did notice that nominal types aren't in the 2021 first half roadmap but I assume that was just for the sake of being realistic?</p>",
        "createdAt": "2021-05-10T11:50:02Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-836600097",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 3
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc44OOYn",
        "author": {
          "login": "codeandcats"
        },
        "authorAssociation": "NONE",
        "body": "I'm wondering if TS 4.5 Beta's addition of [Private Field Presence Checks](https://devblogs.microsoft.com/typescript/announcing-typescript-4-5-beta/#private-field-presence-checks) improves the situation for nominal typing.\r\n\r\nFrom the docs:\r\n\r\n> You can now write a class with a #private field member and see whether another object has the same field by using the in operator.\r\n\r\n```ts\r\nclass Person {\r\n    #name: string;\r\n    constructor(name: string) {\r\n        this.#name = name;\r\n    }\r\n\r\n    equals(other: unknown) {\r\n        return other &&\r\n            typeof other === \"object\" &&\r\n            #name in other && // <- this is new!\r\n            this.#name === other.#name;\r\n    }\r\n}\r\n```\r\n\r\n> One interesting aspect of this feature is that the check #name in other implies that other must have been constructed as a Person, since there’s no other way that field could be present. This is actually one of the key features of the proposal, and it’s why the proposal is named “ergonomic brand checks” – because private fields often act as a “brand” to guard against objects that aren’t instances of their class. As such, TypeScript is able to appropriately narrow the type of other on each check, until it ends up with the type Person.\r\n\r\nI'm curious if this feature can improve in any way any of the examples mentioned in this thread or not",
        "bodyHTML": "<p dir=\"auto\">I'm wondering if TS 4.5 Beta's addition of <a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-4-5-beta/#private-field-presence-checks\" rel=\"nofollow\">Private Field Presence Checks</a> improves the situation for nominal typing.</p>\n<p dir=\"auto\">From the docs:</p>\n<blockquote>\n<p dir=\"auto\">You can now write a class with a #private field member and see whether another object has the same field by using the in operator.</p>\n</blockquote>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"class Person {\n    #name: string;\n    constructor(name: string) {\n        this.#name = name;\n    }\n\n    equals(other: unknown) {\n        return other &amp;&amp;\n            typeof other === &quot;object&quot; &amp;&amp;\n            #name in other &amp;&amp; // &lt;- this is new!\n            this.#name === other.#name;\n    }\n}\"><pre class=\"notranslate\"><span class=\"pl-k\">class</span> <span class=\"pl-smi\">Person</span> <span class=\"pl-kos\">{</span>\n    #name: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-en\">constructor</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">name</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n        <span class=\"pl-smi\">this</span><span class=\"pl-kos\">.</span>#name <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">name</span><span class=\"pl-kos\">;</span>\n    <span class=\"pl-kos\">}</span>\n\n    <span class=\"pl-en\">equals</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">other</span>: <span class=\"pl-smi\">unknown</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n        <span class=\"pl-k\">return</span> <span class=\"pl-s1\">other</span> <span class=\"pl-c1\">&amp;&amp;</span>\n            <span class=\"pl-k\">typeof</span> <span class=\"pl-s1\">other</span> <span class=\"pl-c1\">===</span> <span class=\"pl-s\">\"object\"</span> <span class=\"pl-c1\">&amp;&amp;</span>\n            #name <span class=\"pl-k\">in</span> <span class=\"pl-s1\">other</span> <span class=\"pl-c1\">&amp;&amp;</span> <span class=\"pl-c\">// &lt;- this is new!</span>\n            <span class=\"pl-smi\">this</span><span class=\"pl-kos\">.</span>#name <span class=\"pl-c1\">===</span> <span class=\"pl-s1\">other</span><span class=\"pl-kos\">.</span>#name<span class=\"pl-kos\">;</span>\n    <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<blockquote>\n<p dir=\"auto\">One interesting aspect of this feature is that the check #name in other implies that other must have been constructed as a Person, since there’s no other way that field could be present. This is actually one of the key features of the proposal, and it’s why the proposal is named “ergonomic brand checks” – because private fields often act as a “brand” to guard against objects that aren’t instances of their class. As such, TypeScript is able to appropriately narrow the type of other on each check, until it ends up with the type Person.</p>\n</blockquote>\n<p dir=\"auto\">I'm curious if this feature can improve in any way any of the examples mentioned in this thread or not</p>",
        "createdAt": "2021-10-14T11:07:31Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-943253031",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 3
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc45VLat",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "You can do something like (This is updated answer):\r\n\r\n```\r\nexport type Miles = number & { readonly '': unique symbol };\r\nexport type Kilograms = number & { readonly '': unique symbol }\r\nexport type MilesPerKilogram = number & { readonly '': unique symbol }\r\n\r\nvar a: Miles = 3; // error\r\nvar b: Kilograms = 3; // error\r\nvar c: MilesPerKilogram = x / y; // error\r\n\r\na = b; // error\r\n\r\nvar x: Miles = 3 as Miles; // ok\r\nvar y: Kilograms = 3 as Kilograms; // ok\r\nvar u: MilesPerKilogram = x / y as MilesPerKilogram; // ok\r\n```\r\n\r\n[See code](https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBDAnmYcCyBLANsAznAXjgDsBXAWwCNgo4AyOAbzimAEMATCYrROAcn4AuOKWIYAjqVS5EVCFjgBfANwAoUJFgJkqANLYIAcyhty+ImSo16TFuy48+gkWMnS4s+YtUbw0eCQUdGw8AAUaAyxjU3JCEgpqWgZmVk5uXgFhUXEpGTlKBWV1NQA3Nlo2EUwcCzgAZhU4AHpmuBooaDKKuEoRKJizOsaWto6u8toAY2rQ3AioAZMzeJAWuEQm1vaoTqg1NTZ4yibRnb2DybgQWdr4+rg2fBq8LbaIAGtu2kR+w2XzPdHvglrFcG84J9vqJbuFIv9Yqt1nwniFagtQWYIZ8gA)\r\n\r\nBe careful though as you are not allowed to wrap nominal type declaration into a separate type as in such case a unique symbol will be shared across all type usages which would essentially share type \"nominality\" and thus beat it's original purpose.\r\n\r\n```\r\nexport type Nominal<T> = T & { readonly '': unique symbol };\r\n\r\nexport type Miles = Nominal<number>;\r\nexport type Kilograms = Nominal<number>;\r\nexport type MilesPerKilogram = Nominal<number>;\r\n\r\nvar a: Miles = 3; // error\r\nvar b: Kilograms = 3; // error\r\nvar c: MilesPerKilogram = x / y; // error\r\n\r\nvar x: Miles = 3 as Miles; // ok\r\nvar y: Kilograms = 3 as Kilograms; // ok\r\nvar u: MilesPerKilogram = x / y as MilesPerKilogram; // ok\r\n\r\na = b; // ok, but it should be error! <========================= This is due to declaration of Nominal<T>\r\n\r\n```\r\n\r\n[See code](https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBDAnmYcByEC2BLAdgQwBsAeAFQD44BeOUuAMjgG84ph8ATCXQxOAcn4AuOAFdc2AI6jUAZ0SYARhEJwAvgG4AUFtCRYCZKgCy2QsFnV0WPEWK5RS4FHLa90eEhRwA0mYgA5lD4mJY0GDgEJA5OLm7gHobepuayAArOfoSBwZhWEbbRjorOrjoAbvhQcPgiKRZWAMwacAD0rXDOUNBaldWKIlk5IWFwzW0dXT19cADGdWYWGVBDQSFWIG1wiC3tnVDdUBVVcCALqU01lvWyux0QANa9J4iD-muhl-iWq7m3E3BHs9qqJzktMu9chstnxvnAbstfiE7oCnlp8FZFCjHgAaOCKUTwbDwWQACwgokIHHxqCmUAAhHBiFQWay2eyOWzaKTsJZeXAODIEBABcBZoQqvgYNhuICAGbWSJ2ChaIA)\r\n\r\nThe suggested solution is still far from being perfect but covered most of my use-cases I had chance to face",
        "bodyHTML": "<p dir=\"auto\">You can do something like (This is updated answer):</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"export type Miles = number &amp; { readonly '': unique symbol };\nexport type Kilograms = number &amp; { readonly '': unique symbol }\nexport type MilesPerKilogram = number &amp; { readonly '': unique symbol }\n\nvar a: Miles = 3; // error\nvar b: Kilograms = 3; // error\nvar c: MilesPerKilogram = x / y; // error\n\na = b; // error\n\nvar x: Miles = 3 as Miles; // ok\nvar y: Kilograms = 3 as Kilograms; // ok\nvar u: MilesPerKilogram = x / y as MilesPerKilogram; // ok\"><pre class=\"notranslate\"><code class=\"notranslate\">export type Miles = number &amp; { readonly '': unique symbol };\nexport type Kilograms = number &amp; { readonly '': unique symbol }\nexport type MilesPerKilogram = number &amp; { readonly '': unique symbol }\n\nvar a: Miles = 3; // error\nvar b: Kilograms = 3; // error\nvar c: MilesPerKilogram = x / y; // error\n\na = b; // error\n\nvar x: Miles = 3 as Miles; // ok\nvar y: Kilograms = 3 as Kilograms; // ok\nvar u: MilesPerKilogram = x / y as MilesPerKilogram; // ok\n</code></pre></div>\n<p dir=\"auto\"><a href=\"https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBDAnmYcCyBLANsAznAXjgDsBXAWwCNgo4AyOAbzimAEMATCYrROAcn4AuOKWIYAjqVS5EVCFjgBfANwAoUJFgJkqANLYIAcyhty+ImSo16TFuy48+gkWMnS4s+YtUbw0eCQUdGw8AAUaAyxjU3JCEgpqWgZmVk5uXgFhUXEpGTlKBWV1NQA3Nlo2EUwcCzgAZhU4AHpmuBooaDKKuEoRKJizOsaWto6u8toAY2rQ3AioAZMzeJAWuEQm1vaoTqg1NTZ4yibRnb2DybgQWdr4+rg2fBq8LbaIAGtu2kR+w2XzPdHvglrFcG84J9vqJbuFIv9Yqt1nwniFagtQWYIZ8gA\" rel=\"nofollow\">See code</a></p>\n<p dir=\"auto\">Be careful though as you are not allowed to wrap nominal type declaration into a separate type as in such case a unique symbol will be shared across all type usages which would essentially share type \"nominality\" and thus beat it's original purpose.</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"export type Nominal&lt;T&gt; = T &amp; { readonly '': unique symbol };\n\nexport type Miles = Nominal&lt;number&gt;;\nexport type Kilograms = Nominal&lt;number&gt;;\nexport type MilesPerKilogram = Nominal&lt;number&gt;;\n\nvar a: Miles = 3; // error\nvar b: Kilograms = 3; // error\nvar c: MilesPerKilogram = x / y; // error\n\nvar x: Miles = 3 as Miles; // ok\nvar y: Kilograms = 3 as Kilograms; // ok\nvar u: MilesPerKilogram = x / y as MilesPerKilogram; // ok\n\na = b; // ok, but it should be error! &lt;========================= This is due to declaration of Nominal&lt;T&gt;\n\"><pre class=\"notranslate\"><code class=\"notranslate\">export type Nominal&lt;T&gt; = T &amp; { readonly '': unique symbol };\n\nexport type Miles = Nominal&lt;number&gt;;\nexport type Kilograms = Nominal&lt;number&gt;;\nexport type MilesPerKilogram = Nominal&lt;number&gt;;\n\nvar a: Miles = 3; // error\nvar b: Kilograms = 3; // error\nvar c: MilesPerKilogram = x / y; // error\n\nvar x: Miles = 3 as Miles; // ok\nvar y: Kilograms = 3 as Kilograms; // ok\nvar u: MilesPerKilogram = x / y as MilesPerKilogram; // ok\n\na = b; // ok, but it should be error! &lt;========================= This is due to declaration of Nominal&lt;T&gt;\n\n</code></pre></div>\n<p dir=\"auto\"><a href=\"https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBDAnmYcByEC2BLAdgQwBsAeAFQD44BeOUuAMjgG84ph8ATCXQxOAcn4AuOAFdc2AI6jUAZ0SYARhEJwAvgG4AUFtCRYCZKgCy2QsFnV0WPEWK5RS4FHLa90eEhRwA0mYgA5lD4mJY0GDgEJA5OLm7gHobepuayAArOfoSBwZhWEbbRjorOrjoAbvhQcPgiKRZWAMwacAD0rXDOUNBaldWKIlk5IWFwzW0dXT19cADGdWYWGVBDQSFWIG1wiC3tnVDdUBVVcCALqU01lvWyux0QANa9J4iD-muhl-iWq7m3E3BHs9qqJzktMu9chstnxvnAbstfiE7oCnlp8FZFCjHgAaOCKUTwbDwWQACwgokIHHxqCmUAAhHBiFQWay2eyOWzaKTsJZeXAODIEBABcBZoQqvgYNhuICAGbWSJ2ChaIA\" rel=\"nofollow\">See code</a></p>\n<p dir=\"auto\">The suggested solution is still far from being perfect but covered most of my use-cases I had chance to face</p>",
        "createdAt": "2021-11-05T12:23:35Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-961853101",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc45VyPX",
        "author": {
          "login": "Janpot"
        },
        "authorAssociation": "NONE",
        "body": "I usually do [a variation](https://www.typescriptlang.org/play?#code/CYUwxgNghgTiAEYD2A7AzgF3hgXPArigJYCO+CaAngLYBGSEA3AFAgAeADkjFhpRwgBySakRRQIAHgAqAPngBeeNPgAyeAG94cKMFQRK8ANoYAunkKly8KnQbwAvi1aduvfggCyRCCDSL4YVFxKRR8OhAYWRZ2Lh5sD3gAaR8kAHMYKGp-JSCxCUkwiKiY13i+AXhvXzQABUiUiHTM6gC8kMLw2kjo5mYAN1h4KDxqvwCAZkZ4AHoZ+EiYbgGh2jxG5qyc+CnZ+cXlwZhEUZ8-epgNjKyAtln4Smm5hZglmD6j+DZTmsnh-zGaCe8yQAGsVsdKOtUtdsn8oP4ri0gXt4GCIQQfucGjCWrd7oYEVUznUcU1YcC0aCgA) on that:\r\n```ts\r\ndeclare const t: unique symbol;\r\nexport type Nominal<T> = T & { readonly [t]: unique symbol };\r\n```\r\n\r\n_edit_\r\n\r\nActually, after reading the comments below, I checked my actual code again and I'm doing something different indeed 🙂. Still allows assignment of primitives though.\r\n```ts\r\ndeclare const t: unique symbol;\r\nexport type Nominal<T, U> = T & { readonly [t]: U };\r\n\r\ntype Miles = Nominal<number, 'Miles'>\r\ntype Kilometers = Nominal<number, 'Kilometers'>\r\n```",
        "bodyHTML": "<p dir=\"auto\">I usually do <a href=\"https://www.typescriptlang.org/play?#code/CYUwxgNghgTiAEYD2A7AzgF3hgXPArigJYCO+CaAngLYBGSEA3AFAgAeADkjFhpRwgBySakRRQIAHgAqAPngBeeNPgAyeAG94cKMFQRK8ANoYAunkKly8KnQbwAvi1aduvfggCyRCCDSL4YVFxKRR8OhAYWRZ2Lh5sD3gAaR8kAHMYKGp-JSCxCUkwiKiY13i+AXhvXzQABUiUiHTM6gC8kMLw2kjo5mYAN1h4KDxqvwCAZkZ4AHoZ+EiYbgGh2jxG5qyc+CnZ+cXlwZhEUZ8-epgNjKyAtln4Smm5hZglmD6j+DZTmsnh-zGaCe8yQAGsVsdKOtUtdsn8oP4ri0gXt4GCIQQfucGjCWrd7oYEVUznUcU1YcC0aCgA\" rel=\"nofollow\">a variation</a> on that:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"declare const t: unique symbol;\nexport type Nominal&lt;T&gt; = T &amp; { readonly [t]: unique symbol };\"><pre class=\"notranslate\"><span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">t</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-kos\">[</span><span class=\"pl-s1\">t</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\"><em>edit</em></p>\n<p dir=\"auto\">Actually, after reading the comments below, I checked my actual code again and I'm doing something different indeed 🙂. Still allows assignment of primitives though.</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"declare const t: unique symbol;\nexport type Nominal&lt;T, U&gt; = T &amp; { readonly [t]: U };\n\ntype Miles = Nominal&lt;number, 'Miles'&gt;\ntype Kilometers = Nominal&lt;number, 'Kilometers'&gt;\"><pre class=\"notranslate\"><span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">t</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">U</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-kos\">[</span><span class=\"pl-s1\">t</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">U</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Miles</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'Miles'</span><span class=\"pl-kos\">&gt;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Kilometers</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">number</span><span class=\"pl-kos\">,</span> <span class=\"pl-s\">'Kilometers'</span><span class=\"pl-kos\">&gt;</span></pre></div>",
        "createdAt": "2021-11-05T15:55:35Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-962012119",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc45V2iO",
        "author": {
          "login": "evelant"
        },
        "authorAssociation": "NONE",
        "body": "@Janpot @lu4 doesn't that allow assigning any nominal type to any other nominal type that structurally matches? For example:\r\n\r\n```\r\ntype Nominal<T> = T & { readonly [t]: unique symbol }\r\n\r\ntype Miles = Nominal<number>\r\ntype Kilometers = Nominal<number>\r\n\r\nlet distanceInMiles: Miles = 3 as Miles\r\nlet distanceInKm = 4.83 as Kilometers\r\n\r\n//uhoh, TS lets us assign kilometers to miles, that doesn't make sense\r\ndistanceInMiles = distanceInKm\r\n\r\nif (distanceInMiles <= 3) {\r\n    //Uhoh, the probe is going to crash into mars because we were allowed to accidentally assign KM to miles\r\n   //which actually happened once https://en.wikipedia.org/wiki/Mars_Climate_Orbiter\r\n    adjustOrbitalDescentTrajectory()\r\n}\r\n```\r\n\r\nedit:\r\nThe solution proposed by @bendman works as expected\r\n```\r\ntype Nominal<Name extends string, Tag, Type = {}> = Type & {\r\n    readonly __tuid__: { name: Name; tag: Tag }\r\n}\r\n\r\ntype Miles = Nominal<\"Miles\", { readonly id: unique symbol }, number>\r\ntype Kilometers = Nominal<\"Kilometers\", { readonly id: unique symbol }, number>\r\n\r\nlet distanceInMiles: Miles = 3 as Miles\r\nlet distanceInKm = 4.83 as Kilometers\r\n\r\n//this is not assignable, good!\r\ndistanceInMiles = distanceInKm\r\n//Type 'Kilometers' is not assignable to type 'Miles'.\r\n//  Type 'Kilometers' is not assignable to type '{ readonly __tuid__: { name: \"Miles\"; tag: { readonly id: unique symbol; }; //}; }'.\r\n//    The types of '__tuid__.name' are incompatible between these types.\r\n//      Type '\"Kilometers\"' is not assignable to type '\"Miles\"'.ts(2322)\r\n```\r\n\r\nedit2:\r\n\r\nThat solution does however allow comparison of nominal types with primitive types without an error which could cause bugs\r\n\r\n```\r\ntype Miles = Nominal<\"Miles\", { readonly id: unique symbol }, number>\r\ntype Kilometers = Nominal<\"Kilometers\", { readonly id: unique symbol }, number>\r\n\r\nlet distanceInKm: Kilometers = 4.83 as Kilometers\r\nlet distanceInMiles: Miles = 3 as Miles\r\n\r\n//TS doesn't allow comparison of two nominal types, \"Miles and Kilometers have no overlap\"\r\nif (distanceInMiles === distanceInKm) {\r\n}\r\n\r\n//TS allows a comparison of number to Miles, but not assignment\r\n// it would be good to have an error here as it is likely a bug\r\nlet amountOfFuel = 12452\r\nif (distanceInMiles === amountOfFuel) {\r\n}\r\n```",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Janpot/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Janpot\">@Janpot</a> <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lu4/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lu4\">@lu4</a> doesn't that allow assigning any nominal type to any other nominal type that structurally matches? For example:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"type Nominal&lt;T&gt; = T &amp; { readonly [t]: unique symbol }\n\ntype Miles = Nominal&lt;number&gt;\ntype Kilometers = Nominal&lt;number&gt;\n\nlet distanceInMiles: Miles = 3 as Miles\nlet distanceInKm = 4.83 as Kilometers\n\n//uhoh, TS lets us assign kilometers to miles, that doesn't make sense\ndistanceInMiles = distanceInKm\n\nif (distanceInMiles &lt;= 3) {\n    //Uhoh, the probe is going to crash into mars because we were allowed to accidentally assign KM to miles\n   //which actually happened once https://en.wikipedia.org/wiki/Mars_Climate_Orbiter\n    adjustOrbitalDescentTrajectory()\n}\"><pre class=\"notranslate\"><code class=\"notranslate\">type Nominal&lt;T&gt; = T &amp; { readonly [t]: unique symbol }\n\ntype Miles = Nominal&lt;number&gt;\ntype Kilometers = Nominal&lt;number&gt;\n\nlet distanceInMiles: Miles = 3 as Miles\nlet distanceInKm = 4.83 as Kilometers\n\n//uhoh, TS lets us assign kilometers to miles, that doesn't make sense\ndistanceInMiles = distanceInKm\n\nif (distanceInMiles &lt;= 3) {\n    //Uhoh, the probe is going to crash into mars because we were allowed to accidentally assign KM to miles\n   //which actually happened once https://en.wikipedia.org/wiki/Mars_Climate_Orbiter\n    adjustOrbitalDescentTrajectory()\n}\n</code></pre></div>\n<p dir=\"auto\">edit:<br>\nThe solution proposed by <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/bendman/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/bendman\">@bendman</a> works as expected</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"type Nominal&lt;Name extends string, Tag, Type = {}&gt; = Type &amp; {\n    readonly __tuid__: { name: Name; tag: Tag }\n}\n\ntype Miles = Nominal&lt;&quot;Miles&quot;, { readonly id: unique symbol }, number&gt;\ntype Kilometers = Nominal&lt;&quot;Kilometers&quot;, { readonly id: unique symbol }, number&gt;\n\nlet distanceInMiles: Miles = 3 as Miles\nlet distanceInKm = 4.83 as Kilometers\n\n//this is not assignable, good!\ndistanceInMiles = distanceInKm\n//Type 'Kilometers' is not assignable to type 'Miles'.\n//  Type 'Kilometers' is not assignable to type '{ readonly __tuid__: { name: &quot;Miles&quot;; tag: { readonly id: unique symbol; }; //}; }'.\n//    The types of '__tuid__.name' are incompatible between these types.\n//      Type '&quot;Kilometers&quot;' is not assignable to type '&quot;Miles&quot;'.ts(2322)\"><pre class=\"notranslate\"><code class=\"notranslate\">type Nominal&lt;Name extends string, Tag, Type = {}&gt; = Type &amp; {\n    readonly __tuid__: { name: Name; tag: Tag }\n}\n\ntype Miles = Nominal&lt;\"Miles\", { readonly id: unique symbol }, number&gt;\ntype Kilometers = Nominal&lt;\"Kilometers\", { readonly id: unique symbol }, number&gt;\n\nlet distanceInMiles: Miles = 3 as Miles\nlet distanceInKm = 4.83 as Kilometers\n\n//this is not assignable, good!\ndistanceInMiles = distanceInKm\n//Type 'Kilometers' is not assignable to type 'Miles'.\n//  Type 'Kilometers' is not assignable to type '{ readonly __tuid__: { name: \"Miles\"; tag: { readonly id: unique symbol; }; //}; }'.\n//    The types of '__tuid__.name' are incompatible between these types.\n//      Type '\"Kilometers\"' is not assignable to type '\"Miles\"'.ts(2322)\n</code></pre></div>\n<p dir=\"auto\">edit2:</p>\n<p dir=\"auto\">That solution does however allow comparison of nominal types with primitive types without an error which could cause bugs</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"type Miles = Nominal&lt;&quot;Miles&quot;, { readonly id: unique symbol }, number&gt;\ntype Kilometers = Nominal&lt;&quot;Kilometers&quot;, { readonly id: unique symbol }, number&gt;\n\nlet distanceInKm: Kilometers = 4.83 as Kilometers\nlet distanceInMiles: Miles = 3 as Miles\n\n//TS doesn't allow comparison of two nominal types, &quot;Miles and Kilometers have no overlap&quot;\nif (distanceInMiles === distanceInKm) {\n}\n\n//TS allows a comparison of number to Miles, but not assignment\n// it would be good to have an error here as it is likely a bug\nlet amountOfFuel = 12452\nif (distanceInMiles === amountOfFuel) {\n}\"><pre class=\"notranslate\"><code class=\"notranslate\">type Miles = Nominal&lt;\"Miles\", { readonly id: unique symbol }, number&gt;\ntype Kilometers = Nominal&lt;\"Kilometers\", { readonly id: unique symbol }, number&gt;\n\nlet distanceInKm: Kilometers = 4.83 as Kilometers\nlet distanceInMiles: Miles = 3 as Miles\n\n//TS doesn't allow comparison of two nominal types, \"Miles and Kilometers have no overlap\"\nif (distanceInMiles === distanceInKm) {\n}\n\n//TS allows a comparison of number to Miles, but not assignment\n// it would be good to have an error here as it is likely a bug\nlet amountOfFuel = 12452\nif (distanceInMiles === amountOfFuel) {\n}\n</code></pre></div>",
        "createdAt": "2021-11-05T16:17:27Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-962029710",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc45Wg-V",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "@AndrewMorsillo Pardon me, I've did some optimizations in the process of preparing an answer and haven't checked for correctness. The proper version of code would look like this:\r\n\r\n```\r\nexport type Miles = number & { readonly '': unique symbol };\r\nexport type Kilograms = number & { readonly '': unique symbol };\r\nexport type MilesPerKilogram = number & { readonly '': unique symbol };\r\n\r\nvar a: Miles = 3; // error\r\nvar b: Kilograms = 3; // error\r\nvar c: MilesPerKilogram = x / y; // error\r\n\r\na = b; // error\r\n\r\nvar x: Miles = 3 as Miles; // ok\r\nvar y: Kilograms = 3 as Kilograms; // ok\r\nvar u: MilesPerKilogram = x / y as MilesPerKilogram; // ok\r\n```\r\n\r\n[See code](https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBDAnmYcCyBLANsAznAXjgDsBXAWwCNgo4AyOAbzimAEMATCYrROAcn4AuOKWIYAjqVS5EVCFjgBfANwAoUJFgJkqANLYIAcyhty+ImSo16TFuy48+gkWMnS4s+YtUbw0eCQUdGw8AAUaAyxjU3JCEgpqWgZmVk5uXgFhUXEpGTlKBWV1NQA3Nlo2EUwcCzgAZhU4AHpmuBooaDKKuEoRKJizOsaWto6u8toAY2rQ3AioAZMzeJAWuEQm1vaoTqg1NTZ4yibRnb2DybgQWdr4+rg2fBq8LbaIAGtu2kR+w2XzPdHvglrFcG84J9vqJbuFIv9Yqt1nwniFagtQWYIZ8gA)\r\n\r\nI will update original answer to reduce confusion",
        "bodyHTML": "<p dir=\"auto\">@AndrewMorsillo Pardon me, I've did some optimizations in the process of preparing an answer and haven't checked for correctness. The proper version of code would look like this:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"export type Miles = number &amp; { readonly '': unique symbol };\nexport type Kilograms = number &amp; { readonly '': unique symbol };\nexport type MilesPerKilogram = number &amp; { readonly '': unique symbol };\n\nvar a: Miles = 3; // error\nvar b: Kilograms = 3; // error\nvar c: MilesPerKilogram = x / y; // error\n\na = b; // error\n\nvar x: Miles = 3 as Miles; // ok\nvar y: Kilograms = 3 as Kilograms; // ok\nvar u: MilesPerKilogram = x / y as MilesPerKilogram; // ok\"><pre class=\"notranslate\"><code class=\"notranslate\">export type Miles = number &amp; { readonly '': unique symbol };\nexport type Kilograms = number &amp; { readonly '': unique symbol };\nexport type MilesPerKilogram = number &amp; { readonly '': unique symbol };\n\nvar a: Miles = 3; // error\nvar b: Kilograms = 3; // error\nvar c: MilesPerKilogram = x / y; // error\n\na = b; // error\n\nvar x: Miles = 3 as Miles; // ok\nvar y: Kilograms = 3 as Kilograms; // ok\nvar u: MilesPerKilogram = x / y as MilesPerKilogram; // ok\n</code></pre></div>\n<p dir=\"auto\"><a href=\"https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBDAnmYcCyBLANsAznAXjgDsBXAWwCNgo4AyOAbzimAEMATCYrROAcn4AuOKWIYAjqVS5EVCFjgBfANwAoUJFgJkqANLYIAcyhty+ImSo16TFuy48+gkWMnS4s+YtUbw0eCQUdGw8AAUaAyxjU3JCEgpqWgZmVk5uXgFhUXEpGTlKBWV1NQA3Nlo2EUwcCzgAZhU4AHpmuBooaDKKuEoRKJizOsaWto6u8toAY2rQ3AioAZMzeJAWuEQm1vaoTqg1NTZ4yibRnb2DybgQWdr4+rg2fBq8LbaIAGtu2kR+w2XzPdHvglrFcG84J9vqJbuFIv9Yqt1nwniFagtQWYIZ8gA\" rel=\"nofollow\">See code</a></p>\n<p dir=\"auto\">I will update original answer to reduce confusion</p>",
        "createdAt": "2021-11-05T20:34:04Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-962203541",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc45WlCs",
        "author": {
          "login": "evelant"
        },
        "authorAssociation": "NONE",
        "body": "@lu4 That certainly works better but it still allows comparison of nominal types to primitives, for example:\r\n\r\n```\r\nlet distance: Miles = 3 as Miles; // ok\r\nlet fuelWeight = 3583\r\n//uhoh, probably not what was intended but no error when comparing number to Miles!\r\nif(distance < fuelWeight){\r\n}\r\n```\r\n\r\nI think maybe this technique suggested above is the best we can get right now but still not perfect\r\n```\r\ninterface NominalNumber<T extends string> extends Number {\r\n  readonly __typeName: T;\r\n}\r\n\r\ntype Miles = NominalNumber<\"miles\">\r\ntype Kilograms = NominalNumber<\"kilograms\">\r\n\r\n//Error: Type 'number' is not assignable to type 'Miles'\r\nlet x: Miles = 3\r\n//Error: Conversion of type 'number' to type 'Miles' may be a mistake because neither type sufficiently overlaps with the other.\r\nlet y = 3 as Miles\r\n\r\n//OK\r\nlet distance = 3 as unknown as Miles\r\nlet weight = 10 as unknown as Kilograms\r\n\r\n//Error: Type 'Kilograms' is not assignable to type 'Miles'\r\ndistance = weight\r\n\r\n//Error: This condition will always return 'false' since the types 'Miles' and 'Kilograms' have no overlap.\r\nif(distance === weight){}\r\n\r\nlet durationSeconds = 3\r\n//Better! No accidental comparison of raw numbers to Miles\r\n//Error: This condition will always return 'false' since the types 'Miles' and 'number' have no overlap.\r\nif(distance === durationSeconds){}\r\n\r\n//But still not great because we can make asssignment mistakes due to \"as unknown\"\r\n//No error here. Would be better if TS would ensure we at least have a number when casting to Miles.\r\nlet badDistance = \"uhoh\" as unknown as Miles\r\n//Looks like this is unavoidable with this technique until as have more fine grained type assertion operator\r\n//https://github.com/microsoft/TypeScript/issues/7481\r\n```\r\n\r\n[playground link](https://www.typescriptlang.org/play?ts=4.5.0-beta&ssl=30&ssc=45&pln=1&pc=1#code/JYOwLgpgTgZghgYwgAgHIHsC2o4BtUCumARtADwAqyEAHpCACYDOyTYUoA5gHzV0SMWhEtGQBvAFDJkUCHAboQuAJ7IA+mrDKADhFRxMEAFzIKAbgkBfCRK27kAWWC4ILALxosOfEVJQyAETYLkwB3LY6KADSzuicUAbuntggeMJ+gQDWsfGJYTYA9AUAolBQ6FAmFJHIAOQgvtC1yMAsIOhgyHBMTMCcqcQuyGDowzW1TiG1Ei6dNCaTrsgeAMwSRaXllcgAwooAbtC9isjoMGP29Y1QzSMXKBPOrs2YcKqkXcjYbHCZKKQIOAEJgoEAQYBgAAWojsKCYBBgMGACGAAjAKlOhyguDg2hYAHcIZDhtDTlDoAA6GYQTqqVZdFiLJiFAoAeSi1M6DFaYDgICQy2QKwZyAIIEy7XxIBFTM5yHx4M4kM6HgAjAAGEViiXoKUimK4OIJTDM9YlMoVKrjA1GxLNVrIdqdbq9fpwQYoO6wupM6bcn78lAeBV9ZUszaW0yQh0IRTcsDAE6E3C4Lq4fFvFiyMAEKDS2rwXAg5q9QMkz2RFiPKZdRh1G25E3NSFwQ6O0boLE47RU4AwAAU-t5Zbco-liuVAEoxNY5Qxc3AE4oAMoQWOCQVrIoAIRpkCgAEJPF0ECiGGi8MhY5htHAOEwTmcZHB8Y7riw7rKNhbthRoyx13jRNpWTVM8AzZQsxpXN80LYtWFAAVyXuKtfVrBg6gaEQbmQFs23aTFoG7XsByHPkBVHDx5wSJcQFXQCmGnWcdwITo2GcVMnWQeI5E6AEgRBccrz5L5fhQF1XRAQxwC+HkxJYedPVGAJulFcVJRAAIzQwagf1w6AIDlYh5AAETkkdkACAhIXQSEAi1dTdWlVTZQkIA)",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lu4/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lu4\">@lu4</a> That certainly works better but it still allows comparison of nominal types to primitives, for example:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"let distance: Miles = 3 as Miles; // ok\nlet fuelWeight = 3583\n//uhoh, probably not what was intended but no error when comparing number to Miles!\nif(distance &lt; fuelWeight){\n}\"><pre class=\"notranslate\"><code class=\"notranslate\">let distance: Miles = 3 as Miles; // ok\nlet fuelWeight = 3583\n//uhoh, probably not what was intended but no error when comparing number to Miles!\nif(distance &lt; fuelWeight){\n}\n</code></pre></div>\n<p dir=\"auto\">I think maybe this technique suggested above is the best we can get right now but still not perfect</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"interface NominalNumber&lt;T extends string&gt; extends Number {\n  readonly __typeName: T;\n}\n\ntype Miles = NominalNumber&lt;&quot;miles&quot;&gt;\ntype Kilograms = NominalNumber&lt;&quot;kilograms&quot;&gt;\n\n//Error: Type 'number' is not assignable to type 'Miles'\nlet x: Miles = 3\n//Error: Conversion of type 'number' to type 'Miles' may be a mistake because neither type sufficiently overlaps with the other.\nlet y = 3 as Miles\n\n//OK\nlet distance = 3 as unknown as Miles\nlet weight = 10 as unknown as Kilograms\n\n//Error: Type 'Kilograms' is not assignable to type 'Miles'\ndistance = weight\n\n//Error: This condition will always return 'false' since the types 'Miles' and 'Kilograms' have no overlap.\nif(distance === weight){}\n\nlet durationSeconds = 3\n//Better! No accidental comparison of raw numbers to Miles\n//Error: This condition will always return 'false' since the types 'Miles' and 'number' have no overlap.\nif(distance === durationSeconds){}\n\n//But still not great because we can make asssignment mistakes due to &quot;as unknown&quot;\n//No error here. Would be better if TS would ensure we at least have a number when casting to Miles.\nlet badDistance = &quot;uhoh&quot; as unknown as Miles\n//Looks like this is unavoidable with this technique until as have more fine grained type assertion operator\n//https://github.com/microsoft/TypeScript/issues/7481\"><pre class=\"notranslate\"><code class=\"notranslate\">interface NominalNumber&lt;T extends string&gt; extends Number {\n  readonly __typeName: T;\n}\n\ntype Miles = NominalNumber&lt;\"miles\"&gt;\ntype Kilograms = NominalNumber&lt;\"kilograms\"&gt;\n\n//Error: Type 'number' is not assignable to type 'Miles'\nlet x: Miles = 3\n//Error: Conversion of type 'number' to type 'Miles' may be a mistake because neither type sufficiently overlaps with the other.\nlet y = 3 as Miles\n\n//OK\nlet distance = 3 as unknown as Miles\nlet weight = 10 as unknown as Kilograms\n\n//Error: Type 'Kilograms' is not assignable to type 'Miles'\ndistance = weight\n\n//Error: This condition will always return 'false' since the types 'Miles' and 'Kilograms' have no overlap.\nif(distance === weight){}\n\nlet durationSeconds = 3\n//Better! No accidental comparison of raw numbers to Miles\n//Error: This condition will always return 'false' since the types 'Miles' and 'number' have no overlap.\nif(distance === durationSeconds){}\n\n//But still not great because we can make asssignment mistakes due to \"as unknown\"\n//No error here. Would be better if TS would ensure we at least have a number when casting to Miles.\nlet badDistance = \"uhoh\" as unknown as Miles\n//Looks like this is unavoidable with this technique until as have more fine grained type assertion operator\n//https://github.com/microsoft/TypeScript/issues/7481\n</code></pre></div>\n<p dir=\"auto\"><a href=\"https://www.typescriptlang.org/play?ts=4.5.0-beta&amp;ssl=30&amp;ssc=45&amp;pln=1&amp;pc=1#code/JYOwLgpgTgZghgYwgAgHIHsC2o4BtUCumARtADwAqyEAHpCACYDOyTYUoA5gHzV0SMWhEtGQBvAFDJkUCHAboQuAJ7IA+mrDKADhFRxMEAFzIKAbgkBfCRK27kAWWC4ILALxosOfEVJQyAETYLkwB3LY6KADSzuicUAbuntggeMJ+gQDWsfGJYTYA9AUAolBQ6FAmFJHIAOQgvtC1yMAsIOhgyHBMTMCcqcQuyGDowzW1TiG1Ei6dNCaTrsgeAMwSRaXllcgAwooAbtC9isjoMGP29Y1QzSMXKBPOrs2YcKqkXcjYbHCZKKQIOAEJgoEAQYBgAAWojsKCYBBgMGACGAAjAKlOhyguDg2hYAHcIZDhtDTlDoAA6GYQTqqVZdFiLJiFAoAeSi1M6DFaYDgICQy2QKwZyAIIEy7XxIBFTM5yHx4M4kM6HgAjAAGEViiXoKUimK4OIJTDM9YlMoVKrjA1GxLNVrIdqdbq9fpwQYoO6wupM6bcn78lAeBV9ZUszaW0yQh0IRTcsDAE6E3C4Lq4fFvFiyMAEKDS2rwXAg5q9QMkz2RFiPKZdRh1G25E3NSFwQ6O0boLE47RU4AwAAU-t5Zbco-liuVAEoxNY5Qxc3AE4oAMoQWOCQVrIoAIRpkCgAEJPF0ECiGGi8MhY5htHAOEwTmcZHB8Y7riw7rKNhbthRoyx13jRNpWTVM8AzZQsxpXN80LYtWFAAVyXuKtfVrBg6gaEQbmQFs23aTFoG7XsByHPkBVHDx5wSJcQFXQCmGnWcdwITo2GcVMnWQeI5E6AEgRBccrz5L5fhQF1XRAQxwC+HkxJYedPVGAJulFcVJRAAIzQwagf1w6AIDlYh5AAETkkdkACAhIXQSEAi1dTdWlVTZQkIA\" rel=\"nofollow\">playground link</a></p>",
        "createdAt": "2021-11-05T21:06:44Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-962220204",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc45WnTY",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "Ahh, yes that is unfortunate truth... But hey, you are free to choose from several solutions. There's also this book https://basarat.gitbook.io/typescript/main-1/nominaltyping where Nominal typing is discussed they have several other \r\napproaches that may be useful for you. In my case I was looking for more or less clean (in terms of declaration and in terms of IDE list of suggestions pollution) way of declaring nominal types and it suited me. It was not related to arithmetic code but rather it became handy when declaring database `ID` fields. Compiler happily shows errors in places where extreme precaution is required.",
        "bodyHTML": "<p dir=\"auto\">Ahh, yes that is unfortunate truth... But hey, you are free to choose from several solutions. There's also this book <a href=\"https://basarat.gitbook.io/typescript/main-1/nominaltyping\" rel=\"nofollow\">https://basarat.gitbook.io/typescript/main-1/nominaltyping</a> where Nominal typing is discussed they have several other<br>\napproaches that may be useful for you. In my case I was looking for more or less clean (in terms of declaration and in terms of IDE list of suggestions pollution) way of declaring nominal types and it suited me. It was not related to arithmetic code but rather it became handy when declaring database <code class=\"notranslate\">ID</code> fields. Compiler happily shows errors in places where extreme precaution is required.</p>",
        "createdAt": "2021-11-05T21:23:07Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-962229464",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc45Wpaz",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "Giving more thought to it @AndrewMorsillo why wouldn't it be possible to compare or perform other mathematical operations on incompatible types. You are free to divide miles over gallons in which case you should get a Miles Per Gallon. Like with taking a square root of a negative number it depends on the context where mathematical operation is used. Same thinking goes to comparison operators we actually can compare mosquito to an elephant in some context, say size, but not in some other. Thus one can impose definitive restrictions only on assignment... This is where one can be absolutely sure about the check in any context.",
        "bodyHTML": "<p dir=\"auto\">Giving more thought to it @AndrewMorsillo why wouldn't it be possible to compare or perform other mathematical operations on incompatible types. You are free to divide miles over gallons in which case you should get a Miles Per Gallon. Like with taking a square root of a negative number it depends on the context where mathematical operation is used. Same thinking goes to comparison operators we actually can compare mosquito to an elephant in some context, say size, but not in some other. Thus one can impose definitive restrictions only on assignment... This is where one can be absolutely sure about the check in any context.</p>",
        "createdAt": "2021-11-05T21:40:05Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-962238131",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc49GlUS",
        "author": {
          "login": "evelant"
        },
        "authorAssociation": "NONE",
        "body": "@lu4 It certainly makes sense to perform operations on incompatible nominal types but IMO in order to prevent bugs and have safety it's best to be forced to be explicit about any operations involving differing types. \r\n\r\nIt makes sense to operate on differing types like Miles / Gallons but most of the time I think it _only_ makes sense on a per-context basis. For example `const speed = Miles / Gallons` would be a bug since Miles/Gallons clearly isn't a representation of speed as intended -- if you allow these operations without warning it's easy to introduce bugs. \r\n\r\nWhen you can implicitly do operations on types with similar data but different or contextually important meanings it's easy to end up [crashing into the surface of mars](https://en.wikipedia.org/wiki/Mars_Climate_Orbiter) because you accidentally compared Miles to Kilometers without realizing it.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/lu4/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lu4\">@lu4</a> It certainly makes sense to perform operations on incompatible nominal types but IMO in order to prevent bugs and have safety it's best to be forced to be explicit about any operations involving differing types.</p>\n<p dir=\"auto\">It makes sense to operate on differing types like Miles / Gallons but most of the time I think it <em>only</em> makes sense on a per-context basis. For example <code class=\"notranslate\">const speed = Miles / Gallons</code> would be a bug since Miles/Gallons clearly isn't a representation of speed as intended -- if you allow these operations without warning it's easy to introduce bugs.</p>\n<p dir=\"auto\">When you can implicitly do operations on types with similar data but different or contextually important meanings it's easy to end up <a href=\"https://en.wikipedia.org/wiki/Mars_Climate_Orbiter\" rel=\"nofollow\">crashing into the surface of mars</a> because you accidentally compared Miles to Kilometers without realizing it.</p>",
        "createdAt": "2022-01-30T12:45:06Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1025135890",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 11
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc49GmmO",
        "author": {
          "login": "lu4"
        },
        "authorAssociation": "NONE",
        "body": "I don't think typescript was ever used for any Mars missions so I think we're on the safe side here :) There is no one size that fits all. If you have cases where you need comparison not to work for two different brands of numbers please use the approach that helps you achieve your goal. But the stricter the type system the harder it becomes to use it so you are the one who chooses the balance there. One extreme example from my university days in this regard is when we spent nearly a semester on Category theory just to define a plus operation it was very precise definition of plus but we've never actually got much chance to use it for adding anything...",
        "bodyHTML": "<p dir=\"auto\">I don't think typescript was ever used for any Mars missions so I think we're on the safe side here :) There is no one size that fits all. If you have cases where you need comparison not to work for two different brands of numbers please use the approach that helps you achieve your goal. But the stricter the type system the harder it becomes to use it so you are the one who chooses the balance there. One extreme example from my university days in this regard is when we spent nearly a semester on Category theory just to define a plus operation it was very precise definition of plus but we've never actually got much chance to use it for adding anything...</p>",
        "createdAt": "2022-01-30T13:14:27Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1025141134",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 26
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc49Gn4A",
        "author": {
          "login": "evelant"
        },
        "authorAssociation": "NONE",
        "body": "I wasn't intending to say that TS should force strict nominal typing on anybody. I'd just like for TS to support it in an ergonomic way for people who would like to use it. \r\n\r\nDoing implicit mathematical operations on variables that have different meanings but the same type is already fully supported, just use the `number` type! For cases where you want nominal typing however I think allowing implicit comparison and operations somewhat defeats the purpose.",
        "bodyHTML": "<p dir=\"auto\">I wasn't intending to say that TS should force strict nominal typing on anybody. I'd just like for TS to support it in an ergonomic way for people who would like to use it.</p>\n<p dir=\"auto\">Doing implicit mathematical operations on variables that have different meanings but the same type is already fully supported, just use the <code class=\"notranslate\">number</code> type! For cases where you want nominal typing however I think allowing implicit comparison and operations somewhat defeats the purpose.</p>",
        "createdAt": "2022-01-30T13:41:48Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1025146368",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 10
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5C5uo9",
        "author": {
          "login": "michaelKurowski"
        },
        "authorAssociation": "NONE",
        "body": "It would be good to have some sort of distinct type casting for nominal types i.e.\r\n`myVariable is MyNominalType` instead of using `as`. My reasoning here is that using `as` is very often a workaround while I'd expect typecasting in terms of nominal types to be a standard. Having a separate syntax wouldn't introduce noise during CR process while one would likely like to pay extra attention while seeing `as` being used in contrast to usual TS operations.",
        "bodyHTML": "<p dir=\"auto\">It would be good to have some sort of distinct type casting for nominal types i.e.<br>\n<code class=\"notranslate\">myVariable is MyNominalType</code> instead of using <code class=\"notranslate\">as</code>. My reasoning here is that using <code class=\"notranslate\">as</code> is very often a workaround while I'd expect typecasting in terms of nominal types to be a standard. Having a separate syntax wouldn't introduce noise during CR process while one would likely like to pay extra attention while seeing <code class=\"notranslate\">as</code> being used in contrast to usual TS operations.</p>",
        "createdAt": "2022-05-10T13:53:50Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1122429501",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5D5vFA",
        "author": {
          "login": "shicks"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "There's some good discussion upthread around opaque/unique nominal types, which were prototyped a bit in #33038 (though I like the `new number` syntax a little better), but there was a parallel experiment in #33290 that explored \"structural\" brands, which generalizes to the opaque/unique case by making a new (actual) unique symbol for the structural parameter.\r\n\r\nThe latter thread was just locked, though it's not clear to me that it's \"just\" an implementation sketch for nominal types.  As far as I'm aware, the experiment didn't end in any sort of failure, it just fizzled out - so potentially it's a viable approach to solving this issue.  I.e.,\r\n\r\n```ts\r\ndeclare const milesTag: unique symbol;\r\ntype Miles = number & tag (typeof milesTag);\r\n```\r\n\r\nThis approach has the advantage that the structural tag allows the same nominal type to be defined in multiple places, when that may be desirable (i.e. for API compatibility), though that's opt-in (the above example would be truly unique and not forgeable elsewhere).\r\n\r\nIt looks like the TS maintainers aren't paying much attention to this issue, but I'm wondering if there's any interest in picking this back up again?",
        "bodyHTML": "<p dir=\"auto\">There's some good discussion upthread around opaque/unique nominal types, which were prototyped a bit in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"484275578\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/33038\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/microsoft/TypeScript/pull/33038/hovercard\" href=\"https://github.com/microsoft/TypeScript/pull/33038\">#33038</a> (though I like the <code class=\"notranslate\">new number</code> syntax a little better), but there was a parallel experiment in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"490557334\" data-permission-text=\"Title is private\" data-url=\"https://github.com/microsoft/TypeScript/issues/33290\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/microsoft/TypeScript/pull/33290/hovercard\" href=\"https://github.com/microsoft/TypeScript/pull/33290\">#33290</a> that explored \"structural\" brands, which generalizes to the opaque/unique case by making a new (actual) unique symbol for the structural parameter.</p>\n<p dir=\"auto\">The latter thread was just locked, though it's not clear to me that it's \"just\" an implementation sketch for nominal types.  As far as I'm aware, the experiment didn't end in any sort of failure, it just fizzled out - so potentially it's a viable approach to solving this issue.  I.e.,</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"declare const milesTag: unique symbol;\ntype Miles = number &amp; tag (typeof milesTag);\"><pre class=\"notranslate\"><span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">milesTag</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Miles</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-s1\">tag</span> <span class=\"pl-kos\">(</span><span class=\"pl-k\">typeof</span> <span class=\"pl-s1\">milesTag</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">This approach has the advantage that the structural tag allows the same nominal type to be defined in multiple places, when that may be desirable (i.e. for API compatibility), though that's opt-in (the above example would be truly unique and not forgeable elsewhere).</p>\n<p dir=\"auto\">It looks like the TS maintainers aren't paying much attention to this issue, but I'm wondering if there's any interest in picking this back up again?</p>",
        "createdAt": "2022-05-27T02:01:33Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1139208512",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 29
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5F36Xk",
        "author": {
          "login": "jsoldi"
        },
        "authorAssociation": "NONE",
        "body": "Wouldn't this be a simple way to avoid adding fake properties?\r\n\r\n```typescript\r\ndeclare const isFinite: unique symbol\r\ndeclare const isInteger: unique symbol\r\n\r\nexport type finite = number & { readonly [isFinite]: true }\r\nexport type integer = finite & { readonly [isInteger]: true }\r\n\r\nexport const numberIsFinite = (n: unknown): n is finite => typeof n === 'number' && Number.isFinite(n)\r\nexport const numberIsInteger = (n: unknown): n is integer => typeof n === 'number' && Number.isInteger(n)\r\n```\r\n\r\nSince `isFinite` and `isInteger` are not exported, they'll only be usable from inside the module. Is there a downside to doing this, other than being a little more verbose?",
        "bodyHTML": "<p dir=\"auto\">Wouldn't this be a simple way to avoid adding fake properties?</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"declare const isFinite: unique symbol\ndeclare const isInteger: unique symbol\n\nexport type finite = number &amp; { readonly [isFinite]: true }\nexport type integer = finite &amp; { readonly [isInteger]: true }\n\nexport const numberIsFinite = (n: unknown): n is finite =&gt; typeof n === 'number' &amp;&amp; Number.isFinite(n)\nexport const numberIsInteger = (n: unknown): n is integer =&gt; typeof n === 'number' &amp;&amp; Number.isInteger(n)\"><pre class=\"notranslate\"><span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">isFinite</span>: <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">symbol</span>\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">isInteger</span>: <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">symbol</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">finite</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-kos\">[</span><span class=\"pl-s1\">isFinite</span><span class=\"pl-kos\">]</span>: <span class=\"pl-c1\">true</span> <span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">integer</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">finite</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-k\">readonly</span> <span class=\"pl-kos\">[</span><span class=\"pl-s1\">isInteger</span><span class=\"pl-kos\">]</span>: <span class=\"pl-c1\">true</span> <span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">const</span> <span class=\"pl-en\">numberIsFinite</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">n</span>: <span class=\"pl-smi\">unknown</span><span class=\"pl-kos\">)</span>: <span class=\"pl-s1\">n</span> is <span class=\"pl-smi\">finite</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-s1\">n</span> <span class=\"pl-c1\">===</span> <span class=\"pl-s\">'number'</span> <span class=\"pl-c1\">&amp;&amp;</span> <span class=\"pl-smi\">Number</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">isFinite</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">n</span><span class=\"pl-kos\">)</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">const</span> <span class=\"pl-en\">numberIsInteger</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">n</span>: <span class=\"pl-smi\">unknown</span><span class=\"pl-kos\">)</span>: <span class=\"pl-s1\">n</span> is <span class=\"pl-smi\">integer</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-k\">typeof</span> <span class=\"pl-s1\">n</span> <span class=\"pl-c1\">===</span> <span class=\"pl-s\">'number'</span> <span class=\"pl-c1\">&amp;&amp;</span> <span class=\"pl-smi\">Number</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">isInteger</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">n</span><span class=\"pl-kos\">)</span></pre></div>\n<p dir=\"auto\">Since <code class=\"notranslate\">isFinite</code> and <code class=\"notranslate\">isInteger</code> are not exported, they'll only be usable from inside the module. Is there a downside to doing this, other than being a little more verbose?</p>",
        "createdAt": "2022-07-01T12:16:28Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1172284900",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 10
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5UNYYu",
        "author": {
          "login": "Conaclos"
        },
        "authorAssociation": "NONE",
        "body": "> This approach has the advantage that the structural tag allows the same nominal type to be defined in multiple places, when that may be desirable\r\n\r\nI see that as a drawback. This almost destroys the interest of nominal types...\r\n\r\nI pretty how _Flow_ handles nominal types via [subtypes of opaque types](https://flow.org/en/docs/types/opaque-types/#toc-subtyping-constraints).\r\nTypeScript could only handle nominal types choosing the same behavior: in the file where it is declared, [the nominal type is treated as its underlying structural type](https://flow.org/en/docs/types/opaque-types/#toc-within-the-defining-file):\r\n\r\n```ts\r\n// ./meter.ts\r\nexport unique type Meter = number\r\nexport function Meter(n: number): Meter {\r\n    assert(n >= 0)\r\n    return n // allowed in this file\r\n}\r\n\r\n// ./index.ts\r\nimport { Meter } from \"./meter.js\"\r\n\r\nconst x: Meter = 5 // error\r\nconst a: number = Meter(5) + Meter(5) // `Meter` is a subtype of `number`\r\n```",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">This approach has the advantage that the structural tag allows the same nominal type to be defined in multiple places, when that may be desirable</p>\n</blockquote>\n<p dir=\"auto\">I see that as a drawback. This almost destroys the interest of nominal types...</p>\n<p dir=\"auto\">I pretty how <em>Flow</em> handles nominal types via <a href=\"https://flow.org/en/docs/types/opaque-types/#toc-subtyping-constraints\" rel=\"nofollow\">subtypes of opaque types</a>.<br>\nTypeScript could only handle nominal types choosing the same behavior: in the file where it is declared, <a href=\"https://flow.org/en/docs/types/opaque-types/#toc-within-the-defining-file\" rel=\"nofollow\">the nominal type is treated as its underlying structural type</a>:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// ./meter.ts\nexport unique type Meter = number\nexport function Meter(n: number): Meter {\n    assert(n &gt;= 0)\n    return n // allowed in this file\n}\n\n// ./index.ts\nimport { Meter } from &quot;./meter.js&quot;\n\nconst x: Meter = 5 // error\nconst a: number = Meter(5) + Meter(5) // `Meter` is a subtype of `number`\"><pre class=\"notranslate\"><span class=\"pl-c\">// ./meter.ts</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Meter</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">function</span> <span class=\"pl-smi\">Meter</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">n</span>: <span class=\"pl-smi\">number</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">Meter</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-en\">assert</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">n</span> <span class=\"pl-c1\">&gt;=</span> <span class=\"pl-c1\">0</span><span class=\"pl-kos\">)</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-s1\">n</span> <span class=\"pl-c\">// allowed in this file</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-c\">// ./index.ts</span>\n<span class=\"pl-k\">import</span> <span class=\"pl-kos\">{</span> <span class=\"pl-smi\">Meter</span> <span class=\"pl-kos\">}</span> <span class=\"pl-k\">from</span> <span class=\"pl-s\">\"./meter.js\"</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">Meter</span> <span class=\"pl-c1\">=</span> <span class=\"pl-c1\">5</span> <span class=\"pl-c\">// error</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">a</span>: <span class=\"pl-smi\">number</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Meter</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">5</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">+</span> <span class=\"pl-smi\">Meter</span><span class=\"pl-kos\">(</span><span class=\"pl-c1\">5</span><span class=\"pl-kos\">)</span> <span class=\"pl-c\">// `Meter` is a subtype of `number`</span></pre></div>",
        "createdAt": "2023-02-01T22:01:08Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1412793902",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V4C99",
        "author": {
          "login": "refactorized"
        },
        "authorAssociation": "NONE",
        "body": "This really feels dangerously close to the `this` issue in which we open the door to one classical-OOP paradigm and they proceed to invite an entire football team of misunderstandings to the party.  To me the \"brand\" pattern, possibly combined with something like symbols as keys, or any other reasonably unique and registrable magic hash, feels almost like a proper _javascript_ solution.   \r\n\r\nI recently went through lengths to modify an package that relied on the type names extracted and encoded into objects via a similar pattern, and only later realized how much easier it would have been to just to tuck my own brand property in wherever needed.  The problem here was that I was approaching things in a nominal way, which wasn't in accordance to how the language worked.  \r\n\r\nI think that the original cases put forward as arguments for some kind of nominal typing are valid, but they are also handled by the branding pattern.  Perhaps it's possible to codify the pattern and top it with some syntactic sugar.  \r\n\r\nIt's also possible to establish a convention that is practically collision free, without new language features.  If you establish that `UIdFn()` results in a reasonably unique string, then it follows that `'_type_symbol_'+UIdFn()` is also (reasonably) unique.",
        "bodyHTML": "<p dir=\"auto\">This really feels dangerously close to the <code class=\"notranslate\">this</code> issue in which we open the door to one classical-OOP paradigm and they proceed to invite an entire football team of misunderstandings to the party.  To me the \"brand\" pattern, possibly combined with something like symbols as keys, or any other reasonably unique and registrable magic hash, feels almost like a proper <em>javascript</em> solution.</p>\n<p dir=\"auto\">I recently went through lengths to modify an package that relied on the type names extracted and encoded into objects via a similar pattern, and only later realized how much easier it would have been to just to tuck my own brand property in wherever needed.  The problem here was that I was approaching things in a nominal way, which wasn't in accordance to how the language worked.</p>\n<p dir=\"auto\">I think that the original cases put forward as arguments for some kind of nominal typing are valid, but they are also handled by the branding pattern.  Perhaps it's possible to codify the pattern and top it with some syntactic sugar.</p>\n<p dir=\"auto\">It's also possible to establish a convention that is practically collision free, without new language features.  If you establish that <code class=\"notranslate\">UIdFn()</code> results in a reasonably unique string, then it follows that <code class=\"notranslate\">'_type_symbol_'+UIdFn()</code> is also (reasonably) unique.</p>",
        "createdAt": "2023-02-22T20:28:49Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1440755581",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V4Wjv",
        "author": {
          "login": "Pauan"
        },
        "authorAssociation": "NONE",
        "body": "@refactorized Nominal types are not an \"OOP thing\", they exist in almost every statically typed language, whether it be OCaml, Haskell, Rust, F#, C#, C++, etc.\r\n\r\nIt is simply very useful to have a type which is the same as an existing type at runtime but different at compile-time. This is a very basic feature which is useful in ***many*** situations, it is not tied to any particular paradigm or code style.\r\n\r\nYou seem to think that this is asking for the ability to detect types at runtime, but we can already do that with `instanceof`. This is not about runtime type detection, it's about compile-time types which are erased at runtime.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/refactorized/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/refactorized\">@refactorized</a> Nominal types are not an \"OOP thing\", they exist in almost every statically typed language, whether it be OCaml, Haskell, Rust, F#, C#, C++, etc.</p>\n<p dir=\"auto\">It is simply very useful to have a type which is the same as an existing type at runtime but different at compile-time. This is a very basic feature which is useful in <em><strong>many</strong></em> situations, it is not tied to any particular paradigm or code style.</p>\n<p dir=\"auto\">You seem to think that this is asking for the ability to detect types at runtime, but we can already do that with <code class=\"notranslate\">instanceof</code>. This is not about runtime type detection, it's about compile-time types which are erased at runtime.</p>",
        "createdAt": "2023-02-22T21:38:05Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1440835823",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 8
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V5Ard",
        "author": {
          "login": "refactorized"
        },
        "authorAssociation": "NONE",
        "body": "> @refactorized Nominal types are not an \"OOP thing\", they exist in almost every statically typed language, whether it be OCaml, Haskell, Rust, F#, C#, C++, etc.\r\n\r\nMaybe, but they are NOT a thing in Javascript and last I checked Typescript was a superset of Javascript, not Java.  This is about what is idiomatic to the language.\r\n\r\n> You seem to think that this is asking for the ability to detect types at runtime, but we can already do that with instanceof. This is not about runtime type detection, it's about compile-time types which are erased at runtime.\r\n\r\nI am not talking about runtime types. I gave a hasty example, in which we were matching mapping functions to their data at runtime without issue (mapping on something like a brand) but struggling to extend the paradigm to proper typescript, but that's besides the main point. \r\n\r\nI am trying to keep duck typing as duck typing.  I don't care if Haskell has nominal types, I care that Java and C# do as I have navigated several layer-cake nightmares written in both languages, and around a design process focused too completely on objects and their hierarchal classifications.  \r\n\r\nNominal types don't _cause_ over-engineering, premature optimization, and brittle code, but they can go a long way to indulging anti-patterns that go away when types are centered on their applicability to a given function or interface instead of what you name them.  Furthermore, Javascript has a history of misrepresenting itself as CLASSical OOP (as in classes not as in rock and roll), and a lot of misunderstanding of its prototypal nature has resulted.\r\n\r\nTypescript has won over many developers precisely because it honors idiomatic Javascript (via a type system complex enough to be turing complete itself), and I think the community should be protective of this by default.\r\n\r\nYou are welcome to go write things in C#, it's a great multi-paradigm language that comes out of the box with nominal types.  But to support actual nominal types means to either fundamentally change the language or else to find some clever syntactic sugar.\r\n\r\nSome compelling arguments for nominal type support have been made above, but any proposal of a change this fundamental should be met with scrutiny, not just a list of other languages that do it too.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/refactorized/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/refactorized\">@refactorized</a> Nominal types are not an \"OOP thing\", they exist in almost every statically typed language, whether it be OCaml, Haskell, Rust, F#, C#, C++, etc.</p>\n</blockquote>\n<p dir=\"auto\">Maybe, but they are NOT a thing in Javascript and last I checked Typescript was a superset of Javascript, not Java.  This is about what is idiomatic to the language.</p>\n<blockquote>\n<p dir=\"auto\">You seem to think that this is asking for the ability to detect types at runtime, but we can already do that with instanceof. This is not about runtime type detection, it's about compile-time types which are erased at runtime.</p>\n</blockquote>\n<p dir=\"auto\">I am not talking about runtime types. I gave a hasty example, in which we were matching mapping functions to their data at runtime without issue (mapping on something like a brand) but struggling to extend the paradigm to proper typescript, but that's besides the main point.</p>\n<p dir=\"auto\">I am trying to keep duck typing as duck typing.  I don't care if Haskell has nominal types, I care that Java and C# do as I have navigated several layer-cake nightmares written in both languages, and around a design process focused too completely on objects and their hierarchal classifications.</p>\n<p dir=\"auto\">Nominal types don't <em>cause</em> over-engineering, premature optimization, and brittle code, but they can go a long way to indulging anti-patterns that go away when types are centered on their applicability to a given function or interface instead of what you name them.  Furthermore, Javascript has a history of misrepresenting itself as CLASSical OOP (as in classes not as in rock and roll), and a lot of misunderstanding of its prototypal nature has resulted.</p>\n<p dir=\"auto\">Typescript has won over many developers precisely because it honors idiomatic Javascript (via a type system complex enough to be turing complete itself), and I think the community should be protective of this by default.</p>\n<p dir=\"auto\">You are welcome to go write things in C#, it's a great multi-paradigm language that comes out of the box with nominal types.  But to support actual nominal types means to either fundamentally change the language or else to find some clever syntactic sugar.</p>\n<p dir=\"auto\">Some compelling arguments for nominal type support have been made above, but any proposal of a change this fundamental should be met with scrutiny, not just a list of other languages that do it too.</p>",
        "createdAt": "2023-02-22T23:41:17Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1441008349",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V5CP1",
        "author": {
          "login": "lazarljubenovic"
        },
        "authorAssociation": "NONE",
        "body": "How will adding nominal types \"fundamentally change the languge\"? JavaScript is already \"changed\" by TypeScript by adding types. Adding a way to express these types better is what TypeScript's aim has always been, with each release.",
        "bodyHTML": "<p dir=\"auto\">How will adding nominal types \"fundamentally change the languge\"? JavaScript is already \"changed\" by TypeScript by adding types. Adding a way to express these types better is what TypeScript's aim has always been, with each release.</p>",
        "createdAt": "2023-02-22T23:50:11Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1441014773",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 9
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V5DND",
        "author": {
          "login": "Pauan"
        },
        "authorAssociation": "NONE",
        "body": "> @refactorized Maybe, but they are NOT a thing in Javascript and last I checked Typescript was a superset of Javascript, not Java. This is about what is idiomatic to the language.\r\n\r\nThat is incorrect. ***All*** classes in JS are nominal, that's why you can use `instanceof` to distinguish between classes. That has been true for decades, classes have *never* been structural in JS.\r\n\r\nTypeScript chose to make classes structural, even though they are not structural in JavaScript. That's a perfectly fine choice, but please don't pretend that it is idiomatic for JavaScript, because it isn't.\r\n\r\nObjects in JS are structural, but classes have never been structural. So you can't use the phrase \"idiomatic\" as a counter-argument against nominal types. Nominal types already exist in JS, so you need to get used to them.\r\n\r\nI'm not even going to engage with your other comments, other than to say that I disagree with everything you wrote.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/refactorized/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/refactorized\">@refactorized</a> Maybe, but they are NOT a thing in Javascript and last I checked Typescript was a superset of Javascript, not Java. This is about what is idiomatic to the language.</p>\n</blockquote>\n<p dir=\"auto\">That is incorrect. <em><strong>All</strong></em> classes in JS are nominal, that's why you can use <code class=\"notranslate\">instanceof</code> to distinguish between classes. That has been true for decades, classes have <em>never</em> been structural in JS.</p>\n<p dir=\"auto\">TypeScript chose to make classes structural, even though they are not structural in JavaScript. That's a perfectly fine choice, but please don't pretend that it is idiomatic for JavaScript, because it isn't.</p>\n<p dir=\"auto\">Objects in JS are structural, but classes have never been structural. So you can't use the phrase \"idiomatic\" as a counter-argument against nominal types. Nominal types already exist in JS, so you need to get used to them.</p>\n<p dir=\"auto\">I'm not even going to engage with your other comments, other than to say that I disagree with everything you wrote.</p>",
        "createdAt": "2023-02-22T23:55:54Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1441018691",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V5OLg",
        "author": {
          "login": "refactorized"
        },
        "authorAssociation": "NONE",
        "body": "> @Pauan That is incorrect. All classes in JS are nominal, that's why you can use instanceof to distinguish between classes.\r\n\r\nI'm not talking about classes, gross.  I am simply talking about objects, arrays of objects, you know - things that can be converted to json.  I kid, but one can build pretty much anything without ever touching a javascript class, which I find useful for only data structures and fluent interfaces.  \r\n\r\nI'm really not sure how one would go about making classes _not_ nominal, other than just ignoring what they are.  I have been generally avoiding classes in javascript for over a decade, and pretty happy with the result so far - but I admittedly wasn't considering them any more than I usually do. \r\n\r\nI dunno, maybe my idioms are not yours.  I found refuge in the wisdom of luminaries like Douglas Crockford and Eric Elliott who do a much better job than I do celebrating the parsimony of simple javascript.\r\n\r\nI would love to be wrong about this, there's a lot more value in learning something new than resisting change.  However, the magic for me has always been that Javascript doesn't feel like Java or C#, it's different and that's good.\r\n\r\nThis is all academic of course if we are only considering seasoned developers like yourself who can pick which parts of the language they want to use, and which to ignore.  My insistence on \"Idiomatic Javascript\" has a lot to do with my Journey learning and teaching the language, and the value I have found in its limitations.\r\n\r\nThat said, If you want _classes_ to be nominally typed in typescript I actually think _that_ makes sense.   \r\n",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Pauan/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Pauan\">@Pauan</a> That is incorrect. All classes in JS are nominal, that's why you can use instanceof to distinguish between classes.</p>\n</blockquote>\n<p dir=\"auto\">I'm not talking about classes, gross.  I am simply talking about objects, arrays of objects, you know - things that can be converted to json.  I kid, but one can build pretty much anything without ever touching a javascript class, which I find useful for only data structures and fluent interfaces.</p>\n<p dir=\"auto\">I'm really not sure how one would go about making classes <em>not</em> nominal, other than just ignoring what they are.  I have been generally avoiding classes in javascript for over a decade, and pretty happy with the result so far - but I admittedly wasn't considering them any more than I usually do.</p>\n<p dir=\"auto\">I dunno, maybe my idioms are not yours.  I found refuge in the wisdom of luminaries like Douglas Crockford and Eric Elliott who do a much better job than I do celebrating the parsimony of simple javascript.</p>\n<p dir=\"auto\">I would love to be wrong about this, there's a lot more value in learning something new than resisting change.  However, the magic for me has always been that Javascript doesn't feel like Java or C#, it's different and that's good.</p>\n<p dir=\"auto\">This is all academic of course if we are only considering seasoned developers like yourself who can pick which parts of the language they want to use, and which to ignore.  My insistence on \"Idiomatic Javascript\" has a lot to do with my Journey learning and teaching the language, and the value I have found in its limitations.</p>\n<p dir=\"auto\">That said, If you want <em>classes</em> to be nominally typed in typescript I actually think <em>that</em> makes sense.</p>",
        "createdAt": "2023-02-23T00:33:33Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1441063648",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V5QSI",
        "author": {
          "login": "lazarljubenovic"
        },
        "authorAssociation": "NONE",
        "body": "You're already the one picking which parts of the language you want to use by avoiding \"gross\" classes. There's nothing that goes against any principles (classful or classless) in a desire to say \"nominal type Meter = number\" and thus disallow assignments from a plain number to Meter and vice-versa.",
        "bodyHTML": "<p dir=\"auto\">You're already the one picking which parts of the language you want to use by avoiding \"gross\" classes. There's nothing that goes against any principles (classful or classless) in a desire to say \"nominal type Meter = number\" and thus disallow assignments from a plain number to Meter and vice-versa.</p>",
        "createdAt": "2023-02-23T00:41:07Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1441072264",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 7
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V5ZRo",
        "author": {
          "login": "refactorized"
        },
        "authorAssociation": "NONE",
        "body": "> You're already the one picking which parts of the language you want to use by avoiding \"gross\" classes. There's nothing that goes against any principles (classful or classless) in a desire to say \"nominal type Meter = number\" and thus disallow assignments from a plain number to Meter and vice-versa.\r\n\r\nSigh, I don't want to be in this argument.  I see no little value in restricting types like this, and a lot of danger in encoding concepts like 'what is a meter' into names, but I have been wrong before.  \r\n\r\nMy original 2 cents were along the lines of \"be careful\", but I just don't care anymore.  Typescript is terribly confusing to learn without the context of plain javascript anyway, and has never been a particularly useful guide for which parts of the language to use for what, so what is one more concept on the heap.\r\n\r\nHave your nominal types, I will put them in the drawer with classes, private variables, and `this`.  That drawer is occasionally useful for very specific things, I guess, but I would just as soon not look at them.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">You're already the one picking which parts of the language you want to use by avoiding \"gross\" classes. There's nothing that goes against any principles (classful or classless) in a desire to say \"nominal type Meter = number\" and thus disallow assignments from a plain number to Meter and vice-versa.</p>\n</blockquote>\n<p dir=\"auto\">Sigh, I don't want to be in this argument.  I see no little value in restricting types like this, and a lot of danger in encoding concepts like 'what is a meter' into names, but I have been wrong before.</p>\n<p dir=\"auto\">My original 2 cents were along the lines of \"be careful\", but I just don't care anymore.  Typescript is terribly confusing to learn without the context of plain javascript anyway, and has never been a particularly useful guide for which parts of the language to use for what, so what is one more concept on the heap.</p>\n<p dir=\"auto\">Have your nominal types, I will put them in the drawer with classes, private variables, and <code class=\"notranslate\">this</code>.  That drawer is occasionally useful for very specific things, I guess, but I would just as soon not look at them.</p>",
        "createdAt": "2023-02-23T01:26:38Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1441109096",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V6BD5",
        "author": {
          "login": "binki"
        },
        "authorAssociation": "NONE",
        "body": "> > @refactorized Nominal types are not an \"OOP thing\", they exist in almost every statically typed language, whether it be OCaml, Haskell, Rust, F#, C#, C++, etc.\r\n> \r\n> Maybe, but they are NOT a thing in Javascript and last I checked Typescript was a superset of Javascript, not Java. This is about what is idiomatic to the language.\r\n\r\nTypeScript is not a superset of JavaScript. If it were a superset of JavaScript, then JavaScript would be a subset of TypeScript and it would be impossible to write a JavaScript program which is not also TypeScript. The following is perfectly valid JavaScript but invalid TypeScript:\r\n\r\n```js\r\n1/'34';\r\n```\r\n\r\nIf TypeScript were a superset of JavaScript, it would be useless. Preventing the emission of certain “wrong” (by some arbitrary standard) JavaScript programs is the entire point of TypeScript.\r\n\r\n> I am trying to keep duck typing as duck typing. I don't care if Haskell has nominal types, I care that Java and C# do as I have navigated several layer-cake nightmares written in both languages, and around a design process focused too completely on objects and their hierarchal classifications.\r\n>\r\n> Nominal types don't _cause_ over-engineering, premature optimization, and brittle code, but they can go a long way to indulging anti-patterns that go away when types are centered on their applicability to a given function or interface instead of what you name them.\r\n\r\nJust because a method accepts a type that happens to have certain properties with particular types does not mean it is meant to be passed to that method. However, if the IDE suggests that the method is applicable when, instead, you are intending to use a different, unrelated method, then you have type confusion for which TypeScript will happy emit valid but wrong JavaScript code. Nominal types are a way to prevent such code from compiling. This gets us back to the primary use case of TypeScript: using static typing to prevent emission of valid but “wrong” (by some arbitrary standard) JavaScript programs.\r\n\r\nTypeScript hasn’t offered us something better than nominal types. But it has the mechanism (which is used if you include private properties in your class). It just doesn’t provide a way to use that mechanism in a reasonable way (i.e., without creating unused private properties). And the reasons we are given are that the TypeScript team just prefers structural typing and that they are no longer willing to introduce new syntax (even though they introduced the type suffix syntax and keywords like `class`, `import`, `async`, `await`, `type`, and `interface`).",
        "bodyHTML": "<blockquote>\n<blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/refactorized/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/refactorized\">@refactorized</a> Nominal types are not an \"OOP thing\", they exist in almost every statically typed language, whether it be OCaml, Haskell, Rust, F#, C#, C++, etc.</p>\n</blockquote>\n<p dir=\"auto\">Maybe, but they are NOT a thing in Javascript and last I checked Typescript was a superset of Javascript, not Java. This is about what is idiomatic to the language.</p>\n</blockquote>\n<p dir=\"auto\">TypeScript is not a superset of JavaScript. If it were a superset of JavaScript, then JavaScript would be a subset of TypeScript and it would be impossible to write a JavaScript program which is not also TypeScript. The following is perfectly valid JavaScript but invalid TypeScript:</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"1/'34';\"><pre class=\"notranslate\"><span class=\"pl-c1\">1</span><span class=\"pl-c1\">/</span><span class=\"pl-s\">'34'</span><span class=\"pl-kos\">;</span></pre></div>\n<p dir=\"auto\">If TypeScript were a superset of JavaScript, it would be useless. Preventing the emission of certain “wrong” (by some arbitrary standard) JavaScript programs is the entire point of TypeScript.</p>\n<blockquote>\n<p dir=\"auto\">I am trying to keep duck typing as duck typing. I don't care if Haskell has nominal types, I care that Java and C# do as I have navigated several layer-cake nightmares written in both languages, and around a design process focused too completely on objects and their hierarchal classifications.</p>\n<p dir=\"auto\">Nominal types don't <em>cause</em> over-engineering, premature optimization, and brittle code, but they can go a long way to indulging anti-patterns that go away when types are centered on their applicability to a given function or interface instead of what you name them.</p>\n</blockquote>\n<p dir=\"auto\">Just because a method accepts a type that happens to have certain properties with particular types does not mean it is meant to be passed to that method. However, if the IDE suggests that the method is applicable when, instead, you are intending to use a different, unrelated method, then you have type confusion for which TypeScript will happy emit valid but wrong JavaScript code. Nominal types are a way to prevent such code from compiling. This gets us back to the primary use case of TypeScript: using static typing to prevent emission of valid but “wrong” (by some arbitrary standard) JavaScript programs.</p>\n<p dir=\"auto\">TypeScript hasn’t offered us something better than nominal types. But it has the mechanism (which is used if you include private properties in your class). It just doesn’t provide a way to use that mechanism in a reasonable way (i.e., without creating unused private properties). And the reasons we are given are that the TypeScript team just prefers structural typing and that they are no longer willing to introduce new syntax (even though they introduced the type suffix syntax and keywords like <code class=\"notranslate\">class</code>, <code class=\"notranslate\">import</code>, <code class=\"notranslate\">async</code>, <code class=\"notranslate\">await</code>, <code class=\"notranslate\">type</code>, and <code class=\"notranslate\">interface</code>).</p>",
        "createdAt": "2023-02-23T06:35:50Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1441272057",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V6Ngo",
        "author": {
          "login": "simonbuchan"
        },
        "authorAssociation": "NONE",
        "body": "> TypeScript is not a superset of JavaScript. I\r\n\r\nJust to address this arbitrary semantic point, \"language A is a subset of language B\" has two possible interpretations, with an exact analogy to a type being a subset of another.\r\n\r\nIt can be, as you say, \"the set of programs/values that are valid in A is a subset of those for B\", but it can also be \"the things that are possible in A is a subset of those in B\", and for both languages and types we tend to use the latter.\r\n\r\nFor example, \"the C subset of C++\", \"the type Cat extends (meaning, makes bigger!) Animal\".\r\n\r\nInstead, we talk about the subset of C++ *programs* that are C, or the subset of *values* of Animal that are Cats, instead of the language or type itself.\r\n\r\n---\r\n\r\nRegarding the actual point, please (everyone) don't spam feature request threads with arguments about whether a feature is \"too OOP\" or \"doesn't fit with the style of Javascript\" or whatever, without going into what actual issues it's likely to cause (at which point you don't need the general, derailing complaint) ",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">TypeScript is not a superset of JavaScript. I</p>\n</blockquote>\n<p dir=\"auto\">Just to address this arbitrary semantic point, \"language A is a subset of language B\" has two possible interpretations, with an exact analogy to a type being a subset of another.</p>\n<p dir=\"auto\">It can be, as you say, \"the set of programs/values that are valid in A is a subset of those for B\", but it can also be \"the things that are possible in A is a subset of those in B\", and for both languages and types we tend to use the latter.</p>\n<p dir=\"auto\">For example, \"the C subset of C++\", \"the type Cat extends (meaning, makes bigger!) Animal\".</p>\n<p dir=\"auto\">Instead, we talk about the subset of C++ <em>programs</em> that are C, or the subset of <em>values</em> of Animal that are Cats, instead of the language or type itself.</p>\n<hr>\n<p dir=\"auto\">Regarding the actual point, please (everyone) don't spam feature request threads with arguments about whether a feature is \"too OOP\" or \"doesn't fit with the style of Javascript\" or whatever, without going into what actual issues it's likely to cause (at which point you don't need the general, derailing complaint)</p>",
        "createdAt": "2023-02-23T07:48:08Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1441323048",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V9VZc",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "`instanceof` doesn't work cross-realm (see https://www.reddit.com/r/javascript/comments/2hkl93/instanceof_why_not/) \r\n\r\nIt also doesn't work cross-commonjs-module-instances\r\n\r\nFor example, if you have \r\n- a shared observables library, \r\n- another library using v1.5 of the above library\r\n- a third library using v1.6 of the above library\r\n\r\nThese may end up in different directories, due to\r\n- package managers trying to respect lockfiles when you add a library\r\n- a fourth dependency requiring a different major version of the observables library (say, 2.0) and ending up at the root `node_modules`, will cause the other two libraries to have two different copies of the observable library, even if the versions are identical, and therefore have different CommonJS instances (and `instanceof` wont work)\r\n\r\n\r\nIncidentally, the above two problems are also very good reasons to avoid nominal types in favor of brands in JS.\r\n\r\nNote: due to liberal use of small dependencies across the JS ecosystem and deep dependency trees, this happens quite more often than you'd think.",
        "bodyHTML": "<p dir=\"auto\"><code class=\"notranslate\">instanceof</code> doesn't work cross-realm (see <a href=\"https://www.reddit.com/r/javascript/comments/2hkl93/instanceof_why_not/\" rel=\"nofollow\">https://www.reddit.com/r/javascript/comments/2hkl93/instanceof_why_not/</a>)</p>\n<p dir=\"auto\">It also doesn't work cross-commonjs-module-instances</p>\n<p dir=\"auto\">For example, if you have</p>\n<ul dir=\"auto\">\n<li>a shared observables library,</li>\n<li>another library using v1.5 of the above library</li>\n<li>a third library using v1.6 of the above library</li>\n</ul>\n<p dir=\"auto\">These may end up in different directories, due to</p>\n<ul dir=\"auto\">\n<li>package managers trying to respect lockfiles when you add a library</li>\n<li>a fourth dependency requiring a different major version of the observables library (say, 2.0) and ending up at the root <code class=\"notranslate\">node_modules</code>, will cause the other two libraries to have two different copies of the observable library, even if the versions are identical, and therefore have different CommonJS instances (and <code class=\"notranslate\">instanceof</code> wont work)</li>\n</ul>\n<p dir=\"auto\">Incidentally, the above two problems are also very good reasons to avoid nominal types in favor of brands in JS.</p>\n<p dir=\"auto\">Note: due to liberal use of small dependencies across the JS ecosystem and deep dependency trees, this happens quite more often than you'd think.</p>",
        "createdAt": "2023-02-23T17:14:35Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442141788",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V9XbJ",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "Rather than downvoting, how about presenting a counter-argument?",
        "bodyHTML": "<p dir=\"auto\">Rather than downvoting, how about presenting a counter-argument?</p>",
        "createdAt": "2023-02-23T17:19:55Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442150089",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V9YFy",
        "author": {
          "login": "ljharb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "In those cases, you *want* nominal types, because you want to quickly surface that you have an incompatible dependency graph - that's what peer deps are for.",
        "bodyHTML": "<p dir=\"auto\">In those cases, you <em>want</em> nominal types, because you want to quickly surface that you have an incompatible dependency graph - that's what peer deps are for.</p>",
        "createdAt": "2023-02-23T17:21:09Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442152818",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 6
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V9Yfy",
        "author": {
          "login": "binki"
        },
        "authorAssociation": "NONE",
        "body": "> `instanceof` doesn't work cross-realm (see https://www.reddit.com/r/javascript/comments/2hkl93/instanceof_why_not/) or cross-commonjs-module-instances (e.g. if you have a shared observables library, and one library uses v1.5 while another uses v1.6 due to, say, minimal lockfile change restrictions, or inability to place the copies in the shared root due to conflict with a 3rd version of the library).\r\n\r\nIf you are using different versions of the library in the same package, you shouldn’t be passing instances of the one type into APIs from the other type. I.e., the behavior you are seeing is correct and logical.\r\n\r\nIf distinct versions of the shared library are required by different dependencies and those dependencies themselves publicize the types from their dependencies as part of their APIs, then it is the job of your package manager to see these as publicly exposed dependencies and recognize an irresolvable dependency conflict.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\"><code class=\"notranslate\">instanceof</code> doesn't work cross-realm (see <a href=\"https://www.reddit.com/r/javascript/comments/2hkl93/instanceof_why_not/\" rel=\"nofollow\">https://www.reddit.com/r/javascript/comments/2hkl93/instanceof_why_not/</a>) or cross-commonjs-module-instances (e.g. if you have a shared observables library, and one library uses v1.5 while another uses v1.6 due to, say, minimal lockfile change restrictions, or inability to place the copies in the shared root due to conflict with a 3rd version of the library).</p>\n</blockquote>\n<p dir=\"auto\">If you are using different versions of the library in the same package, you shouldn’t be passing instances of the one type into APIs from the other type. I.e., the behavior you are seeing is correct and logical.</p>\n<p dir=\"auto\">If distinct versions of the shared library are required by different dependencies and those dependencies themselves publicize the types from their dependencies as part of their APIs, then it is the job of your package manager to see these as publicly exposed dependencies and recognize an irresolvable dependency conflict.</p>",
        "createdAt": "2023-02-23T17:22:00Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442154482",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V9Yqp",
        "author": {
          "login": "patrys"
        },
        "authorAssociation": "NONE",
        "body": "@spion Classes imported from two modules are different, even if they share the same class name. Classes in JS are nominal, so you can't perform a structural duck-typing check. Having potentially differently structured objects pass an `instanceof` check would be horrifying. If anything, that's an argument for nominal types over branding for consistency with how the underlying language works.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/spion/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/spion\">@spion</a> Classes imported from two modules are different, even if they share the same class name. Classes in JS are nominal, so you can't perform a structural duck-typing check. Having potentially differently structured objects pass an <code class=\"notranslate\">instanceof</code> check would be horrifying. If anything, that's an argument for nominal types over branding for consistency with how the underlying language works.</p>",
        "createdAt": "2023-02-23T17:22:22Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442155177",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V9ZdE",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "> In those cases, you want nominal types, because you want to quickly surface that you have an incompatible dependency graph\r\n\r\nThat's not what I'm saying. \r\n\r\nThere is no guarantee they're incompatible. Consider the following situation\r\n\r\n- dep `a` depends on `observable` v2.0\r\n- dep `b` depends on `observable` v1.5.1 \r\n- dep `c` depends on `observable` v1.5.2\r\n\r\nWe often end up with the following dep tree\r\n\r\n- node_modules\r\n  - a\r\n  - observable@2.0\r\n  - b\r\n    - node_modules\r\n      - observable@1.5.1  \r\n  - c\r\n    - node_modules\r\n      - observable@1.5.2\r\n\r\nnpm and yarn (at least v1) will still nest fully compatible versions.\r\n\r\nIf you want to specify that a brand is no longer compatible, just bump its version.\r\n\r\nUse a convention such as\r\n\r\n'npm-package-name.objectType.version'\r\n\r\nfor the brand string. That way, you get to control type compatibility exactly.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">In those cases, you want nominal types, because you want to quickly surface that you have an incompatible dependency graph</p>\n</blockquote>\n<p dir=\"auto\">That's not what I'm saying.</p>\n<p dir=\"auto\">There is no guarantee they're incompatible. Consider the following situation</p>\n<ul dir=\"auto\">\n<li>dep <code class=\"notranslate\">a</code> depends on <code class=\"notranslate\">observable</code> v2.0</li>\n<li>dep <code class=\"notranslate\">b</code> depends on <code class=\"notranslate\">observable</code> v1.5.1</li>\n<li>dep <code class=\"notranslate\">c</code> depends on <code class=\"notranslate\">observable</code> v1.5.2</li>\n</ul>\n<p dir=\"auto\">We often end up with the following dep tree</p>\n<ul dir=\"auto\">\n<li>node_modules\n<ul dir=\"auto\">\n<li>a</li>\n<li>observable@2.0</li>\n<li>b\n<ul dir=\"auto\">\n<li>node_modules\n<ul dir=\"auto\">\n<li>observable@1.5.1</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>c\n<ul dir=\"auto\">\n<li>node_modules\n<ul dir=\"auto\">\n<li>observable@1.5.2</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p dir=\"auto\">npm and yarn (at least v1) will still nest fully compatible versions.</p>\n<p dir=\"auto\">If you want to specify that a brand is no longer compatible, just bump its version.</p>\n<p dir=\"auto\">Use a convention such as</p>\n<p dir=\"auto\">'npm-package-name.objectType.version'</p>\n<p dir=\"auto\">for the brand string. That way, you get to control type compatibility exactly.</p>",
        "createdAt": "2023-02-23T17:24:28Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442158404",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V9aAk",
        "author": {
          "login": "ljharb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Using a brand is forgeable, so you don't actually get to control it - you're just being hopeful, which certainly may be \"good enough\" for many use cases, but isn't the same as truly being correct.",
        "bodyHTML": "<p dir=\"auto\">Using a brand is forgeable, so you don't actually get to control it - you're just being hopeful, which certainly may be \"good enough\" for many use cases, but isn't the same as truly being correct.</p>",
        "createdAt": "2023-02-23T17:26:09Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442160676",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V9aPx",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "> Using a brand is forgeable\r\n\r\nYou can also cast any value to any type in TypeScript. This is not a \"security\" problem - its a way to prevent errors. Deliberately forging a brand can be beneficial e.g. for testing purposes.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">Using a brand is forgeable</p>\n</blockquote>\n<p dir=\"auto\">You can also cast any value to any type in TypeScript. This is not a \"security\" problem - its a way to prevent errors. Deliberately forging a brand can be beneficial e.g. for testing purposes.</p>",
        "createdAt": "2023-02-23T17:26:50Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442161649",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V9ame",
        "author": {
          "login": "ljharb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "In type space, you're absolutely correct - but the argument being made was about runtime consequences, in which case the security actually matters, and hopefully you'd want your types to match runtime behavior.",
        "bodyHTML": "<p dir=\"auto\">In type space, you're absolutely correct - but the argument being made was about runtime consequences, in which case the security actually matters, and hopefully you'd want your types to match runtime behavior.</p>",
        "createdAt": "2023-02-23T17:27:54Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442163102",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V9bnU",
        "author": {
          "login": "patrys"
        },
        "authorAssociation": "NONE",
        "body": ">There is no guarantee they're incompatible.\r\n\r\nThere is also no guarantee that my custom `Foo` object is incompatible, but the whole point of having a type system is for you to explicitly prove that things are compatible before the code compiles. That's why some people lobby to default to using `unknown` instead of `any`.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">There is no guarantee they're incompatible.</p>\n</blockquote>\n<p dir=\"auto\">There is also no guarantee that my custom <code class=\"notranslate\">Foo</code> object is incompatible, but the whole point of having a type system is for you to explicitly prove that things are compatible before the code compiles. That's why some people lobby to default to using <code class=\"notranslate\">unknown</code> instead of <code class=\"notranslate\">any</code>.</p>",
        "createdAt": "2023-02-23T17:30:54Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442167252",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V9b1Q",
        "author": {
          "login": "RyanCavanaugh"
        },
        "authorAssociation": "MEMBER",
        "body": "I realize there's *a* connection between class prototype identity and nominal types, but this discussion is getting pretty far afield and it'd be nice if we could steer it back a little. Thanks!",
        "bodyHTML": "<p dir=\"auto\">I realize there's <em>a</em> connection between class prototype identity and nominal types, but this discussion is getting pretty far afield and it'd be nice if we could steer it back a little. Thanks!</p>",
        "createdAt": "2023-02-23T17:31:32Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442168144",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 7
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V9cg-",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "@RyanCavanaugh this is a fundamental issue, and there is a lot of misunderstanding about the variety of situations where incompatible nominal types may arise in JS land (even between identical package code / versions, when npm is used). It potentially makes nominal types a footgun that can cause random problems based on a particular directory tree configuration. Most of the desired properties offered by nominal types can also be achieved with precise use of branded types.\r\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/RyanCavanaugh/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/RyanCavanaugh\">@RyanCavanaugh</a> this is a fundamental issue, and there is a lot of misunderstanding about the variety of situations where incompatible nominal types may arise in JS land (even between identical package code / versions, when npm is used). It potentially makes nominal types a footgun that can cause random problems based on a particular directory tree configuration. Most of the desired properties offered by nominal types can also be achieved with precise use of branded types.</p>",
        "createdAt": "2023-02-23T17:33:33Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442170942",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V9ne5",
        "author": {
          "login": "patrys"
        },
        "authorAssociation": "NONE",
        "body": "@spion Nominal types don't exist at runtime. The type system exists to ensure that there are no runtime issues related to the shape of the data. Nominal types offer a way to ensure you're not passing `5.0`, as in \"five liters,\" to a function that expects to be given a length in kilometers. Or that you're not adding dollars to pounds. Or that you're not mixing first names and emails in your code.\r\n\r\nI, personally, don't want to invent a unique branding namespace and versioning system to be able to create a special scalar for a JSON string, a length, or a US Dollar. And I'm sure no one wants their custom type to accidentally match another because their brand turned out not to be unique.\r\n\r\nIf your stack absolutely depends on leaking typed objects between different versions of some library, TypeScript allows you to do that explicitly.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/spion/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/spion\">@spion</a> Nominal types don't exist at runtime. The type system exists to ensure that there are no runtime issues related to the shape of the data. Nominal types offer a way to ensure you're not passing <code class=\"notranslate\">5.0</code>, as in \"five liters,\" to a function that expects to be given a length in kilometers. Or that you're not adding dollars to pounds. Or that you're not mixing first names and emails in your code.</p>\n<p dir=\"auto\">I, personally, don't want to invent a unique branding namespace and versioning system to be able to create a special scalar for a JSON string, a length, or a US Dollar. And I'm sure no one wants their custom type to accidentally match another because their brand turned out not to be unique.</p>\n<p dir=\"auto\">If your stack absolutely depends on leaking typed objects between different versions of some library, TypeScript allows you to do that explicitly.</p>",
        "createdAt": "2023-02-23T18:08:52Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442215865",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V9ua2",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "@patrys I'm well aware of how nominal types can work. Branded types don't have to exist at runtime either: e.g. https://github.com/spion/branded-types\r\n\r\nI, personally, don't want to end up with type errors between two perfectly compatible objects, just because npm decided to nest the same copy of a node module under different directories. This is what happens with `instanceof`. Unless there is some (package.jso based) namespacing and versioning logic *somewhere* (e.g. in the compiler itself), this is what would happen with TS nominal types too.\r\n",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/patrys/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/patrys\">@patrys</a> I'm well aware of how nominal types can work. Branded types don't have to exist at runtime either: e.g. <a href=\"https://github.com/spion/branded-types\">https://github.com/spion/branded-types</a></p>\n<p dir=\"auto\">I, personally, don't want to end up with type errors between two perfectly compatible objects, just because npm decided to nest the same copy of a node module under different directories. This is what happens with <code class=\"notranslate\">instanceof</code>. Unless there is some (package.jso based) namespacing and versioning logic <em>somewhere</em> (e.g. in the compiler itself), this is what would happen with TS nominal types too.</p>",
        "createdAt": "2023-02-23T18:31:49Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442244278",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V91G_",
        "author": {
          "login": "samhh"
        },
        "authorAssociation": "NONE",
        "body": "> I, personally, don't want to end up with type errors between two perfectly compatible objects, just because npm decided to nest the same copy of a node module under different directories.\r\n\r\nSounds like an issue with your dependency management and not nominal types. This won't be a new issue for those of us concerned about frontend bundle bloat.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">I, personally, don't want to end up with type errors between two perfectly compatible objects, just because npm decided to nest the same copy of a node module under different directories.</p>\n</blockquote>\n<p dir=\"auto\">Sounds like an issue with your dependency management and not nominal types. This won't be a new issue for those of us concerned about frontend bundle bloat.</p>",
        "createdAt": "2023-02-23T18:53:16Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442271679",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V-V6Q",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "> Sounds like an issue with your dependency management and not nominal types.\r\n\r\nIts an issue with npm dependency management in general, and the price to pay for the way JS package managers enable multiple versions to coexist in a single project (in an effort to combat the previous \"dependency hell\" issues of ecosystems like Ruby's). \r\n\r\nTake a look at the structure of your `node_modules` - you might be surprised.\r\n\r\nThere are plenty of development (tool) dependencies that also get installed in `node_modules` and participate in creating this problem (without affecting bundle sizes). \r\n\r\nedit: I ran this on a fresh `yarn create next-app`  example:\r\n\r\n```\r\n% find . -type d | egrep 'node_modules/[^/]+/node_modules/[^/]+$' | grep -v '.bin$' | wc -l\r\n12\r\n```\r\n\r\nThere are 12 doubly-nested node_modules. If we remove duplicates\r\n\r\n```\r\n% find . -type d | egrep 'node_modules/[^/]+/node_modules/[^/]+$' | grep -v '.bin$' | sed 's/node_modules\\/[^/]*//' | sort | uniq | wc -l\r\n8\r\n```\r\n\r\nwhich means there are at least 4 extra copies of existing module(s).\r\n\r\nedit 2: npm results:\r\n\r\n```\r\n% find . -type d | egrep 'node_modules/[^/]+/node_modules/[^/]+$' | grep -v '.bin$' | sed 's/node_modules\\/[^/]*//' | sort | wc -l       \r\n14\r\n\r\n% find . -type d | egrep 'node_modules/[^/]+/node_modules/[^/]+$' | grep -v '.bin$' | sed 's/node_modules\\/[^/]*//' | sort | uniq | wc -l\r\n9\r\n```\r\n\r\nI am *legitimately* worried that this will become a serious problem if TS implements nominal types and libraries start using them.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">Sounds like an issue with your dependency management and not nominal types.</p>\n</blockquote>\n<p dir=\"auto\">Its an issue with npm dependency management in general, and the price to pay for the way JS package managers enable multiple versions to coexist in a single project (in an effort to combat the previous \"dependency hell\" issues of ecosystems like Ruby's).</p>\n<p dir=\"auto\">Take a look at the structure of your <code class=\"notranslate\">node_modules</code> - you might be surprised.</p>\n<p dir=\"auto\">There are plenty of development (tool) dependencies that also get installed in <code class=\"notranslate\">node_modules</code> and participate in creating this problem (without affecting bundle sizes).</p>\n<p dir=\"auto\">edit: I ran this on a fresh <code class=\"notranslate\">yarn create next-app</code>  example:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"% find . -type d | egrep 'node_modules/[^/]+/node_modules/[^/]+$' | grep -v '.bin$' | wc -l\n12\"><pre class=\"notranslate\"><code class=\"notranslate\">% find . -type d | egrep 'node_modules/[^/]+/node_modules/[^/]+$' | grep -v '.bin$' | wc -l\n12\n</code></pre></div>\n<p dir=\"auto\">There are 12 doubly-nested node_modules. If we remove duplicates</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"% find . -type d | egrep 'node_modules/[^/]+/node_modules/[^/]+$' | grep -v '.bin$' | sed 's/node_modules\\/[^/]*//' | sort | uniq | wc -l\n8\"><pre class=\"notranslate\"><code class=\"notranslate\">% find . -type d | egrep 'node_modules/[^/]+/node_modules/[^/]+$' | grep -v '.bin$' | sed 's/node_modules\\/[^/]*//' | sort | uniq | wc -l\n8\n</code></pre></div>\n<p dir=\"auto\">which means there are at least 4 extra copies of existing module(s).</p>\n<p dir=\"auto\">edit 2: npm results:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"% find . -type d | egrep 'node_modules/[^/]+/node_modules/[^/]+$' | grep -v '.bin$' | sed 's/node_modules\\/[^/]*//' | sort | wc -l       \n14\n\n% find . -type d | egrep 'node_modules/[^/]+/node_modules/[^/]+$' | grep -v '.bin$' | sed 's/node_modules\\/[^/]*//' | sort | uniq | wc -l\n9\"><pre class=\"notranslate\"><code class=\"notranslate\">% find . -type d | egrep 'node_modules/[^/]+/node_modules/[^/]+$' | grep -v '.bin$' | sed 's/node_modules\\/[^/]*//' | sort | wc -l       \n14\n\n% find . -type d | egrep 'node_modules/[^/]+/node_modules/[^/]+$' | grep -v '.bin$' | sed 's/node_modules\\/[^/]*//' | sort | uniq | wc -l\n9\n</code></pre></div>\n<p dir=\"auto\">I am <em>legitimately</em> worried that this will become a serious problem if TS implements nominal types and libraries start using them.</p>",
        "createdAt": "2023-02-23T20:43:52Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442406032",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V-eQr",
        "author": {
          "login": "binki"
        },
        "authorAssociation": "NONE",
        "body": "> > Sounds like an issue with your dependency management and not nominal types.\r\n> \r\n> Its an issue with npm dependency management in general, and the price to pay for the way JS package managers enable multiple versions to coexist in a single project (in an effort to combat the previous \"dependency hell\" issues of ecosystems like Ruby's).\r\n\r\nIs it just me or are you contradicting yourself?",
        "bodyHTML": "<blockquote>\n<blockquote>\n<p dir=\"auto\">Sounds like an issue with your dependency management and not nominal types.</p>\n</blockquote>\n<p dir=\"auto\">Its an issue with npm dependency management in general, and the price to pay for the way JS package managers enable multiple versions to coexist in a single project (in an effort to combat the previous \"dependency hell\" issues of ecosystems like Ruby's).</p>\n</blockquote>\n<p dir=\"auto\">Is it just me or are you contradicting yourself?</p>",
        "createdAt": "2023-02-23T21:13:28Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442440235",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V-pUX",
        "author": {
          "login": "codeandcats"
        },
        "authorAssociation": "NONE",
        "body": "I think TS assuming two different versions of a library containing the same nominal type are in fact different is not a bad default behaviour. After all they are different versions, who is to say that they are in fact compatible. As we know, even `instanceof` will think two copies of the same class are different.\r\n\r\nIf you want to pass a nominal type from one library to another and believe they are the same then you could always cast it.\r\n\r\nMaybe I’m not getting it (quite possible) but this still sounds like a dependency management issue. Don’t yarn and npm provide an overriding mechanism for resolving which version of a module should be used when installing a dependency?",
        "bodyHTML": "<p dir=\"auto\">I think TS assuming two different versions of a library containing the same nominal type are in fact different is not a bad default behaviour. After all they are different versions, who is to say that they are in fact compatible. As we know, even <code class=\"notranslate\">instanceof</code> will think two copies of the same class are different.</p>\n<p dir=\"auto\">If you want to pass a nominal type from one library to another and believe they are the same then you could always cast it.</p>\n<p dir=\"auto\">Maybe I’m not getting it (quite possible) but this still sounds like a dependency management issue. Don’t yarn and npm provide an overriding mechanism for resolving which version of a module should be used when installing a dependency?</p>",
        "createdAt": "2023-02-23T21:59:48Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442485527",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V-4SU",
        "author": {
          "login": "refactorized"
        },
        "authorAssociation": "NONE",
        "body": "> Regarding the actual point, please (everyone) don't spam feature request threads with arguments about whether a feature is \"too OOP\" or \"doesn't fit with the style of Javascript\" or whatever, without going into what actual issues it's likely to cause (at which point you don't need the general, derailing complaint)\r\n\r\nYeah, sorry about that, really.  \r\n\r\nI think my general argument is more constructively: \"please do not only consider which problems this feature solves, but what other costs might be associated with it, especially in terms of complexity vs clarity.\"\r\n\r\nAnd while I am apologizing, I am sorry a (probably well meaning) comment about me be confused put me in defensive butt-hurt mode.  Subsequent arguments were less coherent and much less constructive than they could have been.\r\n\r\nI should have asked better questions to learn from people with clearly different experiences and biases.  To those making a good faith effort to illuminate, thank you. ",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">Regarding the actual point, please (everyone) don't spam feature request threads with arguments about whether a feature is \"too OOP\" or \"doesn't fit with the style of Javascript\" or whatever, without going into what actual issues it's likely to cause (at which point you don't need the general, derailing complaint)</p>\n</blockquote>\n<p dir=\"auto\">Yeah, sorry about that, really.</p>\n<p dir=\"auto\">I think my general argument is more constructively: \"please do not only consider which problems this feature solves, but what other costs might be associated with it, especially in terms of complexity vs clarity.\"</p>\n<p dir=\"auto\">And while I am apologizing, I am sorry a (probably well meaning) comment about me be confused put me in defensive butt-hurt mode.  Subsequent arguments were less coherent and much less constructive than they could have been.</p>\n<p dir=\"auto\">I should have asked better questions to learn from people with clearly different experiences and biases.  To those making a good faith effort to illuminate, thank you.</p>",
        "createdAt": "2023-02-23T23:04:40Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442546836",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 8
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V-4Wy",
        "author": {
          "login": "patrys"
        },
        "authorAssociation": "NONE",
        "body": "I think we disagree on TypeScript’s role. To me, its task is to prevent false negatives at all cost. False positives are not desirable but are better than finding a bug at runtime. The “I hate that I have to explicitly cast objects because my stack has 8 copies of the same library” argument does not make sense if you accept that a false positive is preferable to a false negative.",
        "bodyHTML": "<p dir=\"auto\">I think we disagree on TypeScript’s role. To me, its task is to prevent false negatives at all cost. False positives are not desirable but are better than finding a bug at runtime. The “I hate that I have to explicitly cast objects because my stack has 8 copies of the same library” argument does not make sense if you accept that a false positive is preferable to a false negative.</p>",
        "createdAt": "2023-02-23T23:04:51Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442547122",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 12
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V-5sU",
        "author": {
          "login": "refactorized"
        },
        "authorAssociation": "NONE",
        "body": "> TypeScript is not a superset of JavaScript. If it were a superset of JavaScript, then JavaScript would be a subset of TypeScript and it would be impossible to write a JavaScript program which is not also TypeScript. The following is perfectly valid JavaScript but invalid TypeScript: [ ... lot's of interesting stuff ... ]\r\n\r\nI'm just using their own parlance - though admittedly examples are harder to find than I remember so maybe the TS team\r\nis deciding their audience might be a little more exacting in their understanding of sets: \r\n\r\nhttps://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html#a-typed-superset-of-javascript\r\n",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">TypeScript is not a superset of JavaScript. If it were a superset of JavaScript, then JavaScript would be a subset of TypeScript and it would be impossible to write a JavaScript program which is not also TypeScript. The following is perfectly valid JavaScript but invalid TypeScript: [ ... lot's of interesting stuff ... ]</p>\n</blockquote>\n<p dir=\"auto\">I'm just using their own parlance - though admittedly examples are harder to find than I remember so maybe the TS team<br>\nis deciding their audience might be a little more exacting in their understanding of sets:</p>\n<p dir=\"auto\"><a href=\"https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html#a-typed-superset-of-javascript\" rel=\"nofollow\">https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html#a-typed-superset-of-javascript</a></p>",
        "createdAt": "2023-02-23T23:10:03Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442552596",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V_B5h",
        "author": {
          "login": "binki"
        },
        "authorAssociation": "NONE",
        "body": "@codeandcats\r\n> If you want to pass a nominal type from one library to another and believe they are the same then you could always cast it.\r\n\r\nIf they are being treated as nominal types and they need to be treated as the same type, they should be defined in a third library which both of those libraries reference.\r\n\r\nAdding nominal typing support to TypeScript will not make everything which is currently being treated as structurally typed suddenly nominally typed. Deciding that something is nominal would done by the library author or TypeScript type declaration author.\r\n\r\nThis feature would be useful even without libraries. One of the use cases, a data model such as might be used with an ORM, which is a collection of types which are used together, will often include types with overlapping structures. And it is within such a context where distinguishing between conceptually different types to avoid type confusion is so important.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/codeandcats/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/codeandcats\">@codeandcats</a></p>\n<blockquote>\n<p dir=\"auto\">If you want to pass a nominal type from one library to another and believe they are the same then you could always cast it.</p>\n</blockquote>\n<p dir=\"auto\">If they are being treated as nominal types and they need to be treated as the same type, they should be defined in a third library which both of those libraries reference.</p>\n<p dir=\"auto\">Adding nominal typing support to TypeScript will not make everything which is currently being treated as structurally typed suddenly nominally typed. Deciding that something is nominal would done by the library author or TypeScript type declaration author.</p>\n<p dir=\"auto\">This feature would be useful even without libraries. One of the use cases, a data model such as might be used with an ORM, which is a collection of types which are used together, will often include types with overlapping structures. And it is within such a context where distinguishing between conceptually different types to avoid type confusion is so important.</p>",
        "createdAt": "2023-02-23T23:52:24Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442586209",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V_C8v",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "> I hate that I have to explicitly cast objects because my stack has 8 copies of the same library\r\n\r\nThe scenario looks more like this: \r\n\r\n- I use two libraries which return observables. Both using `cool-observable@2.0.0`\r\n- I added an eslint plugin, which happens to use `cool-observable@1.0.0`\r\n- npm decided the eslint plugin's own `cool-observable@1.0.0` goes to toplevel `node_modules` \r\n- The two libraries I use can no longer share a copy of `observable@2.0.0` because there can be only one version of a library in the toplevel `node_modules`\r\n- My project can no longer compile, as `myLib1.produceObservable().flatMap(v => otherLib.produceObservable(v))` yields type errors. \r\n\r\nThis nesting issue is frustrating, but unfortunately common even though it doesn't look like it (especially for \"foundational\" type libraries / shims and similar), and I think its  something worth being aware of before making a decision for nominal types. Hopefully one day all package managers will get pnpm's deduplicating behavior. \r\n\r\nTo be fair, I'd like to add that this wouldn't happen for application code, and nominal types are most useful there. \r\n\r\nI personally don't understand the reluctance about branded types - in my experience they don't necessarily require wrapper objects as long as you instruct the compiler to pretend that the primitive isn't a primitive. Even the error messages are not bad - for https://github.com/spion/branded-types the most verbose case is when you're using one branded type instead of another, which is when you get to see incompatibility with the other brand (but you can still get the type names to show up nicely)\r\n\r\n```\r\n./src/utils/other.ts:9:7\r\nType error: Argument of type 'UserId' is not assignable to parameter of type 'OrderId'.\r\n  Types of property '\"  kind\"' are incompatible.\r\n    Type '\"my-package.UserId\"' is not assignable to type '\"my-package.OrderId\"'.\r\n\r\n   7 | m.set(safeCreateOrderId(),  '1');\r\n   8 | \r\n>  9 | m.set(safeCreateUserId(),  '1');\r\n     |       ^\r\n```\r\n\r\nWith a bit of syntax sugar in the compiler this could work really nicely.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">I hate that I have to explicitly cast objects because my stack has 8 copies of the same library</p>\n</blockquote>\n<p dir=\"auto\">The scenario looks more like this:</p>\n<ul dir=\"auto\">\n<li>I use two libraries which return observables. Both using <code class=\"notranslate\">cool-observable@2.0.0</code></li>\n<li>I added an eslint plugin, which happens to use <code class=\"notranslate\">cool-observable@1.0.0</code></li>\n<li>npm decided the eslint plugin's own <code class=\"notranslate\">cool-observable@1.0.0</code> goes to toplevel <code class=\"notranslate\">node_modules</code></li>\n<li>The two libraries I use can no longer share a copy of <code class=\"notranslate\">observable@2.0.0</code> because there can be only one version of a library in the toplevel <code class=\"notranslate\">node_modules</code></li>\n<li>My project can no longer compile, as <code class=\"notranslate\">myLib1.produceObservable().flatMap(v =&gt; otherLib.produceObservable(v))</code> yields type errors.</li>\n</ul>\n<p dir=\"auto\">This nesting issue is frustrating, but unfortunately common even though it doesn't look like it (especially for \"foundational\" type libraries / shims and similar), and I think its  something worth being aware of before making a decision for nominal types. Hopefully one day all package managers will get pnpm's deduplicating behavior.</p>\n<p dir=\"auto\">To be fair, I'd like to add that this wouldn't happen for application code, and nominal types are most useful there.</p>\n<p dir=\"auto\">I personally don't understand the reluctance about branded types - in my experience they don't necessarily require wrapper objects as long as you instruct the compiler to pretend that the primitive isn't a primitive. Even the error messages are not bad - for <a href=\"https://github.com/spion/branded-types\">https://github.com/spion/branded-types</a> the most verbose case is when you're using one branded type instead of another, which is when you get to see incompatibility with the other brand (but you can still get the type names to show up nicely)</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"./src/utils/other.ts:9:7\nType error: Argument of type 'UserId' is not assignable to parameter of type 'OrderId'.\n  Types of property '&quot;  kind&quot;' are incompatible.\n    Type '&quot;my-package.UserId&quot;' is not assignable to type '&quot;my-package.OrderId&quot;'.\n\n   7 | m.set(safeCreateOrderId(),  '1');\n   8 | \n&gt;  9 | m.set(safeCreateUserId(),  '1');\n     |       ^\"><pre class=\"notranslate\"><code class=\"notranslate\">./src/utils/other.ts:9:7\nType error: Argument of type 'UserId' is not assignable to parameter of type 'OrderId'.\n  Types of property '\"  kind\"' are incompatible.\n    Type '\"my-package.UserId\"' is not assignable to type '\"my-package.OrderId\"'.\n\n   7 | m.set(safeCreateOrderId(),  '1');\n   8 | \n&gt;  9 | m.set(safeCreateUserId(),  '1');\n     |       ^\n</code></pre></div>\n<p dir=\"auto\">With a bit of syntax sugar in the compiler this could work really nicely.</p>",
        "createdAt": "2023-02-23T23:57:33Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442590511",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V_F2g",
        "author": {
          "login": "codeandcats"
        },
        "authorAssociation": "NONE",
        "body": "> I personally don't understand the reluctance about branded types - in my experience they don't necessarily require wrapper objects as long as you instruct the compiler to pretend that the primitive isn't a primitive.\r\n> …\r\n> With a bit of syntax sugar in the compiler this could work really nicely.\r\n\r\n@spion If you are instructing the compiler to pretend that a primitive is a branded type (i.e. it’s only a branded type at compile time), then what’s the difference between a branded type with syntactic sugar and a nominal type at that point? Hasn’t a branded type lost its unique meaning and we may as well refer to it as a nominal type?",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">I personally don't understand the reluctance about branded types - in my experience they don't necessarily require wrapper objects as long as you instruct the compiler to pretend that the primitive isn't a primitive.<br>\n…<br>\nWith a bit of syntax sugar in the compiler this could work really nicely.</p>\n</blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/spion/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/spion\">@spion</a> If you are instructing the compiler to pretend that a primitive is a branded type (i.e. it’s only a branded type at compile time), then what’s the difference between a branded type with syntactic sugar and a nominal type at that point? Hasn’t a branded type lost its unique meaning and we may as well refer to it as a nominal type?</p>",
        "createdAt": "2023-02-24T00:09:57Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442602400",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V_JA_",
        "author": {
          "login": "ljharb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@spion in that scenario, if peer deps were properly set up, `npm ls` would exit nonzero, which means your dep graph is invalid - so you can't expect *anything* to work right. The types have nothing to do with it.\r\n\r\nIf they were compatible, then the types would need to reflect somehow.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/spion/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/spion\">@spion</a> in that scenario, if peer deps were properly set up, <code class=\"notranslate\">npm ls</code> would exit nonzero, which means your dep graph is invalid - so you can't expect <em>anything</em> to work right. The types have nothing to do with it.</p>\n<p dir=\"auto\">If they were compatible, then the types would need to reflect somehow.</p>",
        "createdAt": "2023-02-24T00:25:01Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442615359",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V_JQD",
        "author": {
          "login": "unional"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> Hasn’t a branded type lost its unique meaning and we may as well refer to it as a nominal type?\r\n\r\nHi, I tried to follow the thread but a bit confused.\r\nWhat's the difference between the proposed nominal type vs branded type semantically?\r\n\r\nMy basic understanding is the nominal type is a category, there are classical nominal typing as in other languages and `class` in javascript.\r\n\r\nBranding and Flavor are two additional kind of nominal types, where branding is strong while flavoring is a bit weaker.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\">Hasn’t a branded type lost its unique meaning and we may as well refer to it as a nominal type?</p>\n</blockquote>\n<p dir=\"auto\">Hi, I tried to follow the thread but a bit confused.<br>\nWhat's the difference between the proposed nominal type vs branded type semantically?</p>\n<p dir=\"auto\">My basic understanding is the nominal type is a category, there are classical nominal typing as in other languages and <code class=\"notranslate\">class</code> in javascript.</p>\n<p dir=\"auto\">Branding and Flavor are two additional kind of nominal types, where branding is strong while flavoring is a bit weaker.</p>",
        "createdAt": "2023-02-24T00:26:09Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442616323",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V_Nft",
        "author": {
          "login": "spion"
        },
        "authorAssociation": "NONE",
        "body": "@ljharb Not sure I understand you, could you explain in more detail? \r\n\r\nFWIW, this situation can (and does) arise without the usage of peer dependencies.\r\n\r\nAnyway, this is what `npx create-next-app` produces:\r\n\r\n```\r\n% find . -type d | egrep 'node_modules/[^/]+/node_modules/[^/]+$' | grep -v '.bin$' | xargs -I {} bash -c 'echo $1 @ $(cat $1/package.json | jq .version)' _ {} | sort -k3 \r\n./node_modules/tsutils/node_modules/tslib @ \"1.14.1\"\r\n./node_modules/eslint-import-resolver-typescript/node_modules/globby @ \"13.1.3\"\r\n./node_modules/eslint-plugin-react/node_modules/resolve @ \"2.0.0-next.4\"\r\n./node_modules/eslint-plugin-import/node_modules/doctrine @ \"2.1.0\"\r\n./node_modules/eslint-plugin-react/node_modules/doctrine @ \"2.1.0\"\r\n./node_modules/eslint-utils/node_modules/eslint-visitor-keys @ \"2.1.0\"\r\n./node_modules/eslint-import-resolver-node/node_modules/debug @ \"3.2.7\"\r\n./node_modules/eslint-module-utils/node_modules/debug @ \"3.2.7\"\r\n./node_modules/eslint-plugin-import/node_modules/debug @ \"3.2.7\"\r\n./node_modules/eslint-import-resolver-typescript/node_modules/slash @ \"4.0.0\"\r\n./node_modules/fast-glob/node_modules/glob-parent @ \"5.1.2\"\r\n./node_modules/eslint-plugin-import/node_modules/semver @ \"6.3.0\"\r\n./node_modules/eslint-plugin-jsx-a11y/node_modules/semver @ \"6.3.0\"\r\n./node_modules/eslint-plugin-react/node_modules/semver @ \"6.3.0\"\r\n```\r\n\r\nDuplicated copies of doctrine, debug and semver, all of them the exact versions. This is due to different version being installed at toplevel:\r\n\r\n```\r\n./node_modules/eslint-plugin-import/node_modules/doctrine @ \"2.1.0\"\r\n./node_modules/eslint-plugin-react/node_modules/doctrine @ \"2.1.0\"\r\n./node_modules/doctrine @ \"3.0.0\"\r\n./node_modules/eslint-import-resolver-node/node_modules/debug @ \"3.2.7\"\r\n./node_modules/eslint-module-utils/node_modules/debug @ \"3.2.7\"\r\n./node_modules/eslint-plugin-import/node_modules/debug @ \"3.2.7\"\r\n./node_modules/debug @ \"4.3.4\"\r\n./node_modules/eslint-plugin-import/node_modules/semver @ \"6.3.0\"\r\n./node_modules/eslint-plugin-jsx-a11y/node_modules/semver @ \"6.3.0\"\r\n./node_modules/eslint-plugin-react/node_modules/semver @ \"6.3.0\"\r\n./node_modules/semver @ \"7.3.8\"\r\n```\r\n\r\n`npm ls` is still reporting no issues.\r\n\r\nLuckily, these are all utility dependencies that don't produce values that could be marked nominal (or any values for that matter). I'm not sure that would always be the case",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/ljharb/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ljharb\">@ljharb</a> Not sure I understand you, could you explain in more detail?</p>\n<p dir=\"auto\">FWIW, this situation can (and does) arise without the usage of peer dependencies.</p>\n<p dir=\"auto\">Anyway, this is what <code class=\"notranslate\">npx create-next-app</code> produces:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"% find . -type d | egrep 'node_modules/[^/]+/node_modules/[^/]+$' | grep -v '.bin$' | xargs -I {} bash -c 'echo $1 @ $(cat $1/package.json | jq .version)' _ {} | sort -k3 \n./node_modules/tsutils/node_modules/tslib @ &quot;1.14.1&quot;\n./node_modules/eslint-import-resolver-typescript/node_modules/globby @ &quot;13.1.3&quot;\n./node_modules/eslint-plugin-react/node_modules/resolve @ &quot;2.0.0-next.4&quot;\n./node_modules/eslint-plugin-import/node_modules/doctrine @ &quot;2.1.0&quot;\n./node_modules/eslint-plugin-react/node_modules/doctrine @ &quot;2.1.0&quot;\n./node_modules/eslint-utils/node_modules/eslint-visitor-keys @ &quot;2.1.0&quot;\n./node_modules/eslint-import-resolver-node/node_modules/debug @ &quot;3.2.7&quot;\n./node_modules/eslint-module-utils/node_modules/debug @ &quot;3.2.7&quot;\n./node_modules/eslint-plugin-import/node_modules/debug @ &quot;3.2.7&quot;\n./node_modules/eslint-import-resolver-typescript/node_modules/slash @ &quot;4.0.0&quot;\n./node_modules/fast-glob/node_modules/glob-parent @ &quot;5.1.2&quot;\n./node_modules/eslint-plugin-import/node_modules/semver @ &quot;6.3.0&quot;\n./node_modules/eslint-plugin-jsx-a11y/node_modules/semver @ &quot;6.3.0&quot;\n./node_modules/eslint-plugin-react/node_modules/semver @ &quot;6.3.0&quot;\"><pre class=\"notranslate\"><code class=\"notranslate\">% find . -type d | egrep 'node_modules/[^/]+/node_modules/[^/]+$' | grep -v '.bin$' | xargs -I {} bash -c 'echo $1 @ $(cat $1/package.json | jq .version)' _ {} | sort -k3 \n./node_modules/tsutils/node_modules/tslib @ \"1.14.1\"\n./node_modules/eslint-import-resolver-typescript/node_modules/globby @ \"13.1.3\"\n./node_modules/eslint-plugin-react/node_modules/resolve @ \"2.0.0-next.4\"\n./node_modules/eslint-plugin-import/node_modules/doctrine @ \"2.1.0\"\n./node_modules/eslint-plugin-react/node_modules/doctrine @ \"2.1.0\"\n./node_modules/eslint-utils/node_modules/eslint-visitor-keys @ \"2.1.0\"\n./node_modules/eslint-import-resolver-node/node_modules/debug @ \"3.2.7\"\n./node_modules/eslint-module-utils/node_modules/debug @ \"3.2.7\"\n./node_modules/eslint-plugin-import/node_modules/debug @ \"3.2.7\"\n./node_modules/eslint-import-resolver-typescript/node_modules/slash @ \"4.0.0\"\n./node_modules/fast-glob/node_modules/glob-parent @ \"5.1.2\"\n./node_modules/eslint-plugin-import/node_modules/semver @ \"6.3.0\"\n./node_modules/eslint-plugin-jsx-a11y/node_modules/semver @ \"6.3.0\"\n./node_modules/eslint-plugin-react/node_modules/semver @ \"6.3.0\"\n</code></pre></div>\n<p dir=\"auto\">Duplicated copies of doctrine, debug and semver, all of them the exact versions. This is due to different version being installed at toplevel:</p>\n<div class=\"snippet-clipboard-content notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"./node_modules/eslint-plugin-import/node_modules/doctrine @ &quot;2.1.0&quot;\n./node_modules/eslint-plugin-react/node_modules/doctrine @ &quot;2.1.0&quot;\n./node_modules/doctrine @ &quot;3.0.0&quot;\n./node_modules/eslint-import-resolver-node/node_modules/debug @ &quot;3.2.7&quot;\n./node_modules/eslint-module-utils/node_modules/debug @ &quot;3.2.7&quot;\n./node_modules/eslint-plugin-import/node_modules/debug @ &quot;3.2.7&quot;\n./node_modules/debug @ &quot;4.3.4&quot;\n./node_modules/eslint-plugin-import/node_modules/semver @ &quot;6.3.0&quot;\n./node_modules/eslint-plugin-jsx-a11y/node_modules/semver @ &quot;6.3.0&quot;\n./node_modules/eslint-plugin-react/node_modules/semver @ &quot;6.3.0&quot;\n./node_modules/semver @ &quot;7.3.8&quot;\"><pre class=\"notranslate\"><code class=\"notranslate\">./node_modules/eslint-plugin-import/node_modules/doctrine @ \"2.1.0\"\n./node_modules/eslint-plugin-react/node_modules/doctrine @ \"2.1.0\"\n./node_modules/doctrine @ \"3.0.0\"\n./node_modules/eslint-import-resolver-node/node_modules/debug @ \"3.2.7\"\n./node_modules/eslint-module-utils/node_modules/debug @ \"3.2.7\"\n./node_modules/eslint-plugin-import/node_modules/debug @ \"3.2.7\"\n./node_modules/debug @ \"4.3.4\"\n./node_modules/eslint-plugin-import/node_modules/semver @ \"6.3.0\"\n./node_modules/eslint-plugin-jsx-a11y/node_modules/semver @ \"6.3.0\"\n./node_modules/eslint-plugin-react/node_modules/semver @ \"6.3.0\"\n./node_modules/semver @ \"7.3.8\"\n</code></pre></div>\n<p dir=\"auto\"><code class=\"notranslate\">npm ls</code> is still reporting no issues.</p>\n<p dir=\"auto\">Luckily, these are all utility dependencies that don't produce values that could be marked nominal (or any values for that matter). I'm not sure that would always be the case</p>",
        "createdAt": "2023-02-24T00:48:32Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442633709",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5V_mE3",
        "author": {
          "login": "MicahZoltu"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Dev dependencies impacting project type checking is certainly a real problem for ambient types, but really no one should be using ambient types (especially not build tooling).  My weak argument here is that if you have dependencies installing ambient nominal types you should find new dependencies.  There are a bunch of ways a dependency can do bad things, and rather than constraining the language to limit the set of bad things they can do, I think we (developer community) should \"boycott\" dependencies that misbehave.",
        "bodyHTML": "<p dir=\"auto\">Dev dependencies impacting project type checking is certainly a real problem for ambient types, but really no one should be using ambient types (especially not build tooling).  My weak argument here is that if you have dependencies installing ambient nominal types you should find new dependencies.  There are a bunch of ways a dependency can do bad things, and rather than constraining the language to limit the set of bad things they can do, I think we (developer community) should \"boycott\" dependencies that misbehave.</p>",
        "createdAt": "2023-02-24T03:05:12Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1442734391",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5WCWng",
        "author": {
          "login": "Conaclos"
        },
        "authorAssociation": "NONE",
        "body": "@spion I see your point. It is something you can encounter with [Dual package hazard](https://nodejs.org/api/packages.html#dual-package-hazard).\r\n\r\n- However, nominal typing for classes at the type level could help to detect dual package loading.\r\n  By treating classes structurally, you are not able to detect issues with `instanceof`.\r\n  For example:\r\n\r\n  ```ts\r\n  //@filename: footgun.ts\r\n  export class Foo {}\r\n  export class Bar {}\r\n  export function name(x: Foo | Bar): string {\r\n    if (x instanceof Foo) {\r\n      return \"Foo\"\r\n    } else {\r\n      return \"Bar\"\r\n    }\r\n  }\r\n\r\n  //@filename: index.ts\r\n  import { name  } from \"./footgun.js\"\r\n  import { Foo  } from \"./footgun.js?x=x\"\r\n\r\n  console.log(name(new Foo())) //=> Bar\r\n  ```\r\n\r\n- The current proposal has no impact at runtime. Thus, dual package loading could just cause issues at the type level.\r\n  Branded types could, indeed, avoid the issue at the type level.\r\n  However, I prefer starting with strict nominal types and later relaxing to branded type if issues are too frequent.\r\n  The brand could simply be the type name:\r\n\r\n  ```ts\r\n  // this could later be considered as a branded type with brand \"Meter\"\r\n  export unique type Meter = number\r\n  ```\r\n    ",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/spion/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/spion\">@spion</a> I see your point. It is something you can encounter with <a href=\"https://nodejs.org/api/packages.html#dual-package-hazard\" rel=\"nofollow\">Dual package hazard</a>.</p>\n<ul dir=\"auto\">\n<li>\n<p dir=\"auto\">However, nominal typing for classes at the type level could help to detect dual package loading.<br>\nBy treating classes structurally, you are not able to detect issues with <code class=\"notranslate\">instanceof</code>.<br>\nFor example:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"//@filename: footgun.ts\nexport class Foo {}\nexport class Bar {}\nexport function name(x: Foo | Bar): string {\n  if (x instanceof Foo) {\n    return &quot;Foo&quot;\n  } else {\n    return &quot;Bar&quot;\n  }\n}\n\n//@filename: index.ts\nimport { name  } from &quot;./footgun.js&quot;\nimport { Foo  } from &quot;./footgun.js?x=x&quot;\n\nconsole.log(name(new Foo())) //=&gt; Bar\"><pre class=\"notranslate\"><span class=\"pl-c\">//<span class=\"pl-k\">@filename</span>: footgun.ts</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">class</span> <span class=\"pl-smi\">Foo</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">class</span> <span class=\"pl-smi\">Bar</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">function</span> <span class=\"pl-en\">name</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">Foo</span> <span class=\"pl-c1\">|</span> <span class=\"pl-smi\">Bar</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\">string</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span> <span class=\"pl-k\">instanceof</span> <span class=\"pl-smi\">Foo</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-s\">\"Foo\"</span>\n  <span class=\"pl-kos\">}</span> <span class=\"pl-k\">else</span> <span class=\"pl-kos\">{</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-s\">\"Bar\"</span>\n  <span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-c\">//<span class=\"pl-k\">@filename</span>: index.ts</span>\n<span class=\"pl-k\">import</span> <span class=\"pl-kos\">{</span> <span class=\"pl-s1\">name</span>  <span class=\"pl-kos\">}</span> <span class=\"pl-k\">from</span> <span class=\"pl-s\">\"./footgun.js\"</span>\n<span class=\"pl-k\">import</span> <span class=\"pl-kos\">{</span> <span class=\"pl-smi\">Foo</span>  <span class=\"pl-kos\">}</span> <span class=\"pl-k\">from</span> <span class=\"pl-s\">\"./footgun.js?x=x\"</span>\n\n<span class=\"pl-smi\">console</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-en\">name</span><span class=\"pl-kos\">(</span><span class=\"pl-k\">new</span> <span class=\"pl-smi\">Foo</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span> <span class=\"pl-c\">//=&gt; Bar</span></pre></div>\n</li>\n<li>\n<p dir=\"auto\">The current proposal has no impact at runtime. Thus, dual package loading could just cause issues at the type level.<br>\nBranded types could, indeed, avoid the issue at the type level.<br>\nHowever, I prefer starting with strict nominal types and later relaxing to branded type if issues are too frequent.<br>\nThe brand could simply be the type name:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// this could later be considered as a branded type with brand &quot;Meter&quot;\nexport unique type Meter = number\"><pre class=\"notranslate\"><span class=\"pl-c\">// this could later be considered as a branded type with brand \"Meter\"</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-s1\">unique</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Meter</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">number</span></pre></div>\n</li>\n</ul>",
        "createdAt": "2023-02-24T10:38:31Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1443457504",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5WENDZ",
        "author": {
          "login": "ljharb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@spion nominal types would be used whenever identity mattered, which is also when peer deps would be used. Using one without the other would simply be a bug.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/spion/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/spion\">@spion</a> nominal types would be used whenever identity mattered, which is also when peer deps would be used. Using one without the other would simply be a bug.</p>",
        "createdAt": "2023-02-24T16:19:57Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1443942617",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5WEcL7",
        "author": {
          "login": "RyanCavanaugh"
        },
        "authorAssociation": "MEMBER",
        "body": "The situation on my side for the last ~12 months has been a steady stream that looks like this:\r\n\r\n1. (User) \"TypeScript's module resolver is broken; here is my repo\"\r\n2. (Us) No, everything is working per spec. One of your dependencies has a misconfigured package.json export map / .d.ts / build setting / file extension / path mapping / import map / dependency specification\r\n3. (User) \"OK What do I do?\"\r\n4. (Us) The upstream package needs to be fixed\r\n5. (User) \"But I'm not in control of that, so I need a flag to silence the error or otherwise change TS's behavior. This is a reasonable request because, at runtime, everything is working fine\"\r\n6. (Us) ... hmm.\r\n\r\nPiling on another list of things to step 2 where \"it works fine at runtime but TS detects some purely hypothetical problem\" sounds extremely unappealing.",
        "bodyHTML": "<p dir=\"auto\">The situation on my side for the last ~12 months has been a steady stream that looks like this:</p>\n<ol dir=\"auto\">\n<li>(User) \"TypeScript's module resolver is broken; here is my repo\"</li>\n<li>(Us) No, everything is working per spec. One of your dependencies has a misconfigured package.json export map / .d.ts / build setting / file extension / path mapping / import map / dependency specification</li>\n<li>(User) \"OK What do I do?\"</li>\n<li>(Us) The upstream package needs to be fixed</li>\n<li>(User) \"But I'm not in control of that, so I need a flag to silence the error or otherwise change TS's behavior. This is a reasonable request because, at runtime, everything is working fine\"</li>\n<li>(Us) ... hmm.</li>\n</ol>\n<p dir=\"auto\">Piling on another list of things to step 2 where \"it works fine at runtime but TS detects some purely hypothetical problem\" sounds extremely unappealing.</p>",
        "createdAt": "2023-02-24T16:50:59Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1444004603",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 7
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5WFCRx",
        "author": {
          "login": "Pauan"
        },
        "authorAssociation": "NONE",
        "body": "Isn't step 5 solved by things like `emitOnError`, `as any`, `// @ts-ignore` etc.?\r\n\r\nThere are a million things that a package can do that can cause errors downstream, that's a separate issue from nominal types.\r\n\r\nEven just recently, the `@types/d3-hierarchy` package added a [single line of code](https://github.com/DefinitelyTyped/DefinitelyTyped/commit/3981510079a7ca7b3d4f0ca6674baa03e65c0c61#diff-c00ddabcfd72406d3d69a30016f953a4a3fe30a4573efdd1d6fa4ea6a90cec77R30) which broke downstream packages, because it silently changed the variance of the class.\r\n\r\nDoes that mean that generic variance is a bad feature which should never have been added to TypeScript? No. That's not the right way to judge features. By that logic, we should never add new features to TypeScript, because there's always the potential for packages to misuse those features and break code.\r\n\r\nI think the discussion about package resolution and duplication is unrelated to nominal types, because duplicate packages cause a lot of headache regardless of whether nominal types exist or not.\r\n\r\nAlso, I must once again remind everybody that TypeScript and JavaScript already have nominal types. A class that has a private property is already nominal in TypeScript, and thus it has all of the same breakage problems with duplicate packages. Package breakage is not a new problem, nominal types are not a new feature, they already exist. So the arguments about duplicate packages are not a counter-argument against nominal types.",
        "bodyHTML": "<p dir=\"auto\">Isn't step 5 solved by things like <code class=\"notranslate\">emitOnError</code>, <code class=\"notranslate\">as any</code>, <code class=\"notranslate\">// @ts-ignore</code> etc.?</p>\n<p dir=\"auto\">There are a million things that a package can do that can cause errors downstream, that's a separate issue from nominal types.</p>\n<p dir=\"auto\">Even just recently, the <code class=\"notranslate\">@types/d3-hierarchy</code> package added a <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/commit/3981510079a7ca7b3d4f0ca6674baa03e65c0c61#diff-c00ddabcfd72406d3d69a30016f953a4a3fe30a4573efdd1d6fa4ea6a90cec77R30\">single line of code</a> which broke downstream packages, because it silently changed the variance of the class.</p>\n<p dir=\"auto\">Does that mean that generic variance is a bad feature which should never have been added to TypeScript? No. That's not the right way to judge features. By that logic, we should never add new features to TypeScript, because there's always the potential for packages to misuse those features and break code.</p>\n<p dir=\"auto\">I think the discussion about package resolution and duplication is unrelated to nominal types, because duplicate packages cause a lot of headache regardless of whether nominal types exist or not.</p>\n<p dir=\"auto\">Also, I must once again remind everybody that TypeScript and JavaScript already have nominal types. A class that has a private property is already nominal in TypeScript, and thus it has all of the same breakage problems with duplicate packages. Package breakage is not a new problem, nominal types are not a new feature, they already exist. So the arguments about duplicate packages are not a counter-argument against nominal types.</p>",
        "createdAt": "2023-02-24T18:04:41Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1444160625",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 11
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5ZR3BL",
        "author": {
          "login": "christianwish"
        },
        "authorAssociation": "NONE",
        "body": "I use a workaround with `Symbol` and the \"brand mechanism\".\r\nThe disadvantage is that `nominalSymbol` is created once. So this is a tiny overhead in the output.\r\n\r\n```typescript\r\nconst nominalSymbol: unique symbol = Symbol(); // This is a small overhead in the JS output\r\n\r\ntype Nominal<T extends string, U> = U & { [nominalSymbol]: T };\r\n\r\n// example with objects\r\ntype User =  Nominal<'User', { name: string }>;\r\ntype Product = Nominal<'Product', { name: string }>;\r\n\r\nconst user = { name: 'username' } as User;\r\nconst product = { name: 'product' } as Product;\r\n\r\nfunction forceTsTypeError(u: User):void {}\r\n\r\nforceTsTypeError(user);\r\nforceTsTypeError(product);\r\n// --------------^^^^^^^ Type '\"Product\"' is not assignable to type '\"User\"'.\r\n\r\n// example with primitives\r\n\r\ntype ID = Nominal<'ID', string>;\r\ntype Name = Nominal<'Name', string>;\r\n\r\nconst id = 'id string' as ID;\r\nconst name = 'jondoe' as Name;\r\n\r\n\r\nfunction forceTsTypeError2(id: ID):void {}\r\n\r\nforceTsTypeError2(id);\r\nforceTsTypeError2(name);\r\n// ---------------^^^^ Type '\"Name\"' is not assignable to type '\"ID\"'.\r\n\r\n```",
        "bodyHTML": "<p dir=\"auto\">I use a workaround with <code class=\"notranslate\">Symbol</code> and the \"brand mechanism\".<br>\nThe disadvantage is that <code class=\"notranslate\">nominalSymbol</code> is created once. So this is a tiny overhead in the output.</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"const nominalSymbol: unique symbol = Symbol(); // This is a small overhead in the JS output\n\ntype Nominal&lt;T extends string, U&gt; = U &amp; { [nominalSymbol]: T };\n\n// example with objects\ntype User =  Nominal&lt;'User', { name: string }&gt;;\ntype Product = Nominal&lt;'Product', { name: string }&gt;;\n\nconst user = { name: 'username' } as User;\nconst product = { name: 'product' } as Product;\n\nfunction forceTsTypeError(u: User):void {}\n\nforceTsTypeError(user);\nforceTsTypeError(product);\n// --------------^^^^^^^ Type '&quot;Product&quot;' is not assignable to type '&quot;User&quot;'.\n\n// example with primitives\n\ntype ID = Nominal&lt;'ID', string&gt;;\ntype Name = Nominal&lt;'Name', string&gt;;\n\nconst id = 'id string' as ID;\nconst name = 'jondoe' as Name;\n\n\nfunction forceTsTypeError2(id: ID):void {}\n\nforceTsTypeError2(id);\nforceTsTypeError2(name);\n// ---------------^^^^ Type '&quot;Name&quot;' is not assignable to type '&quot;ID&quot;'.\n\"><pre class=\"notranslate\"><span class=\"pl-k\">const</span> <span class=\"pl-s1\">nominalSymbol</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Symbol</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// This is a small overhead in the JS output</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">U</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">U</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">[</span><span class=\"pl-s1\">nominalSymbol</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">T</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// example with objects</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">User</span> <span class=\"pl-c1\">=</span>  <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'User'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">name</span>: <span class=\"pl-smi\">string</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Product</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'Product'</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">name</span>: <span class=\"pl-smi\">string</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">user</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">name</span>: <span class=\"pl-s\">'username'</span> <span class=\"pl-kos\">}</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">User</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">product</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">name</span>: <span class=\"pl-s\">'product'</span> <span class=\"pl-kos\">}</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Product</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">forceTsTypeError</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">u</span>: <span class=\"pl-smi\">User</span><span class=\"pl-kos\">)</span>:<span class=\"pl-smi\"><span class=\"pl-k\">void</span></span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n\n<span class=\"pl-en\">forceTsTypeError</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">user</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-en\">forceTsTypeError</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">product</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-c\">// --------------^^^^^^^ Type '\"Product\"' is not assignable to type '\"User\"'.</span>\n\n<span class=\"pl-c\">// example with primitives</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">ID</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'ID'</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">string</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">Name</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'Name'</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">string</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">id</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'id string'</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">ID</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">name</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'jondoe'</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">Name</span><span class=\"pl-kos\">;</span>\n\n\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">forceTsTypeError2</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">id</span>: <span class=\"pl-smi\">ID</span><span class=\"pl-kos\">)</span>:<span class=\"pl-smi\"><span class=\"pl-k\">void</span></span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span>\n\n<span class=\"pl-en\">forceTsTypeError2</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">id</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-en\">forceTsTypeError2</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">name</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-c\">// ---------------^^^^ Type '\"Name\"' is not assignable to type '\"ID\"'.</span></pre></div>",
        "createdAt": "2023-04-05T17:19:38Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1497854027",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 4
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5ZR4fB",
        "author": {
          "login": "StreetStrider"
        },
        "authorAssociation": "NONE",
        "body": "@christianwish \r\nI believe even this symbol can be eliminated, since it is not mentioned in any runtime code. It is only in `type Nominal`. I believe you can `declare const foo: unique symbol` and use it. At least, this approach worked for me multiple times. Including vanilla JS + d.ts scenario.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/christianwish/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/christianwish\">@christianwish</a><br>\nI believe even this symbol can be eliminated, since it is not mentioned in any runtime code. It is only in <code class=\"notranslate\">type Nominal</code>. I believe you can <code class=\"notranslate\">declare const foo: unique symbol</code> and use it. At least, this approach worked for me multiple times. Including vanilla JS + d.ts scenario.</p>",
        "createdAt": "2023-04-05T17:25:06Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1497860033",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 5
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5ZR61g",
        "author": {
          "login": "christianwish"
        },
        "authorAssociation": "NONE",
        "body": "> @christianwish I believe even this symbol can be eliminated, since it is not mentioned in any runtime code. It is only in `type Nominal`. I believe you can `declare const foo: unique symbol` and use it. At least, this approach worked for me multiple times. Including vanilla JS + d.ts scenario.\r\n\r\n@StreetStrider You are right. `declare const nominalSymbol: unique symbol` does the job.\r\nSo this is a very close solution for nominial types for me.",
        "bodyHTML": "<blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/christianwish/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/christianwish\">@christianwish</a> I believe even this symbol can be eliminated, since it is not mentioned in any runtime code. It is only in <code class=\"notranslate\">type Nominal</code>. I believe you can <code class=\"notranslate\">declare const foo: unique symbol</code> and use it. At least, this approach worked for me multiple times. Including vanilla JS + d.ts scenario.</p>\n</blockquote>\n<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/StreetStrider/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/StreetStrider\">@StreetStrider</a> You are right. <code class=\"notranslate\">declare const nominalSymbol: unique symbol</code> does the job.<br>\nSo this is a very close solution for nominial types for me.</p>",
        "createdAt": "2023-04-05T17:33:59Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1497869664",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5ZTKhB",
        "author": {
          "login": "Conaclos"
        },
        "authorAssociation": "NONE",
        "body": "My personal workaround is as follows:\r\n\r\n```ts\r\ndeclare const USER_BRAND: unique symbol\r\n\r\ntype User = { name: string, [USER_BRAND]: never }\r\n```",
        "bodyHTML": "<p dir=\"auto\">My personal workaround is as follows:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"declare const USER_BRAND: unique symbol\n\ntype User = { name: string, [USER_BRAND]: never }\"><pre class=\"notranslate\"><span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">USER_BRAND</span>: <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">symbol</span>\n\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">User</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span> <span class=\"pl-c1\">name</span>: <span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-kos\">[</span><span class=\"pl-smi\">USER_BRAND</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">never</span> <span class=\"pl-kos\">}</span></pre></div>",
        "createdAt": "2023-04-05T21:41:32Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1498196033",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 3
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5ZksXC",
        "author": {
          "login": "Shinigami92"
        },
        "authorAssociation": "NONE",
        "body": "@christianwish and @Conaclos \r\nHow is it possible to extend from a nominal type?\r\n\r\nI mean like this: [TS Playground](https://www.typescriptlang.org/play?#code/PTAEFpNA7B7BbAltAhgGwpAUFgJgUwGM0UAnfUQ2aAZwBcYFl0BlAT3gCNY0AuUAK7REARwEUaHbmgDcOfAA8ADrFIM6bJRQByTVGgA8AFVCK6+aLhqh6pZAHMANKACqAPlABeV6ABkoAG9QAG04JH12Lh4AXX4TAF85LBBMcEZw9FBEXFT5ZVV1TR1YAgBJHO9dDMMAcl0y3BrnWwc3JJTINIAzRFJ6UBI2fFJcrEUVNVANLVAAWXxcRBRyr1Aq5lr5xeXG53r8cracDqgaImocweHR8YKpotAWOnIUeBXKvXQDGqeXt925gslockrdJtMKAA1bL4WDvNafWrQghwgFbYG4I5jfLgh6leAoewHCoI6rffGE4lNQHbEHHMCdKb4ejWTo4Ki0BjwIE7fjonarGrwAD62RqoBQ1n55TkHP6tnwr3K-F+iv+gpoosaEusqqVuFl1H6ADcYaj+MjYfCasateLJaBLaiknKGAoVc81fDubSDaAUjQABawARoHKcCjG9DZLCu0BsD1-eEK-Uyf1gIMhsOgCOgKNoGNxgBeia9JNNKJl6ZswdD4YoyHzMawXSEhDoiGoUxQAGt8Hr-gAKGil-UASn4xtg2UCWFAoHIdAEpGgcniODovf7nv1g59GLHaYDtezuabuCwm77A-Kw53-0P1czdZzkejF6v26TuEHFatuEfY8s3rLJoHPLAgA)\r\n\r\n```ts\r\n// --- nominal ---\r\n\r\ndeclare const nominalSymbol: unique symbol;\r\n\r\nexport type Nominal<T extends string, U> = U & { [nominalSymbol]: T };\r\n\r\n// --- nominal id ---\r\n\r\nexport type NodeId = Nominal<'NodeId', string>;\r\n\r\n// --- first layer ---\r\n\r\nexport type MediaId = Nominal<'MediaId', NodeId>;\r\n\r\n// --- second layer ---\r\n\r\nexport type StreamId = Nominal<'StreamId', MediaId>;\r\n\r\nexport type VideoId = Nominal<'VideoId', MediaId>;\r\n\r\nexport type ImageId = Nominal<'ImageId', MediaId>;\r\n\r\n// --- tests ---\r\n\r\nconst mediaId: MediaId = 'm_id' as MediaId;\r\nconst streamId: StreamId = 's_id' as StreamId;\r\nconst videoId: VideoId = 'v_id' as VideoId;\r\n\r\nconst x: StreamId = mediaId; // should be valid\r\nconst y: StreamId = streamId; // should be valid\r\nconst z: StreamId = videoId; // should be invalid\r\n\r\nfunction takeStreamId(s: StreamId): void {\r\n  return;\r\n}\r\n\r\ntakeStreamId(mediaId); // should be valid\r\ntakeStreamId(streamId); // should be valid\r\ntakeStreamId(videoId); // should be invalid\r\n```",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/christianwish/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/christianwish\">@christianwish</a> and <a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Conaclos/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Conaclos\">@Conaclos</a><br>\nHow is it possible to extend from a nominal type?</p>\n<p dir=\"auto\">I mean like this: <a href=\"https://www.typescriptlang.org/play?#code/PTAEFpNA7B7BbAltAhgGwpAUFgJgUwGM0UAnfUQ2aAZwBcYFl0BlAT3gCNY0AuUAK7REARwEUaHbmgDcOfAA8ADrFIM6bJRQByTVGgA8AFVCK6+aLhqh6pZAHMANKACqAPlABeV6ABkoAG9QAG04JH12Lh4AXX4TAF85LBBMcEZw9FBEXFT5ZVV1TR1YAgBJHO9dDMMAcl0y3BrnWwc3JJTINIAzRFJ6UBI2fFJcrEUVNVANLVAAWXxcRBRyr1Aq5lr5xeXG53r8cracDqgaImocweHR8YKpotAWOnIUeBXKvXQDGqeXt925gslockrdJtMKAA1bL4WDvNafWrQghwgFbYG4I5jfLgh6leAoewHCoI6rffGE4lNQHbEHHMCdKb4ejWTo4Ki0BjwIE7fjonarGrwAD62RqoBQ1n55TkHP6tnwr3K-F+iv+gpoosaEusqqVuFl1H6ADcYaj+MjYfCasateLJaBLaiknKGAoVc81fDubSDaAUjQABawARoHKcCjG9DZLCu0BsD1-eEK-Uyf1gIMhsOgCOgKNoGNxgBeia9JNNKJl6ZswdD4YoyHzMawXSEhDoiGoUxQAGt8Hr-gAKGil-UASn4xtg2UCWFAoHIdAEpGgcniODovf7nv1g59GLHaYDtezuabuCwm77A-Kw53-0P1czdZzkejF6v26TuEHFatuEfY8s3rLJoHPLAgA\" rel=\"nofollow\">TS Playground</a></p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"// --- nominal ---\n\ndeclare const nominalSymbol: unique symbol;\n\nexport type Nominal&lt;T extends string, U&gt; = U &amp; { [nominalSymbol]: T };\n\n// --- nominal id ---\n\nexport type NodeId = Nominal&lt;'NodeId', string&gt;;\n\n// --- first layer ---\n\nexport type MediaId = Nominal&lt;'MediaId', NodeId&gt;;\n\n// --- second layer ---\n\nexport type StreamId = Nominal&lt;'StreamId', MediaId&gt;;\n\nexport type VideoId = Nominal&lt;'VideoId', MediaId&gt;;\n\nexport type ImageId = Nominal&lt;'ImageId', MediaId&gt;;\n\n// --- tests ---\n\nconst mediaId: MediaId = 'm_id' as MediaId;\nconst streamId: StreamId = 's_id' as StreamId;\nconst videoId: VideoId = 'v_id' as VideoId;\n\nconst x: StreamId = mediaId; // should be valid\nconst y: StreamId = streamId; // should be valid\nconst z: StreamId = videoId; // should be invalid\n\nfunction takeStreamId(s: StreamId): void {\n  return;\n}\n\ntakeStreamId(mediaId); // should be valid\ntakeStreamId(streamId); // should be valid\ntakeStreamId(videoId); // should be invalid\"><pre class=\"notranslate\"><span class=\"pl-c\">// --- nominal ---</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-s1\">nominalSymbol</span>: <span class=\"pl-smi\">unique</span> <span class=\"pl-s1\">symbol</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span> <span class=\"pl-k\">extends</span> <span class=\"pl-smi\">string</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">U</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">U</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">[</span><span class=\"pl-s1\">nominalSymbol</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">T</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// --- nominal id ---</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">NodeId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'NodeId'</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">string</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// --- first layer ---</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">MediaId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'MediaId'</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">NodeId</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// --- second layer ---</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">StreamId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'StreamId'</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">MediaId</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">VideoId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'VideoId'</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">MediaId</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">ImageId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-s\">'ImageId'</span><span class=\"pl-kos\">,</span> <span class=\"pl-smi\">MediaId</span><span class=\"pl-kos\">&gt;</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// --- tests ---</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">mediaId</span>: <span class=\"pl-smi\">MediaId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'m_id'</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">MediaId</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">streamId</span>: <span class=\"pl-smi\">StreamId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'s_id'</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">StreamId</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">videoId</span>: <span class=\"pl-smi\">VideoId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'v_id'</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">VideoId</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">x</span>: <span class=\"pl-smi\">StreamId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">mediaId</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// should be valid</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">y</span>: <span class=\"pl-smi\">StreamId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">streamId</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// should be valid</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">z</span>: <span class=\"pl-smi\">StreamId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">videoId</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// should be invalid</span>\n\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">takeStreamId</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">s</span>: <span class=\"pl-smi\">StreamId</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\"><span class=\"pl-k\">void</span></span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">return</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-en\">takeStreamId</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">mediaId</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// should be valid</span>\n<span class=\"pl-en\">takeStreamId</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">streamId</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// should be valid</span>\n<span class=\"pl-en\">takeStreamId</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">videoId</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// should be invalid</span></pre></div>",
        "createdAt": "2023-04-11T07:09:08Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1502791106",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5ZmEh6",
        "author": {
          "login": "Conaclos"
        },
        "authorAssociation": "NONE",
        "body": "@Shinigami92\r\n\r\nI never did that: composition over inheritance/subtyping.\r\nHowever, if you really want to do that you can:\r\n\r\n```ts\r\ndeclare const MEDIA_ID_BRAND: unique symbol\r\ntype MediaId = { [MEDIA_ID_BRAND]: never }\r\n\r\ndeclare const STREAM_ID_BRAND: unique symbol\r\ntype StreamId = MediaId & { [STREAM_ID_BRAND]: never }\r\n\r\ndeclare const VIDEO_ID_BRAND: unique symbol\r\ntype VideoId = MediaId & { [VIDEO_ID_BRAND]: never }\r\n```\r\n\r\nBy the way your example seems invalid.\r\nWhy it should be valid to use a `MediaId` in place of `StreamId`? `MediaId` is not a sutype of `StreamId`",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Shinigami92/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Shinigami92\">@Shinigami92</a></p>\n<p dir=\"auto\">I never did that: composition over inheritance/subtyping.<br>\nHowever, if you really want to do that you can:</p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"declare const MEDIA_ID_BRAND: unique symbol\ntype MediaId = { [MEDIA_ID_BRAND]: never }\n\ndeclare const STREAM_ID_BRAND: unique symbol\ntype StreamId = MediaId &amp; { [STREAM_ID_BRAND]: never }\n\ndeclare const VIDEO_ID_BRAND: unique symbol\ntype VideoId = MediaId &amp; { [VIDEO_ID_BRAND]: never }\"><pre class=\"notranslate\"><span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">MEDIA_ID_BRAND</span>: <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">symbol</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">MediaId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">[</span><span class=\"pl-smi\">MEDIA_ID_BRAND</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">never</span> <span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">STREAM_ID_BRAND</span>: <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">symbol</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">StreamId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">MediaId</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">[</span><span class=\"pl-smi\">STREAM_ID_BRAND</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">never</span> <span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">VIDEO_ID_BRAND</span>: <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">symbol</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">VideoId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">MediaId</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">[</span><span class=\"pl-smi\">VIDEO_ID_BRAND</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">never</span> <span class=\"pl-kos\">}</span></pre></div>\n<p dir=\"auto\">By the way your example seems invalid.<br>\nWhy it should be valid to use a <code class=\"notranslate\">MediaId</code> in place of <code class=\"notranslate\">StreamId</code>? <code class=\"notranslate\">MediaId</code> is not a sutype of <code class=\"notranslate\">StreamId</code></p>",
        "createdAt": "2023-04-11T11:23:32Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1503152250",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5ZmFua",
        "author": {
          "login": "Shinigami92"
        },
        "authorAssociation": "NONE",
        "body": "Yeah, it's more the other way around\nIt's not a subtype but a super type 🤔\n\nLike I can cast a Media into a Stream, but not a Video to a Stream. Does this make sense?\n\nI will test your suggestion when I'm back home.",
        "bodyHTML": "<p dir=\"auto\">Yeah, it's more the other way around<br>\nIt's not a subtype but a super type 🤔</p>\n<p dir=\"auto\">Like I can cast a Media into a Stream, but not a Video to a Stream. Does this make sense?</p>\n<p dir=\"auto\">I will test your suggestion when I'm back home.</p>",
        "createdAt": "2023-04-11T11:28:05Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1503157146",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5ZmISg",
        "author": {
          "login": "Conaclos"
        },
        "authorAssociation": "NONE",
        "body": "I dont think so it is the place for this discussion...\r\n\r\nIf I understand correctly your example, I got the following type hierarchy.\r\nA `MediaaId` is a `NodeId`, a `StreamId` and a `VideoId` are `MediaaId`.\r\n\r\n```mermaid\r\nclassDiagram\r\n    class NodeId\r\n    class MediaId\r\n    class StreamId\r\n    class VideoId\r\n    NodeId <|-- MediaId\r\n    MediaId <|-- StreamId\r\n    MediaId <|-- VideoId\r\n```\r\n",
        "bodyHTML": "<p dir=\"auto\">I dont think so it is the place for this discussion...</p>\n<p dir=\"auto\">If I understand correctly your example, I got the following type hierarchy.<br>\nA <code class=\"notranslate\">MediaaId</code> is a <code class=\"notranslate\">NodeId</code>, a <code class=\"notranslate\">StreamId</code> and a <code class=\"notranslate\">VideoId</code> are <code class=\"notranslate\">MediaaId</code>.</p>\n<section class=\"js-render-needs-enrichment render-needs-enrichment position-relative\" data-identity=\"db6b290d-42fc-4718-8046-887d7ef9c73b\" data-host=\"https://viewscreen.githubusercontent.com\" data-src=\"https://viewscreen.githubusercontent.com/markdown/mermaid?docs_host=https%3A%2F%2Fdocs.github.com\" data-type=\"mermaid\" aria-label=\"mermaid rendered output container\">\n  <div class=\"js-render-enrichment-target\" data-json=\"{&quot;data&quot;:&quot;classDiagram\\n    class NodeId\\n    class MediaId\\n    class StreamId\\n    class VideoId\\n    NodeId &amp;lt;|-- MediaId\\n    MediaId &amp;lt;|-- StreamId\\n    MediaId &amp;lt;|-- VideoId\\n&quot;}\" data-plain=\"classDiagram\n    class NodeId\n    class MediaId\n    class StreamId\n    class VideoId\n    NodeId &lt;|-- MediaId\n    MediaId &lt;|-- StreamId\n    MediaId &lt;|-- VideoId\n\" dir=\"auto\">\n    <div class=\"render-plaintext-hidden\" dir=\"auto\">\n      <pre lang=\"mermaid\" aria-label=\"Raw mermaid code\" class=\"notranslate\">classDiagram\n    class NodeId\n    class MediaId\n    class StreamId\n    class VideoId\n    NodeId &lt;|-- MediaId\n    MediaId &lt;|-- StreamId\n    MediaId &lt;|-- VideoId\n</pre>\n    </div>\n  </div>\n  <span class=\"js-render-enrichment-loader d-flex flex-justify-center flex-items-center width-full\" style=\"min-height:100px\" role=\"presentation\">\n    <svg style=\"box-sizing: content-box; color: var(--color-icon-primary);\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" data-view-component=\"true\" class=\"octospinner mx-auto anim-rotate\">\n  <circle cx=\"8\" cy=\"8\" r=\"7\" stroke=\"currentColor\" stroke-opacity=\"0.25\" stroke-width=\"2\" vector-effect=\"non-scaling-stroke\" fill=\"none\"></circle>\n  <path d=\"M15 8a7.002 7.002 0 00-7-7\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" vector-effect=\"non-scaling-stroke\"></path>\n</svg>\n  </span>\n</section>\n",
        "createdAt": "2023-04-11T11:37:17Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1503167648",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 2
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5Zo4qv",
        "author": {
          "login": "Shinigami92"
        },
        "authorAssociation": "NONE",
        "body": "So the nearest what I could achieve was [TS Playground](https://www.typescriptlang.org/play?#code/CYUwxgNghgTiAEYD2A7AzgF3gOQPIFkBJbAQQBkB9AIQCUTsARALngFcUBLAR1YTQE8AtgCMkEALAAoEAA8ADkhhYM-OQmxJBHFFAgAeACoA+eAF54B+ADJ4Ab3gBtPEVKVa9BgF0WKEADcQGHgAXwBuKSlQSFgEZHQsPAYAUQpCBmo6RhZ2bl54ARExKRU1HCRQQmAzMq0dfUwYbQBzExt7J1xk1PT3Rm94XwCg4IjJKOg4RFRMeHwkhkISboyPbM4ePiFRCUkShHwQYA4oSuqNCqq2xzmFpbSVvp9-QJDR8Zip+PgAZQMaJJI+GWvWYbHWeQK22KqgQ3wwcCgglO5gORxOlzsjl+-0BwMyXieQ1ekki4AmsWmWAAamkkrg8aswblNoUdnt4FSOKAkMjZodjqcrg4acl6fcQf1Bi8RiTJAB6OXwAC0KvgGBAmDQypVUjiM0E-PR1QA5IIKFzjfAoFrUQLgOFJHqsA0QIjeca0ObgJbrT94a6kfbdZT4H4uSAeVVzMa-F6fVrOdzKg7g18zTIWLajeYDWjk-AFfkABZIVgQKrCBB+XRc1P6ij8TOG3kut32guKtAlssVqs14B1rBmgBeTbzUdD4cjoQ7xdL5fgldD-dGTvyFAzfoRgequbtM8LXfnveXEFrjpDnsbW4DLf9bYPne7C6X1bPA4vX09o5vbeqYaTdtCw4LVtDfc9B1DDcWETCNeT3dFHznHtFz7d9INja9YMjapW0DJCQPgMCV0-GZYx-bDeQAuCgKfY9UNPCDJAAM3YMAMA4VA1SgABrEA4W3SoAAo0BYATb2AABKFg-CQLk7CkeB4DgDBWBgFAHRlYpeP4+9AyEhDKkkpCjxQ18SIwHTxLbES9KMkznxPcCP0svjrP06jI2M2dCOI9DJCAA)\r\n\r\n```ts\r\ndeclare const NOMINAL_BRAND: unique symbol\r\nexport type Nominal<T> = T & { [NOMINAL_BRAND]: never };\r\n\r\ndeclare const NODE_ID_BRAND: unique symbol\r\ntype NodeId = Nominal<string> & { [NODE_ID_BRAND]: never }\r\n\r\ndeclare const MEDIA_ID_BRAND: unique symbol\r\ntype MediaId = NodeId & { [MEDIA_ID_BRAND]: never }\r\n\r\ndeclare const STREAM_ID_BRAND: unique symbol\r\ntype StreamId = MediaId & { [STREAM_ID_BRAND]: never }\r\n\r\ndeclare const VIDEO_ID_BRAND: unique symbol\r\ntype VideoId = MediaId & { [VIDEO_ID_BRAND]: never }\r\n\r\n// --- tests ---\r\nconst mediaId = 'm_id' as MediaId;\r\nconst streamId = 's_id' as StreamId;\r\nconst videoId = 'v_id' as VideoId;\r\n\r\nconst m_x: MediaId = mediaId; // should be valid\r\nconst m_y: MediaId = streamId; // should be valid\r\nconst m_z: MediaId = videoId; // should be valid\r\n\r\nconst s_x: StreamId = mediaId; // should be valid\r\nconst s_y: StreamId = streamId; // should be valid\r\nconst s_z: StreamId = videoId; // is invalid\r\n\r\nconst v_x: VideoId = mediaId; // should be valid\r\nconst v_y: VideoId = streamId; // is invalid\r\nconst v_z: VideoId = videoId; // should be valid\r\n\r\nfunction takeStreamId(s: StreamId): void {\r\n  return;\r\n}\r\n\r\ntakeStreamId(mediaId); // should be valid\r\ntakeStreamId(streamId); // should be valid\r\ntakeStreamId(videoId); // is invalid\r\n```\r\n\r\nbut I think this is fine and for the rest I could just use casts :thinking: \r\nSo at least I have the benefit now of e.g. assigning a streamId to a mediaId",
        "bodyHTML": "<p dir=\"auto\">So the nearest what I could achieve was <a href=\"https://www.typescriptlang.org/play?#code/CYUwxgNghgTiAEYD2A7AzgF3gOQPIFkBJbAQQBkB9AIQCUTsARALngFcUBLAR1YTQE8AtgCMkEALAAoEAA8ADkhhYM-OQmxJBHFFAgAeACoA+eAF54B+ADJ4Ab3gBtPEVKVa9BgF0WKEADcQGHgAXwBuKSlQSFgEZHQsPAYAUQpCBmo6RhZ2bl54ARExKRU1HCRQQmAzMq0dfUwYbQBzExt7J1xk1PT3Rm94XwCg4IjJKOg4RFRMeHwkhkISboyPbM4ePiFRCUkShHwQYA4oSuqNCqq2xzmFpbSVvp9-QJDR8Zip+PgAZQMaJJI+GWvWYbHWeQK22KqgQ3wwcCgglO5gORxOlzsjl+-0BwMyXieQ1ekki4AmsWmWAAamkkrg8aswblNoUdnt4FSOKAkMjZodjqcrg4acl6fcQf1Bi8RiTJAB6OXwAC0KvgGBAmDQypVUjiM0E-PR1QA5IIKFzjfAoFrUQLgOFJHqsA0QIjeca0ObgJbrT94a6kfbdZT4H4uSAeVVzMa-F6fVrOdzKg7g18zTIWLajeYDWjk-AFfkABZIVgQKrCBB+XRc1P6ij8TOG3kut32guKtAlssVqs14B1rBmgBeTbzUdD4cjoQ7xdL5fgldD-dGTvyFAzfoRgequbtM8LXfnveXEFrjpDnsbW4DLf9bYPne7C6X1bPA4vX09o5vbeqYaTdtCw4LVtDfc9B1DDcWETCNeT3dFHznHtFz7d9INja9YMjapW0DJCQPgMCV0-GZYx-bDeQAuCgKfY9UNPCDJAAM3YMAMA4VA1SgABrEA4W3SoAAo0BYATb2AABKFg-CQLk7CkeB4DgDBWBgFAHRlYpeP4+9AyEhDKkkpCjxQ18SIwHTxLbES9KMkznxPcCP0svjrP06jI2M2dCOI9DJCAA\" rel=\"nofollow\">TS Playground</a></p>\n<div class=\"highlight highlight-source-ts notranslate position-relative overflow-auto\" dir=\"auto\" data-snippet-clipboard-copy-content=\"declare const NOMINAL_BRAND: unique symbol\nexport type Nominal&lt;T&gt; = T &amp; { [NOMINAL_BRAND]: never };\n\ndeclare const NODE_ID_BRAND: unique symbol\ntype NodeId = Nominal&lt;string&gt; &amp; { [NODE_ID_BRAND]: never }\n\ndeclare const MEDIA_ID_BRAND: unique symbol\ntype MediaId = NodeId &amp; { [MEDIA_ID_BRAND]: never }\n\ndeclare const STREAM_ID_BRAND: unique symbol\ntype StreamId = MediaId &amp; { [STREAM_ID_BRAND]: never }\n\ndeclare const VIDEO_ID_BRAND: unique symbol\ntype VideoId = MediaId &amp; { [VIDEO_ID_BRAND]: never }\n\n// --- tests ---\nconst mediaId = 'm_id' as MediaId;\nconst streamId = 's_id' as StreamId;\nconst videoId = 'v_id' as VideoId;\n\nconst m_x: MediaId = mediaId; // should be valid\nconst m_y: MediaId = streamId; // should be valid\nconst m_z: MediaId = videoId; // should be valid\n\nconst s_x: StreamId = mediaId; // should be valid\nconst s_y: StreamId = streamId; // should be valid\nconst s_z: StreamId = videoId; // is invalid\n\nconst v_x: VideoId = mediaId; // should be valid\nconst v_y: VideoId = streamId; // is invalid\nconst v_z: VideoId = videoId; // should be valid\n\nfunction takeStreamId(s: StreamId): void {\n  return;\n}\n\ntakeStreamId(mediaId); // should be valid\ntakeStreamId(streamId); // should be valid\ntakeStreamId(videoId); // is invalid\"><pre class=\"notranslate\"><span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">NOMINAL_BRAND</span>: <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">symbol</span>\n<span class=\"pl-k\">export</span> <span class=\"pl-k\">type</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-c1\">&lt;</span><span class=\"pl-smi\">T</span><span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">T</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">[</span><span class=\"pl-smi\">NOMINAL_BRAND</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">never</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">NODE_ID_BRAND</span>: <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">symbol</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">NodeId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">Nominal</span><span class=\"pl-kos\">&lt;</span><span class=\"pl-smi\">string</span><span class=\"pl-kos\">&gt;</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">[</span><span class=\"pl-smi\">NODE_ID_BRAND</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">never</span> <span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">MEDIA_ID_BRAND</span>: <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">symbol</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">MediaId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">NodeId</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">[</span><span class=\"pl-smi\">MEDIA_ID_BRAND</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">never</span> <span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">STREAM_ID_BRAND</span>: <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">symbol</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">StreamId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">MediaId</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">[</span><span class=\"pl-smi\">STREAM_ID_BRAND</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">never</span> <span class=\"pl-kos\">}</span>\n\n<span class=\"pl-k\">declare</span> <span class=\"pl-k\">const</span> <span class=\"pl-smi\">VIDEO_ID_BRAND</span>: <span class=\"pl-s1\">unique</span> <span class=\"pl-smi\">symbol</span>\n<span class=\"pl-k\">type</span> <span class=\"pl-smi\">VideoId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-smi\">MediaId</span> <span class=\"pl-c1\">&amp;</span> <span class=\"pl-kos\">{</span> <span class=\"pl-kos\">[</span><span class=\"pl-smi\">VIDEO_ID_BRAND</span><span class=\"pl-kos\">]</span>: <span class=\"pl-smi\">never</span> <span class=\"pl-kos\">}</span>\n\n<span class=\"pl-c\">// --- tests ---</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">mediaId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'m_id'</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">MediaId</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">streamId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'s_id'</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">StreamId</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">videoId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s\">'v_id'</span> <span class=\"pl-k\">as</span> <span class=\"pl-smi\">VideoId</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">m_x</span>: <span class=\"pl-smi\">MediaId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">mediaId</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// should be valid</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">m_y</span>: <span class=\"pl-smi\">MediaId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">streamId</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// should be valid</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">m_z</span>: <span class=\"pl-smi\">MediaId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">videoId</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// should be valid</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">s_x</span>: <span class=\"pl-smi\">StreamId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">mediaId</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// should be valid</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">s_y</span>: <span class=\"pl-smi\">StreamId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">streamId</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// should be valid</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">s_z</span>: <span class=\"pl-smi\">StreamId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">videoId</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// is invalid</span>\n\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">v_x</span>: <span class=\"pl-smi\">VideoId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">mediaId</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// should be valid</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">v_y</span>: <span class=\"pl-smi\">VideoId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">streamId</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// is invalid</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">v_z</span>: <span class=\"pl-smi\">VideoId</span> <span class=\"pl-c1\">=</span> <span class=\"pl-s1\">videoId</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// should be valid</span>\n\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">takeStreamId</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">s</span>: <span class=\"pl-smi\">StreamId</span><span class=\"pl-kos\">)</span>: <span class=\"pl-smi\"><span class=\"pl-k\">void</span></span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">return</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-en\">takeStreamId</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">mediaId</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// should be valid</span>\n<span class=\"pl-en\">takeStreamId</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">streamId</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// should be valid</span>\n<span class=\"pl-en\">takeStreamId</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">videoId</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// is invalid</span></pre></div>\n<p dir=\"auto\">but I think this is fine and for the rest I could just use casts 🤔<br>\nSo at least I have the benefit now of e.g. assigning a streamId to a mediaId</p>",
        "createdAt": "2023-04-11T18:31:28Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1503890095",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      },
      {
        "__typename": "IssueComment",
        "id": "IC_kwDOAT9aAc5Zv8jB",
        "author": {
          "login": "StreetStrider"
        },
        "authorAssociation": "NONE",
        "body": "@shelby3 \r\n1. I believe, you can throw `Nominal` and `Node` entities out. They does not do anything special. You already have branding on your real entities, so virtual entities are not required. This is not a «base class» situation in any way, because branding is implemented directly on your real types. This is more like mixing in a trait.\r\n1. You can have as much brands as you need, so subtyping is still possible, and your code is an example. But, having a brand is like implementing a mixin, so it's not only subtype-supertype, actually any combinations possible.\r\n1. If you don't like casts, the good way to get rid of them is to designate some constructor functions which will produce branded values (and to make casts inside, if compiler nag). That way, you produce branded values only via this constructors and don't use casts outside and have strong guarantees anywhere outside.",
        "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention notranslate\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/shelby3/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/shelby3\">@shelby3</a></p>\n<ol dir=\"auto\">\n<li>I believe, you can throw <code class=\"notranslate\">Nominal</code> and <code class=\"notranslate\">Node</code> entities out. They does not do anything special. You already have branding on your real entities, so virtual entities are not required. This is not a «base class» situation in any way, because branding is implemented directly on your real types. This is more like mixing in a trait.</li>\n<li>You can have as much brands as you need, so subtyping is still possible, and your code is an example. But, having a brand is like implementing a mixin, so it's not only subtype-supertype, actually any combinations possible.</li>\n<li>If you don't like casts, the good way to get rid of them is to designate some constructor functions which will produce branded values (and to make casts inside, if compiler nag). That way, you produce branded values only via this constructors and don't use casts outside and have strong guarantees anywhere outside.</li>\n</ol>",
        "createdAt": "2023-04-12T18:29:39Z",
        "url": "https://github.com/microsoft/TypeScript/issues/202#issuecomment-1505740993",
        "minimizedReason": null,
        "isMinimized": false,
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "reactors": {
              "totalCount": 1
            }
          },
          {
            "content": "THUMBS_DOWN",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "LAUGH",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HOORAY",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "CONFUSED",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "HEART",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "ROCKET",
            "reactors": {
              "totalCount": 0
            }
          },
          {
            "content": "EYES",
            "reactors": {
              "totalCount": 0
            }
          }
        ]
      }
    ]
  }
}